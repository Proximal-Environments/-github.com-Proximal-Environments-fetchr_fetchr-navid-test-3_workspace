// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v5.29.3
// source: base/user_billing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "base";

export enum PaymentMethodStatus {
  PAYMENT_METHOD_STATUS_UNSPECIFIED = 0,
  PAYMENT_METHOD_STATUS_VALID = 1,
  PAYMENT_METHOD_STATUS_NO_PAYMENT_METHOD = 2,
  PAYMENT_METHOD_STATUS_EXPIRED = 3,
  UNRECOGNIZED = -1,
}

export function paymentMethodStatusFromJSON(object: any): PaymentMethodStatus {
  switch (object) {
    case 0:
    case "PAYMENT_METHOD_STATUS_UNSPECIFIED":
      return PaymentMethodStatus.PAYMENT_METHOD_STATUS_UNSPECIFIED;
    case 1:
    case "PAYMENT_METHOD_STATUS_VALID":
      return PaymentMethodStatus.PAYMENT_METHOD_STATUS_VALID;
    case 2:
    case "PAYMENT_METHOD_STATUS_NO_PAYMENT_METHOD":
      return PaymentMethodStatus.PAYMENT_METHOD_STATUS_NO_PAYMENT_METHOD;
    case 3:
    case "PAYMENT_METHOD_STATUS_EXPIRED":
      return PaymentMethodStatus.PAYMENT_METHOD_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentMethodStatus.UNRECOGNIZED;
  }
}

export function paymentMethodStatusToJSON(object: PaymentMethodStatus): string {
  switch (object) {
    case PaymentMethodStatus.PAYMENT_METHOD_STATUS_UNSPECIFIED:
      return "PAYMENT_METHOD_STATUS_UNSPECIFIED";
    case PaymentMethodStatus.PAYMENT_METHOD_STATUS_VALID:
      return "PAYMENT_METHOD_STATUS_VALID";
    case PaymentMethodStatus.PAYMENT_METHOD_STATUS_NO_PAYMENT_METHOD:
      return "PAYMENT_METHOD_STATUS_NO_PAYMENT_METHOD";
    case PaymentMethodStatus.PAYMENT_METHOD_STATUS_EXPIRED:
      return "PAYMENT_METHOD_STATUS_EXPIRED";
    case PaymentMethodStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines the frequency of subscription payments */
export enum SubscriptionCadence {
  SUBSCRIPTION_CADENCE_UNSPECIFIED = 0,
  SUBSCRIPTION_CADENCE_MONTHLY = 1,
  SUBSCRIPTION_CADENCE_QUARTERLY = 2,
  SUBSCRIPTION_CADENCE_ANNUALLY = 3,
  UNRECOGNIZED = -1,
}

export function subscriptionCadenceFromJSON(object: any): SubscriptionCadence {
  switch (object) {
    case 0:
    case "SUBSCRIPTION_CADENCE_UNSPECIFIED":
      return SubscriptionCadence.SUBSCRIPTION_CADENCE_UNSPECIFIED;
    case 1:
    case "SUBSCRIPTION_CADENCE_MONTHLY":
      return SubscriptionCadence.SUBSCRIPTION_CADENCE_MONTHLY;
    case 2:
    case "SUBSCRIPTION_CADENCE_QUARTERLY":
      return SubscriptionCadence.SUBSCRIPTION_CADENCE_QUARTERLY;
    case 3:
    case "SUBSCRIPTION_CADENCE_ANNUALLY":
      return SubscriptionCadence.SUBSCRIPTION_CADENCE_ANNUALLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubscriptionCadence.UNRECOGNIZED;
  }
}

export function subscriptionCadenceToJSON(object: SubscriptionCadence): string {
  switch (object) {
    case SubscriptionCadence.SUBSCRIPTION_CADENCE_UNSPECIFIED:
      return "SUBSCRIPTION_CADENCE_UNSPECIFIED";
    case SubscriptionCadence.SUBSCRIPTION_CADENCE_MONTHLY:
      return "SUBSCRIPTION_CADENCE_MONTHLY";
    case SubscriptionCadence.SUBSCRIPTION_CADENCE_QUARTERLY:
      return "SUBSCRIPTION_CADENCE_QUARTERLY";
    case SubscriptionCadence.SUBSCRIPTION_CADENCE_ANNUALLY:
      return "SUBSCRIPTION_CADENCE_ANNUALLY";
    case SubscriptionCadence.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Common subscription fields */
export interface SubscriptionDetails {
  cadence: SubscriptionCadence;
  expirationDate: number;
}

/** Provider-specific subscription details */
export interface StripeSubscription {
  subscriptionId: string;
  customerId: string;
  details: SubscriptionDetails | undefined;
}

export interface RevenueCatSubscription {
  details: SubscriptionDetails | undefined;
}

export interface UserSubscription {
  stripeSubscription?: StripeSubscription | undefined;
  revenueCatSubscription?: RevenueCatSubscription | undefined;
}

export interface UserBilling {
  stripeCustomerId?: string | undefined;
  paymentMethodStatus?: PaymentMethodStatus | undefined;
  subscription?: UserSubscription | undefined;
}

function createBaseSubscriptionDetails(): SubscriptionDetails {
  return { cadence: 0, expirationDate: 0 };
}

export const SubscriptionDetails: MessageFns<SubscriptionDetails> = {
  encode(message: SubscriptionDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cadence !== 0) {
      writer.uint32(8).int32(message.cadence);
    }
    if (message.expirationDate !== 0) {
      writer.uint32(16).int64(message.expirationDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cadence = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expirationDate = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionDetails {
    return {
      cadence: isSet(object.cadence) ? subscriptionCadenceFromJSON(object.cadence) : 0,
      expirationDate: isSet(object.expirationDate) ? globalThis.Number(object.expirationDate) : 0,
    };
  },

  toJSON(message: SubscriptionDetails): unknown {
    const obj: any = {};
    if (message.cadence !== 0) {
      obj.cadence = subscriptionCadenceToJSON(message.cadence);
    }
    if (message.expirationDate !== 0) {
      obj.expirationDate = Math.round(message.expirationDate);
    }
    return obj;
  },
};

function createBaseStripeSubscription(): StripeSubscription {
  return { subscriptionId: "", customerId: "", details: undefined };
}

export const StripeSubscription: MessageFns<StripeSubscription> = {
  encode(message: StripeSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.details !== undefined) {
      SubscriptionDetails.encode(message.details, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = SubscriptionDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeSubscription {
    return {
      subscriptionId: isSet(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      details: isSet(object.details) ? SubscriptionDetails.fromJSON(object.details) : undefined,
    };
  },

  toJSON(message: StripeSubscription): unknown {
    const obj: any = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.details !== undefined) {
      obj.details = SubscriptionDetails.toJSON(message.details);
    }
    return obj;
  },
};

function createBaseRevenueCatSubscription(): RevenueCatSubscription {
  return { details: undefined };
}

export const RevenueCatSubscription: MessageFns<RevenueCatSubscription> = {
  encode(message: RevenueCatSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.details !== undefined) {
      SubscriptionDetails.encode(message.details, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevenueCatSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevenueCatSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.details = SubscriptionDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevenueCatSubscription {
    return { details: isSet(object.details) ? SubscriptionDetails.fromJSON(object.details) : undefined };
  },

  toJSON(message: RevenueCatSubscription): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = SubscriptionDetails.toJSON(message.details);
    }
    return obj;
  },
};

function createBaseUserSubscription(): UserSubscription {
  return { stripeSubscription: undefined, revenueCatSubscription: undefined };
}

export const UserSubscription: MessageFns<UserSubscription> = {
  encode(message: UserSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stripeSubscription !== undefined) {
      StripeSubscription.encode(message.stripeSubscription, writer.uint32(26).fork()).join();
    }
    if (message.revenueCatSubscription !== undefined) {
      RevenueCatSubscription.encode(message.revenueCatSubscription, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stripeSubscription = StripeSubscription.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.revenueCatSubscription = RevenueCatSubscription.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSubscription {
    return {
      stripeSubscription: isSet(object.stripeSubscription)
        ? StripeSubscription.fromJSON(object.stripeSubscription)
        : undefined,
      revenueCatSubscription: isSet(object.revenueCatSubscription)
        ? RevenueCatSubscription.fromJSON(object.revenueCatSubscription)
        : undefined,
    };
  },

  toJSON(message: UserSubscription): unknown {
    const obj: any = {};
    if (message.stripeSubscription !== undefined) {
      obj.stripeSubscription = StripeSubscription.toJSON(message.stripeSubscription);
    }
    if (message.revenueCatSubscription !== undefined) {
      obj.revenueCatSubscription = RevenueCatSubscription.toJSON(message.revenueCatSubscription);
    }
    return obj;
  },
};

function createBaseUserBilling(): UserBilling {
  return { stripeCustomerId: undefined, paymentMethodStatus: undefined, subscription: undefined };
}

export const UserBilling: MessageFns<UserBilling> = {
  encode(message: UserBilling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stripeCustomerId !== undefined) {
      writer.uint32(10).string(message.stripeCustomerId);
    }
    if (message.paymentMethodStatus !== undefined) {
      writer.uint32(16).int32(message.paymentMethodStatus);
    }
    if (message.subscription !== undefined) {
      UserSubscription.encode(message.subscription, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserBilling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBilling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stripeCustomerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.paymentMethodStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscription = UserSubscription.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserBilling {
    return {
      stripeCustomerId: isSet(object.stripeCustomerId) ? globalThis.String(object.stripeCustomerId) : undefined,
      paymentMethodStatus: isSet(object.paymentMethodStatus)
        ? paymentMethodStatusFromJSON(object.paymentMethodStatus)
        : undefined,
      subscription: isSet(object.subscription) ? UserSubscription.fromJSON(object.subscription) : undefined,
    };
  },

  toJSON(message: UserBilling): unknown {
    const obj: any = {};
    if (message.stripeCustomerId !== undefined) {
      obj.stripeCustomerId = message.stripeCustomerId;
    }
    if (message.paymentMethodStatus !== undefined) {
      obj.paymentMethodStatus = paymentMethodStatusToJSON(message.paymentMethodStatus);
    }
    if (message.subscription !== undefined) {
      obj.subscription = UserSubscription.toJSON(message.subscription);
    }
    return obj;
  },
};

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
