// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v5.29.3
// source: base/base.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Message } from "../core/core";
import { Thread } from "./comments";
import { UserBilling } from "./user_billing";

export const protobufPackage = "base";

export enum ProductCategory {
  PRODUCT_CATEGORY_UNSPECIFIED = 0,
  PRODUCT_CATEGORY_TOPS = 1,
  PRODUCT_CATEGORY_BOTTOMS = 2,
  PRODUCT_CATEGORY_ACCESSORIES = 3,
  PRODUCT_CATEGORY_SHOES = 4,
  PRODUCT_CATEGORY_DRESSES = 5,
  PRODUCT_CATEGORY_UNDERWEAR = 6,
  PRODUCT_CATEGORY_OTHER = 7,
  UNRECOGNIZED = -1,
}

export function productCategoryFromJSON(object: any): ProductCategory {
  switch (object) {
    case 0:
    case "PRODUCT_CATEGORY_UNSPECIFIED":
      return ProductCategory.PRODUCT_CATEGORY_UNSPECIFIED;
    case 1:
    case "PRODUCT_CATEGORY_TOPS":
      return ProductCategory.PRODUCT_CATEGORY_TOPS;
    case 2:
    case "PRODUCT_CATEGORY_BOTTOMS":
      return ProductCategory.PRODUCT_CATEGORY_BOTTOMS;
    case 3:
    case "PRODUCT_CATEGORY_ACCESSORIES":
      return ProductCategory.PRODUCT_CATEGORY_ACCESSORIES;
    case 4:
    case "PRODUCT_CATEGORY_SHOES":
      return ProductCategory.PRODUCT_CATEGORY_SHOES;
    case 5:
    case "PRODUCT_CATEGORY_DRESSES":
      return ProductCategory.PRODUCT_CATEGORY_DRESSES;
    case 6:
    case "PRODUCT_CATEGORY_UNDERWEAR":
      return ProductCategory.PRODUCT_CATEGORY_UNDERWEAR;
    case 7:
    case "PRODUCT_CATEGORY_OTHER":
      return ProductCategory.PRODUCT_CATEGORY_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProductCategory.UNRECOGNIZED;
  }
}

export function productCategoryToJSON(object: ProductCategory): string {
  switch (object) {
    case ProductCategory.PRODUCT_CATEGORY_UNSPECIFIED:
      return "PRODUCT_CATEGORY_UNSPECIFIED";
    case ProductCategory.PRODUCT_CATEGORY_TOPS:
      return "PRODUCT_CATEGORY_TOPS";
    case ProductCategory.PRODUCT_CATEGORY_BOTTOMS:
      return "PRODUCT_CATEGORY_BOTTOMS";
    case ProductCategory.PRODUCT_CATEGORY_ACCESSORIES:
      return "PRODUCT_CATEGORY_ACCESSORIES";
    case ProductCategory.PRODUCT_CATEGORY_SHOES:
      return "PRODUCT_CATEGORY_SHOES";
    case ProductCategory.PRODUCT_CATEGORY_DRESSES:
      return "PRODUCT_CATEGORY_DRESSES";
    case ProductCategory.PRODUCT_CATEGORY_UNDERWEAR:
      return "PRODUCT_CATEGORY_UNDERWEAR";
    case ProductCategory.PRODUCT_CATEGORY_OTHER:
      return "PRODUCT_CATEGORY_OTHER";
    case ProductCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PreferenceType {
  UNSPECIFIED = 0,
  LIKE = 1,
  DISLIKE = 2,
  SUPERLIKE = 3,
  MAYBE = 4,
  UNRECOGNIZED = -1,
}

export function preferenceTypeFromJSON(object: any): PreferenceType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return PreferenceType.UNSPECIFIED;
    case 1:
    case "LIKE":
      return PreferenceType.LIKE;
    case 2:
    case "DISLIKE":
      return PreferenceType.DISLIKE;
    case 3:
    case "SUPERLIKE":
      return PreferenceType.SUPERLIKE;
    case 4:
    case "MAYBE":
      return PreferenceType.MAYBE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PreferenceType.UNRECOGNIZED;
  }
}

export function preferenceTypeToJSON(object: PreferenceType): string {
  switch (object) {
    case PreferenceType.UNSPECIFIED:
      return "UNSPECIFIED";
    case PreferenceType.LIKE:
      return "LIKE";
    case PreferenceType.DISLIKE:
      return "DISLIKE";
    case PreferenceType.SUPERLIKE:
      return "SUPERLIKE";
    case PreferenceType.MAYBE:
      return "MAYBE";
    case PreferenceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Gender {
  GENDER_UNSPECIFIED = 0,
  GENDER_UNISEX = 1,
  GENDER_MALE = 2,
  GENDER_FEMALE = 3,
  UNRECOGNIZED = -1,
}

export function genderFromJSON(object: any): Gender {
  switch (object) {
    case 0:
    case "GENDER_UNSPECIFIED":
      return Gender.GENDER_UNSPECIFIED;
    case 1:
    case "GENDER_UNISEX":
      return Gender.GENDER_UNISEX;
    case 2:
    case "GENDER_MALE":
      return Gender.GENDER_MALE;
    case 3:
    case "GENDER_FEMALE":
      return Gender.GENDER_FEMALE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Gender.UNRECOGNIZED;
  }
}

export function genderToJSON(object: Gender): string {
  switch (object) {
    case Gender.GENDER_UNSPECIFIED:
      return "GENDER_UNSPECIFIED";
    case Gender.GENDER_UNISEX:
      return "GENDER_UNISEX";
    case Gender.GENDER_MALE:
      return "GENDER_MALE";
    case Gender.GENDER_FEMALE:
      return "GENDER_FEMALE";
    case Gender.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProductFit {
  PRODUCT_FIT_UNSPECIFIED = 0,
  PRODUCT_FIT_SLIM = 1,
  PRODUCT_FIT_REGULAR = 2,
  PRODUCT_FIT_LOOSE = 3,
  PRODUCT_FIT_RELAXED = 4,
  PRODUCT_FIT_OVERSIZED = 5,
  PRODUCT_FIT_ATHLETIC = 6,
  PRODUCT_FIT_TAILORED = 7,
  PRODUCT_FIT_BAGGY = 8,
  PRODUCT_FIT_CROPPED = 9,
  UNRECOGNIZED = -1,
}

export function productFitFromJSON(object: any): ProductFit {
  switch (object) {
    case 0:
    case "PRODUCT_FIT_UNSPECIFIED":
      return ProductFit.PRODUCT_FIT_UNSPECIFIED;
    case 1:
    case "PRODUCT_FIT_SLIM":
      return ProductFit.PRODUCT_FIT_SLIM;
    case 2:
    case "PRODUCT_FIT_REGULAR":
      return ProductFit.PRODUCT_FIT_REGULAR;
    case 3:
    case "PRODUCT_FIT_LOOSE":
      return ProductFit.PRODUCT_FIT_LOOSE;
    case 4:
    case "PRODUCT_FIT_RELAXED":
      return ProductFit.PRODUCT_FIT_RELAXED;
    case 5:
    case "PRODUCT_FIT_OVERSIZED":
      return ProductFit.PRODUCT_FIT_OVERSIZED;
    case 6:
    case "PRODUCT_FIT_ATHLETIC":
      return ProductFit.PRODUCT_FIT_ATHLETIC;
    case 7:
    case "PRODUCT_FIT_TAILORED":
      return ProductFit.PRODUCT_FIT_TAILORED;
    case 8:
    case "PRODUCT_FIT_BAGGY":
      return ProductFit.PRODUCT_FIT_BAGGY;
    case 9:
    case "PRODUCT_FIT_CROPPED":
      return ProductFit.PRODUCT_FIT_CROPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProductFit.UNRECOGNIZED;
  }
}

export function productFitToJSON(object: ProductFit): string {
  switch (object) {
    case ProductFit.PRODUCT_FIT_UNSPECIFIED:
      return "PRODUCT_FIT_UNSPECIFIED";
    case ProductFit.PRODUCT_FIT_SLIM:
      return "PRODUCT_FIT_SLIM";
    case ProductFit.PRODUCT_FIT_REGULAR:
      return "PRODUCT_FIT_REGULAR";
    case ProductFit.PRODUCT_FIT_LOOSE:
      return "PRODUCT_FIT_LOOSE";
    case ProductFit.PRODUCT_FIT_RELAXED:
      return "PRODUCT_FIT_RELAXED";
    case ProductFit.PRODUCT_FIT_OVERSIZED:
      return "PRODUCT_FIT_OVERSIZED";
    case ProductFit.PRODUCT_FIT_ATHLETIC:
      return "PRODUCT_FIT_ATHLETIC";
    case ProductFit.PRODUCT_FIT_TAILORED:
      return "PRODUCT_FIT_TAILORED";
    case ProductFit.PRODUCT_FIT_BAGGY:
      return "PRODUCT_FIT_BAGGY";
    case ProductFit.PRODUCT_FIT_CROPPED:
      return "PRODUCT_FIT_CROPPED";
    case ProductFit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UserRole {
  USER_ROLE_CUSTOMER = 0,
  USER_ROLE_STYLIST = 1,
  USER_ROLE_ADMIN = 2,
  USER_ROLE_SUPER_STYLIST = 3,
  UNRECOGNIZED = -1,
}

export function userRoleFromJSON(object: any): UserRole {
  switch (object) {
    case 0:
    case "USER_ROLE_CUSTOMER":
      return UserRole.USER_ROLE_CUSTOMER;
    case 1:
    case "USER_ROLE_STYLIST":
      return UserRole.USER_ROLE_STYLIST;
    case 2:
    case "USER_ROLE_ADMIN":
      return UserRole.USER_ROLE_ADMIN;
    case 3:
    case "USER_ROLE_SUPER_STYLIST":
      return UserRole.USER_ROLE_SUPER_STYLIST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserRole.UNRECOGNIZED;
  }
}

export function userRoleToJSON(object: UserRole): string {
  switch (object) {
    case UserRole.USER_ROLE_CUSTOMER:
      return "USER_ROLE_CUSTOMER";
    case UserRole.USER_ROLE_STYLIST:
      return "USER_ROLE_STYLIST";
    case UserRole.USER_ROLE_ADMIN:
      return "USER_ROLE_ADMIN";
    case UserRole.USER_ROLE_SUPER_STYLIST:
      return "USER_ROLE_SUPER_STYLIST";
    case UserRole.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MembershipType {
  MEMBERSHIP_TYPE_UNSPECIFIED = 0,
  MEMBERSHIP_TYPE_FREE = 1,
  MEMBERSHIP_TYPE_PRO = 2,
  UNRECOGNIZED = -1,
}

export function membershipTypeFromJSON(object: any): MembershipType {
  switch (object) {
    case 0:
    case "MEMBERSHIP_TYPE_UNSPECIFIED":
      return MembershipType.MEMBERSHIP_TYPE_UNSPECIFIED;
    case 1:
    case "MEMBERSHIP_TYPE_FREE":
      return MembershipType.MEMBERSHIP_TYPE_FREE;
    case 2:
    case "MEMBERSHIP_TYPE_PRO":
      return MembershipType.MEMBERSHIP_TYPE_PRO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MembershipType.UNRECOGNIZED;
  }
}

export function membershipTypeToJSON(object: MembershipType): string {
  switch (object) {
    case MembershipType.MEMBERSHIP_TYPE_UNSPECIFIED:
      return "MEMBERSHIP_TYPE_UNSPECIFIED";
    case MembershipType.MEMBERSHIP_TYPE_FREE:
      return "MEMBERSHIP_TYPE_FREE";
    case MembershipType.MEMBERSHIP_TYPE_PRO:
      return "MEMBERSHIP_TYPE_PRO";
    case MembershipType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Platform {
  PLATFORM_UNSPECIFIED = 0,
  PLATFORM_IOS = 1,
  PLATFORM_ANDROID = 2,
  PLATFORM_WEB = 3,
  UNRECOGNIZED = -1,
}

export function platformFromJSON(object: any): Platform {
  switch (object) {
    case 0:
    case "PLATFORM_UNSPECIFIED":
      return Platform.PLATFORM_UNSPECIFIED;
    case 1:
    case "PLATFORM_IOS":
      return Platform.PLATFORM_IOS;
    case 2:
    case "PLATFORM_ANDROID":
      return Platform.PLATFORM_ANDROID;
    case 3:
    case "PLATFORM_WEB":
      return Platform.PLATFORM_WEB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Platform.UNRECOGNIZED;
  }
}

export function platformToJSON(object: Platform): string {
  switch (object) {
    case Platform.PLATFORM_UNSPECIFIED:
      return "PLATFORM_UNSPECIFIED";
    case Platform.PLATFORM_IOS:
      return "PLATFORM_IOS";
    case Platform.PLATFORM_ANDROID:
      return "PLATFORM_ANDROID";
    case Platform.PLATFORM_WEB:
      return "PLATFORM_WEB";
    case Platform.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SizeTop {
  SIZE_TOP_UNSPECIFIED = 0,
  SIZE_TOP_XS = 1,
  SIZE_TOP_S = 2,
  SIZE_TOP_M = 3,
  SIZE_TOP_L = 4,
  SIZE_TOP_XL = 5,
  SIZE_TOP_XXL = 6,
  UNRECOGNIZED = -1,
}

export function sizeTopFromJSON(object: any): SizeTop {
  switch (object) {
    case 0:
    case "SIZE_TOP_UNSPECIFIED":
      return SizeTop.SIZE_TOP_UNSPECIFIED;
    case 1:
    case "SIZE_TOP_XS":
      return SizeTop.SIZE_TOP_XS;
    case 2:
    case "SIZE_TOP_S":
      return SizeTop.SIZE_TOP_S;
    case 3:
    case "SIZE_TOP_M":
      return SizeTop.SIZE_TOP_M;
    case 4:
    case "SIZE_TOP_L":
      return SizeTop.SIZE_TOP_L;
    case 5:
    case "SIZE_TOP_XL":
      return SizeTop.SIZE_TOP_XL;
    case 6:
    case "SIZE_TOP_XXL":
      return SizeTop.SIZE_TOP_XXL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SizeTop.UNRECOGNIZED;
  }
}

export function sizeTopToJSON(object: SizeTop): string {
  switch (object) {
    case SizeTop.SIZE_TOP_UNSPECIFIED:
      return "SIZE_TOP_UNSPECIFIED";
    case SizeTop.SIZE_TOP_XS:
      return "SIZE_TOP_XS";
    case SizeTop.SIZE_TOP_S:
      return "SIZE_TOP_S";
    case SizeTop.SIZE_TOP_M:
      return "SIZE_TOP_M";
    case SizeTop.SIZE_TOP_L:
      return "SIZE_TOP_L";
    case SizeTop.SIZE_TOP_XL:
      return "SIZE_TOP_XL";
    case SizeTop.SIZE_TOP_XXL:
      return "SIZE_TOP_XXL";
    case SizeTop.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SizeBottom {
  SIZE_BOTTOM_UNSPECIFIED = 0,
  SIZE_BOTTOM_XS = 1,
  SIZE_BOTTOM_S = 2,
  SIZE_BOTTOM_M = 3,
  SIZE_BOTTOM_L = 4,
  SIZE_BOTTOM_XL = 5,
  UNRECOGNIZED = -1,
}

export function sizeBottomFromJSON(object: any): SizeBottom {
  switch (object) {
    case 0:
    case "SIZE_BOTTOM_UNSPECIFIED":
      return SizeBottom.SIZE_BOTTOM_UNSPECIFIED;
    case 1:
    case "SIZE_BOTTOM_XS":
      return SizeBottom.SIZE_BOTTOM_XS;
    case 2:
    case "SIZE_BOTTOM_S":
      return SizeBottom.SIZE_BOTTOM_S;
    case 3:
    case "SIZE_BOTTOM_M":
      return SizeBottom.SIZE_BOTTOM_M;
    case 4:
    case "SIZE_BOTTOM_L":
      return SizeBottom.SIZE_BOTTOM_L;
    case 5:
    case "SIZE_BOTTOM_XL":
      return SizeBottom.SIZE_BOTTOM_XL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SizeBottom.UNRECOGNIZED;
  }
}

export function sizeBottomToJSON(object: SizeBottom): string {
  switch (object) {
    case SizeBottom.SIZE_BOTTOM_UNSPECIFIED:
      return "SIZE_BOTTOM_UNSPECIFIED";
    case SizeBottom.SIZE_BOTTOM_XS:
      return "SIZE_BOTTOM_XS";
    case SizeBottom.SIZE_BOTTOM_S:
      return "SIZE_BOTTOM_S";
    case SizeBottom.SIZE_BOTTOM_M:
      return "SIZE_BOTTOM_M";
    case SizeBottom.SIZE_BOTTOM_L:
      return "SIZE_BOTTOM_L";
    case SizeBottom.SIZE_BOTTOM_XL:
      return "SIZE_BOTTOM_XL";
    case SizeBottom.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SizeWaist {
  SIZE_WAIST_UNSPECIFIED = 0,
  SIZE_WAIST_XS = 1,
  SIZE_WAIST_S = 2,
  SIZE_WAIST_M = 3,
  SIZE_WAIST_L = 4,
  SIZE_WAIST_XL = 5,
  UNRECOGNIZED = -1,
}

export function sizeWaistFromJSON(object: any): SizeWaist {
  switch (object) {
    case 0:
    case "SIZE_WAIST_UNSPECIFIED":
      return SizeWaist.SIZE_WAIST_UNSPECIFIED;
    case 1:
    case "SIZE_WAIST_XS":
      return SizeWaist.SIZE_WAIST_XS;
    case 2:
    case "SIZE_WAIST_S":
      return SizeWaist.SIZE_WAIST_S;
    case 3:
    case "SIZE_WAIST_M":
      return SizeWaist.SIZE_WAIST_M;
    case 4:
    case "SIZE_WAIST_L":
      return SizeWaist.SIZE_WAIST_L;
    case 5:
    case "SIZE_WAIST_XL":
      return SizeWaist.SIZE_WAIST_XL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SizeWaist.UNRECOGNIZED;
  }
}

export function sizeWaistToJSON(object: SizeWaist): string {
  switch (object) {
    case SizeWaist.SIZE_WAIST_UNSPECIFIED:
      return "SIZE_WAIST_UNSPECIFIED";
    case SizeWaist.SIZE_WAIST_XS:
      return "SIZE_WAIST_XS";
    case SizeWaist.SIZE_WAIST_S:
      return "SIZE_WAIST_S";
    case SizeWaist.SIZE_WAIST_M:
      return "SIZE_WAIST_M";
    case SizeWaist.SIZE_WAIST_L:
      return "SIZE_WAIST_L";
    case SizeWaist.SIZE_WAIST_XL:
      return "SIZE_WAIST_XL";
    case SizeWaist.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SizeBust {
  SIZE_BUST_UNSPECIFIED = 0,
  SIZE_BUST_XS = 1,
  SIZE_BUST_S = 2,
  SIZE_BUST_M = 3,
  SIZE_BUST_L = 4,
  SIZE_BUST_XL = 5,
  UNRECOGNIZED = -1,
}

export function sizeBustFromJSON(object: any): SizeBust {
  switch (object) {
    case 0:
    case "SIZE_BUST_UNSPECIFIED":
      return SizeBust.SIZE_BUST_UNSPECIFIED;
    case 1:
    case "SIZE_BUST_XS":
      return SizeBust.SIZE_BUST_XS;
    case 2:
    case "SIZE_BUST_S":
      return SizeBust.SIZE_BUST_S;
    case 3:
    case "SIZE_BUST_M":
      return SizeBust.SIZE_BUST_M;
    case 4:
    case "SIZE_BUST_L":
      return SizeBust.SIZE_BUST_L;
    case 5:
    case "SIZE_BUST_XL":
      return SizeBust.SIZE_BUST_XL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SizeBust.UNRECOGNIZED;
  }
}

export function sizeBustToJSON(object: SizeBust): string {
  switch (object) {
    case SizeBust.SIZE_BUST_UNSPECIFIED:
      return "SIZE_BUST_UNSPECIFIED";
    case SizeBust.SIZE_BUST_XS:
      return "SIZE_BUST_XS";
    case SizeBust.SIZE_BUST_S:
      return "SIZE_BUST_S";
    case SizeBust.SIZE_BUST_M:
      return "SIZE_BUST_M";
    case SizeBust.SIZE_BUST_L:
      return "SIZE_BUST_L";
    case SizeBust.SIZE_BUST_XL:
      return "SIZE_BUST_XL";
    case SizeBust.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SizeDress {
  SIZE_DRESS_UNSPECIFIED = 0,
  SIZE_DRESS_XS = 1,
  SIZE_DRESS_S = 2,
  SIZE_DRESS_M = 3,
  SIZE_DRESS_L = 4,
  SIZE_DRESS_XL = 5,
  UNRECOGNIZED = -1,
}

export function sizeDressFromJSON(object: any): SizeDress {
  switch (object) {
    case 0:
    case "SIZE_DRESS_UNSPECIFIED":
      return SizeDress.SIZE_DRESS_UNSPECIFIED;
    case 1:
    case "SIZE_DRESS_XS":
      return SizeDress.SIZE_DRESS_XS;
    case 2:
    case "SIZE_DRESS_S":
      return SizeDress.SIZE_DRESS_S;
    case 3:
    case "SIZE_DRESS_M":
      return SizeDress.SIZE_DRESS_M;
    case 4:
    case "SIZE_DRESS_L":
      return SizeDress.SIZE_DRESS_L;
    case 5:
    case "SIZE_DRESS_XL":
      return SizeDress.SIZE_DRESS_XL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SizeDress.UNRECOGNIZED;
  }
}

export function sizeDressToJSON(object: SizeDress): string {
  switch (object) {
    case SizeDress.SIZE_DRESS_UNSPECIFIED:
      return "SIZE_DRESS_UNSPECIFIED";
    case SizeDress.SIZE_DRESS_XS:
      return "SIZE_DRESS_XS";
    case SizeDress.SIZE_DRESS_S:
      return "SIZE_DRESS_S";
    case SizeDress.SIZE_DRESS_M:
      return "SIZE_DRESS_M";
    case SizeDress.SIZE_DRESS_L:
      return "SIZE_DRESS_L";
    case SizeDress.SIZE_DRESS_XL:
      return "SIZE_DRESS_XL";
    case SizeDress.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SizeShoes {
  SIZE_SHOES_UNSPECIFIED = 0,
  SIZE_SHOES_XS = 1,
  SIZE_SHOES_S = 2,
  SIZE_SHOES_M = 3,
  SIZE_SHOES_L = 4,
  SIZE_SHOES_XL = 5,
  UNRECOGNIZED = -1,
}

export function sizeShoesFromJSON(object: any): SizeShoes {
  switch (object) {
    case 0:
    case "SIZE_SHOES_UNSPECIFIED":
      return SizeShoes.SIZE_SHOES_UNSPECIFIED;
    case 1:
    case "SIZE_SHOES_XS":
      return SizeShoes.SIZE_SHOES_XS;
    case 2:
    case "SIZE_SHOES_S":
      return SizeShoes.SIZE_SHOES_S;
    case 3:
    case "SIZE_SHOES_M":
      return SizeShoes.SIZE_SHOES_M;
    case 4:
    case "SIZE_SHOES_L":
      return SizeShoes.SIZE_SHOES_L;
    case 5:
    case "SIZE_SHOES_XL":
      return SizeShoes.SIZE_SHOES_XL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SizeShoes.UNRECOGNIZED;
  }
}

export function sizeShoesToJSON(object: SizeShoes): string {
  switch (object) {
    case SizeShoes.SIZE_SHOES_UNSPECIFIED:
      return "SIZE_SHOES_UNSPECIFIED";
    case SizeShoes.SIZE_SHOES_XS:
      return "SIZE_SHOES_XS";
    case SizeShoes.SIZE_SHOES_S:
      return "SIZE_SHOES_S";
    case SizeShoes.SIZE_SHOES_M:
      return "SIZE_SHOES_M";
    case SizeShoes.SIZE_SHOES_L:
      return "SIZE_SHOES_L";
    case SizeShoes.SIZE_SHOES_XL:
      return "SIZE_SHOES_XL";
    case SizeShoes.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DiscoveryMethod {
  TWITTER = 0,
  INSTAGRAM = 1,
  APP_STORE = 2,
  FRIENDS = 3,
  WEB_SEARCH = 4,
  OTHER = 5,
  UNRECOGNIZED = -1,
}

export function discoveryMethodFromJSON(object: any): DiscoveryMethod {
  switch (object) {
    case 0:
    case "TWITTER":
      return DiscoveryMethod.TWITTER;
    case 1:
    case "INSTAGRAM":
      return DiscoveryMethod.INSTAGRAM;
    case 2:
    case "APP_STORE":
      return DiscoveryMethod.APP_STORE;
    case 3:
    case "FRIENDS":
      return DiscoveryMethod.FRIENDS;
    case 4:
    case "WEB_SEARCH":
      return DiscoveryMethod.WEB_SEARCH;
    case 5:
    case "OTHER":
      return DiscoveryMethod.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiscoveryMethod.UNRECOGNIZED;
  }
}

export function discoveryMethodToJSON(object: DiscoveryMethod): string {
  switch (object) {
    case DiscoveryMethod.TWITTER:
      return "TWITTER";
    case DiscoveryMethod.INSTAGRAM:
      return "INSTAGRAM";
    case DiscoveryMethod.APP_STORE:
      return "APP_STORE";
    case DiscoveryMethod.FRIENDS:
      return "FRIENDS";
    case DiscoveryMethod.WEB_SEARCH:
      return "WEB_SEARCH";
    case DiscoveryMethod.OTHER:
      return "OTHER";
    case DiscoveryMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WhatBringsYouToFetchr {
  WHAT_BRINGS_YOU_TO_FETCHR_UNSPECIFIED = 0,
  WHAT_BRINGS_YOU_TO_FETCHR_EXPLORE_STYLE = 1,
  WHAT_BRINGS_YOU_TO_FETCHR_WORK_WITH_STYLIST = 2,
  WHAT_BRINGS_YOU_TO_FETCHR_LOOKING_FOR_ITEM = 3,
  UNRECOGNIZED = -1,
}

export function whatBringsYouToFetchrFromJSON(object: any): WhatBringsYouToFetchr {
  switch (object) {
    case 0:
    case "WHAT_BRINGS_YOU_TO_FETCHR_UNSPECIFIED":
      return WhatBringsYouToFetchr.WHAT_BRINGS_YOU_TO_FETCHR_UNSPECIFIED;
    case 1:
    case "WHAT_BRINGS_YOU_TO_FETCHR_EXPLORE_STYLE":
      return WhatBringsYouToFetchr.WHAT_BRINGS_YOU_TO_FETCHR_EXPLORE_STYLE;
    case 2:
    case "WHAT_BRINGS_YOU_TO_FETCHR_WORK_WITH_STYLIST":
      return WhatBringsYouToFetchr.WHAT_BRINGS_YOU_TO_FETCHR_WORK_WITH_STYLIST;
    case 3:
    case "WHAT_BRINGS_YOU_TO_FETCHR_LOOKING_FOR_ITEM":
      return WhatBringsYouToFetchr.WHAT_BRINGS_YOU_TO_FETCHR_LOOKING_FOR_ITEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WhatBringsYouToFetchr.UNRECOGNIZED;
  }
}

export function whatBringsYouToFetchrToJSON(object: WhatBringsYouToFetchr): string {
  switch (object) {
    case WhatBringsYouToFetchr.WHAT_BRINGS_YOU_TO_FETCHR_UNSPECIFIED:
      return "WHAT_BRINGS_YOU_TO_FETCHR_UNSPECIFIED";
    case WhatBringsYouToFetchr.WHAT_BRINGS_YOU_TO_FETCHR_EXPLORE_STYLE:
      return "WHAT_BRINGS_YOU_TO_FETCHR_EXPLORE_STYLE";
    case WhatBringsYouToFetchr.WHAT_BRINGS_YOU_TO_FETCHR_WORK_WITH_STYLIST:
      return "WHAT_BRINGS_YOU_TO_FETCHR_WORK_WITH_STYLIST";
    case WhatBringsYouToFetchr.WHAT_BRINGS_YOU_TO_FETCHR_LOOKING_FOR_ITEM:
      return "WHAT_BRINGS_YOU_TO_FETCHR_LOOKING_FOR_ITEM";
    case WhatBringsYouToFetchr.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AppEnvironment {
  APP_ENVIRONMENT_UNSPECIFIED = 0,
  APP_ENVIRONMENT_DEV = 1,
  APP_ENVIRONMENT_TEST_FLIGHT = 2,
  APP_ENVIRONMENT_PROD = 3,
  UNRECOGNIZED = -1,
}

export function appEnvironmentFromJSON(object: any): AppEnvironment {
  switch (object) {
    case 0:
    case "APP_ENVIRONMENT_UNSPECIFIED":
      return AppEnvironment.APP_ENVIRONMENT_UNSPECIFIED;
    case 1:
    case "APP_ENVIRONMENT_DEV":
      return AppEnvironment.APP_ENVIRONMENT_DEV;
    case 2:
    case "APP_ENVIRONMENT_TEST_FLIGHT":
      return AppEnvironment.APP_ENVIRONMENT_TEST_FLIGHT;
    case 3:
    case "APP_ENVIRONMENT_PROD":
      return AppEnvironment.APP_ENVIRONMENT_PROD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AppEnvironment.UNRECOGNIZED;
  }
}

export function appEnvironmentToJSON(object: AppEnvironment): string {
  switch (object) {
    case AppEnvironment.APP_ENVIRONMENT_UNSPECIFIED:
      return "APP_ENVIRONMENT_UNSPECIFIED";
    case AppEnvironment.APP_ENVIRONMENT_DEV:
      return "APP_ENVIRONMENT_DEV";
    case AppEnvironment.APP_ENVIRONMENT_TEST_FLIGHT:
      return "APP_ENVIRONMENT_TEST_FLIGHT";
    case AppEnvironment.APP_ENVIRONMENT_PROD:
      return "APP_ENVIRONMENT_PROD";
    case AppEnvironment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExploreMessageType {
  MESSAGE_TYPE_UNSPECIFIED = 0,
  MESSAGE_TYPE_BASIC = 1,
  MESSAGE_TYPE_PRODUCT_PREFERENCES_TOOL_USAGE_REQUEST = 2,
  MESSAGE_TYPE_PRODUCT_PREFERENCES_TOOL_USAGE_RESPONSE = 3,
  MESSAGE_TYPE_PRODUCT_CHOICE_TOOL_USAGE_REQUEST = 4,
  MESSAGE_TYPE_PRODUCT_CHOICE_TOOL_USAGE_RESPONSE = 5,
  MESSAGE_TYPE_TOOL_USE_REQUEST = 6,
  MESSAGE_TYPE_TOOL_USE_RESPONSE = 7,
  UNRECOGNIZED = -1,
}

export function exploreMessageTypeFromJSON(object: any): ExploreMessageType {
  switch (object) {
    case 0:
    case "MESSAGE_TYPE_UNSPECIFIED":
      return ExploreMessageType.MESSAGE_TYPE_UNSPECIFIED;
    case 1:
    case "MESSAGE_TYPE_BASIC":
      return ExploreMessageType.MESSAGE_TYPE_BASIC;
    case 2:
    case "MESSAGE_TYPE_PRODUCT_PREFERENCES_TOOL_USAGE_REQUEST":
      return ExploreMessageType.MESSAGE_TYPE_PRODUCT_PREFERENCES_TOOL_USAGE_REQUEST;
    case 3:
    case "MESSAGE_TYPE_PRODUCT_PREFERENCES_TOOL_USAGE_RESPONSE":
      return ExploreMessageType.MESSAGE_TYPE_PRODUCT_PREFERENCES_TOOL_USAGE_RESPONSE;
    case 4:
    case "MESSAGE_TYPE_PRODUCT_CHOICE_TOOL_USAGE_REQUEST":
      return ExploreMessageType.MESSAGE_TYPE_PRODUCT_CHOICE_TOOL_USAGE_REQUEST;
    case 5:
    case "MESSAGE_TYPE_PRODUCT_CHOICE_TOOL_USAGE_RESPONSE":
      return ExploreMessageType.MESSAGE_TYPE_PRODUCT_CHOICE_TOOL_USAGE_RESPONSE;
    case 6:
    case "MESSAGE_TYPE_TOOL_USE_REQUEST":
      return ExploreMessageType.MESSAGE_TYPE_TOOL_USE_REQUEST;
    case 7:
    case "MESSAGE_TYPE_TOOL_USE_RESPONSE":
      return ExploreMessageType.MESSAGE_TYPE_TOOL_USE_RESPONSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExploreMessageType.UNRECOGNIZED;
  }
}

export function exploreMessageTypeToJSON(object: ExploreMessageType): string {
  switch (object) {
    case ExploreMessageType.MESSAGE_TYPE_UNSPECIFIED:
      return "MESSAGE_TYPE_UNSPECIFIED";
    case ExploreMessageType.MESSAGE_TYPE_BASIC:
      return "MESSAGE_TYPE_BASIC";
    case ExploreMessageType.MESSAGE_TYPE_PRODUCT_PREFERENCES_TOOL_USAGE_REQUEST:
      return "MESSAGE_TYPE_PRODUCT_PREFERENCES_TOOL_USAGE_REQUEST";
    case ExploreMessageType.MESSAGE_TYPE_PRODUCT_PREFERENCES_TOOL_USAGE_RESPONSE:
      return "MESSAGE_TYPE_PRODUCT_PREFERENCES_TOOL_USAGE_RESPONSE";
    case ExploreMessageType.MESSAGE_TYPE_PRODUCT_CHOICE_TOOL_USAGE_REQUEST:
      return "MESSAGE_TYPE_PRODUCT_CHOICE_TOOL_USAGE_REQUEST";
    case ExploreMessageType.MESSAGE_TYPE_PRODUCT_CHOICE_TOOL_USAGE_RESPONSE:
      return "MESSAGE_TYPE_PRODUCT_CHOICE_TOOL_USAGE_RESPONSE";
    case ExploreMessageType.MESSAGE_TYPE_TOOL_USE_REQUEST:
      return "MESSAGE_TYPE_TOOL_USE_REQUEST";
    case ExploreMessageType.MESSAGE_TYPE_TOOL_USE_RESPONSE:
      return "MESSAGE_TYPE_TOOL_USE_RESPONSE";
    case ExploreMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderStatus {
  ORDER_STATUS_UNSPECIFIED = 0,
  ORDER_STATUS_INITIATED = 1,
  ORDER_STATUS_WAITING_FOR_STYLIST = 2,
  ORDER_STATUS_WAITING_FOR_USER_FEEDBACK = 3,
  ORDER_STATUS_TO_BE_PURCHASED = 4,
  ORDER_STATUS_PURCHASED = 5,
  ORDER_STATUS_SHIPPING_IN_TRANSIT = 6,
  ORDER_STATUS_DELIVERED = 7,
  ORDER_STATUS_CANCELLED = 8,
  ORDER_STATUS_REFUNDED = 9,
  UNRECOGNIZED = -1,
}

export function orderStatusFromJSON(object: any): OrderStatus {
  switch (object) {
    case 0:
    case "ORDER_STATUS_UNSPECIFIED":
      return OrderStatus.ORDER_STATUS_UNSPECIFIED;
    case 1:
    case "ORDER_STATUS_INITIATED":
      return OrderStatus.ORDER_STATUS_INITIATED;
    case 2:
    case "ORDER_STATUS_WAITING_FOR_STYLIST":
      return OrderStatus.ORDER_STATUS_WAITING_FOR_STYLIST;
    case 3:
    case "ORDER_STATUS_WAITING_FOR_USER_FEEDBACK":
      return OrderStatus.ORDER_STATUS_WAITING_FOR_USER_FEEDBACK;
    case 4:
    case "ORDER_STATUS_TO_BE_PURCHASED":
      return OrderStatus.ORDER_STATUS_TO_BE_PURCHASED;
    case 5:
    case "ORDER_STATUS_PURCHASED":
      return OrderStatus.ORDER_STATUS_PURCHASED;
    case 6:
    case "ORDER_STATUS_SHIPPING_IN_TRANSIT":
      return OrderStatus.ORDER_STATUS_SHIPPING_IN_TRANSIT;
    case 7:
    case "ORDER_STATUS_DELIVERED":
      return OrderStatus.ORDER_STATUS_DELIVERED;
    case 8:
    case "ORDER_STATUS_CANCELLED":
      return OrderStatus.ORDER_STATUS_CANCELLED;
    case 9:
    case "ORDER_STATUS_REFUNDED":
      return OrderStatus.ORDER_STATUS_REFUNDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderStatus.UNRECOGNIZED;
  }
}

export function orderStatusToJSON(object: OrderStatus): string {
  switch (object) {
    case OrderStatus.ORDER_STATUS_UNSPECIFIED:
      return "ORDER_STATUS_UNSPECIFIED";
    case OrderStatus.ORDER_STATUS_INITIATED:
      return "ORDER_STATUS_INITIATED";
    case OrderStatus.ORDER_STATUS_WAITING_FOR_STYLIST:
      return "ORDER_STATUS_WAITING_FOR_STYLIST";
    case OrderStatus.ORDER_STATUS_WAITING_FOR_USER_FEEDBACK:
      return "ORDER_STATUS_WAITING_FOR_USER_FEEDBACK";
    case OrderStatus.ORDER_STATUS_TO_BE_PURCHASED:
      return "ORDER_STATUS_TO_BE_PURCHASED";
    case OrderStatus.ORDER_STATUS_PURCHASED:
      return "ORDER_STATUS_PURCHASED";
    case OrderStatus.ORDER_STATUS_SHIPPING_IN_TRANSIT:
      return "ORDER_STATUS_SHIPPING_IN_TRANSIT";
    case OrderStatus.ORDER_STATUS_DELIVERED:
      return "ORDER_STATUS_DELIVERED";
    case OrderStatus.ORDER_STATUS_CANCELLED:
      return "ORDER_STATUS_CANCELLED";
    case OrderStatus.ORDER_STATUS_REFUNDED:
      return "ORDER_STATUS_REFUNDED";
    case OrderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PaymentStatus {
  PAYMENT_STATUS_UNSPECIFIED = 0,
  PAYMENT_STATUS_NOT_PAID = 1,
  PAYMENT_STATUS_PAID = 2,
  PAYMENT_STATUS_PAYMENT_DENIED = 3,
  UNRECOGNIZED = -1,
}

export function paymentStatusFromJSON(object: any): PaymentStatus {
  switch (object) {
    case 0:
    case "PAYMENT_STATUS_UNSPECIFIED":
      return PaymentStatus.PAYMENT_STATUS_UNSPECIFIED;
    case 1:
    case "PAYMENT_STATUS_NOT_PAID":
      return PaymentStatus.PAYMENT_STATUS_NOT_PAID;
    case 2:
    case "PAYMENT_STATUS_PAID":
      return PaymentStatus.PAYMENT_STATUS_PAID;
    case 3:
    case "PAYMENT_STATUS_PAYMENT_DENIED":
      return PaymentStatus.PAYMENT_STATUS_PAYMENT_DENIED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentStatus.UNRECOGNIZED;
  }
}

export function paymentStatusToJSON(object: PaymentStatus): string {
  switch (object) {
    case PaymentStatus.PAYMENT_STATUS_UNSPECIFIED:
      return "PAYMENT_STATUS_UNSPECIFIED";
    case PaymentStatus.PAYMENT_STATUS_NOT_PAID:
      return "PAYMENT_STATUS_NOT_PAID";
    case PaymentStatus.PAYMENT_STATUS_PAID:
      return "PAYMENT_STATUS_PAID";
    case PaymentStatus.PAYMENT_STATUS_PAYMENT_DENIED:
      return "PAYMENT_STATUS_PAYMENT_DENIED";
    case PaymentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RefundStatus {
  REFUND_STATUS_UNSPECIFIED = 0,
  REFUND_STATUS_PENDING_USER_FEEDBACK = 1,
  REFUND_STATUS_DEADLINE_EXPIRED = 2,
  REFUND_STATUS_REQUESTED = 3,
  REFUND_STATUS_REQUESTED_ITEM_PICKED_UP = 4,
  REFUND_STATUS_REQUESTED_SHIPPED_BACK = 5,
  REFUND_STATUS_REQUESTED_NON_REFUNDABLE_ITEM = 6,
  REFUND_STATUS_ITEM_KEPT = 7,
  UNRECOGNIZED = -1,
}

export function refundStatusFromJSON(object: any): RefundStatus {
  switch (object) {
    case 0:
    case "REFUND_STATUS_UNSPECIFIED":
      return RefundStatus.REFUND_STATUS_UNSPECIFIED;
    case 1:
    case "REFUND_STATUS_PENDING_USER_FEEDBACK":
      return RefundStatus.REFUND_STATUS_PENDING_USER_FEEDBACK;
    case 2:
    case "REFUND_STATUS_DEADLINE_EXPIRED":
      return RefundStatus.REFUND_STATUS_DEADLINE_EXPIRED;
    case 3:
    case "REFUND_STATUS_REQUESTED":
      return RefundStatus.REFUND_STATUS_REQUESTED;
    case 4:
    case "REFUND_STATUS_REQUESTED_ITEM_PICKED_UP":
      return RefundStatus.REFUND_STATUS_REQUESTED_ITEM_PICKED_UP;
    case 5:
    case "REFUND_STATUS_REQUESTED_SHIPPED_BACK":
      return RefundStatus.REFUND_STATUS_REQUESTED_SHIPPED_BACK;
    case 6:
    case "REFUND_STATUS_REQUESTED_NON_REFUNDABLE_ITEM":
      return RefundStatus.REFUND_STATUS_REQUESTED_NON_REFUNDABLE_ITEM;
    case 7:
    case "REFUND_STATUS_ITEM_KEPT":
      return RefundStatus.REFUND_STATUS_ITEM_KEPT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RefundStatus.UNRECOGNIZED;
  }
}

export function refundStatusToJSON(object: RefundStatus): string {
  switch (object) {
    case RefundStatus.REFUND_STATUS_UNSPECIFIED:
      return "REFUND_STATUS_UNSPECIFIED";
    case RefundStatus.REFUND_STATUS_PENDING_USER_FEEDBACK:
      return "REFUND_STATUS_PENDING_USER_FEEDBACK";
    case RefundStatus.REFUND_STATUS_DEADLINE_EXPIRED:
      return "REFUND_STATUS_DEADLINE_EXPIRED";
    case RefundStatus.REFUND_STATUS_REQUESTED:
      return "REFUND_STATUS_REQUESTED";
    case RefundStatus.REFUND_STATUS_REQUESTED_ITEM_PICKED_UP:
      return "REFUND_STATUS_REQUESTED_ITEM_PICKED_UP";
    case RefundStatus.REFUND_STATUS_REQUESTED_SHIPPED_BACK:
      return "REFUND_STATUS_REQUESTED_SHIPPED_BACK";
    case RefundStatus.REFUND_STATUS_REQUESTED_NON_REFUNDABLE_ITEM:
      return "REFUND_STATUS_REQUESTED_NON_REFUNDABLE_ITEM";
    case RefundStatus.REFUND_STATUS_ITEM_KEPT:
      return "REFUND_STATUS_ITEM_KEPT";
    case RefundStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProductPurchaseFeedbackCategory {
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_UNSPECIFIED = 0,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_FIT_SIZING = 1,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_STYLE_COLOR = 2,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_QUALITY_ISSUE = 3,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_DAMAGED_DEFECTIVE = 4,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_NO_LONGER_NEEDED = 5,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_OTHER = 6,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_FIT = 7,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_COLOR = 8,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_HIGH_QUALITY_FABRIC = 9,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_VALUE = 10,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_MATCHES_WARDROBE = 11,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_LIKE_BRAND = 12,
  PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_OTHER = 13,
  UNRECOGNIZED = -1,
}

export function productPurchaseFeedbackCategoryFromJSON(object: any): ProductPurchaseFeedbackCategory {
  switch (object) {
    case 0:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_UNSPECIFIED":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_UNSPECIFIED;
    case 1:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_FIT_SIZING":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_FIT_SIZING;
    case 2:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_STYLE_COLOR":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_STYLE_COLOR;
    case 3:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_QUALITY_ISSUE":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_QUALITY_ISSUE;
    case 4:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_DAMAGED_DEFECTIVE":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_DAMAGED_DEFECTIVE;
    case 5:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_NO_LONGER_NEEDED":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_NO_LONGER_NEEDED;
    case 6:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_OTHER":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_OTHER;
    case 7:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_FIT":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_FIT;
    case 8:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_COLOR":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_COLOR;
    case 9:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_HIGH_QUALITY_FABRIC":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_HIGH_QUALITY_FABRIC;
    case 10:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_VALUE":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_VALUE;
    case 11:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_MATCHES_WARDROBE":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_MATCHES_WARDROBE;
    case 12:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_LIKE_BRAND":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_LIKE_BRAND;
    case 13:
    case "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_OTHER":
      return ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProductPurchaseFeedbackCategory.UNRECOGNIZED;
  }
}

export function productPurchaseFeedbackCategoryToJSON(object: ProductPurchaseFeedbackCategory): string {
  switch (object) {
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_UNSPECIFIED:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_UNSPECIFIED";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_FIT_SIZING:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_FIT_SIZING";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_STYLE_COLOR:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_STYLE_COLOR";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_QUALITY_ISSUE:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_QUALITY_ISSUE";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_DAMAGED_DEFECTIVE:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_DAMAGED_DEFECTIVE";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_NO_LONGER_NEEDED:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_NO_LONGER_NEEDED";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_OTHER:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_OTHER";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_FIT:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_FIT";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_COLOR:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_COLOR";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_HIGH_QUALITY_FABRIC:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_HIGH_QUALITY_FABRIC";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_VALUE:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_VALUE";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_MATCHES_WARDROBE:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_MATCHES_WARDROBE";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_LIKE_BRAND:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_LIKE_BRAND";
    case ProductPurchaseFeedbackCategory.PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_OTHER:
      return "PRODUCT_PURCHASE_FEEDBACK_CATEGORY_GOOD_OTHER";
    case ProductPurchaseFeedbackCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderSuggestionStatus {
  ORDER_SUGGESTION_STATUS_UNSPECIFIED = 0,
  ORDER_SUGGESTION_STATUS_PENDING = 1,
  ORDER_SUGGESTION_STATUS_REVIEWED = 2,
  ORDER_SUGGESTION_STATUS_ARCHIVED = 3,
  ORDER_SUGGESTION_STATUS_DRAFT = 4,
  UNRECOGNIZED = -1,
}

export function orderSuggestionStatusFromJSON(object: any): OrderSuggestionStatus {
  switch (object) {
    case 0:
    case "ORDER_SUGGESTION_STATUS_UNSPECIFIED":
      return OrderSuggestionStatus.ORDER_SUGGESTION_STATUS_UNSPECIFIED;
    case 1:
    case "ORDER_SUGGESTION_STATUS_PENDING":
      return OrderSuggestionStatus.ORDER_SUGGESTION_STATUS_PENDING;
    case 2:
    case "ORDER_SUGGESTION_STATUS_REVIEWED":
      return OrderSuggestionStatus.ORDER_SUGGESTION_STATUS_REVIEWED;
    case 3:
    case "ORDER_SUGGESTION_STATUS_ARCHIVED":
      return OrderSuggestionStatus.ORDER_SUGGESTION_STATUS_ARCHIVED;
    case 4:
    case "ORDER_SUGGESTION_STATUS_DRAFT":
      return OrderSuggestionStatus.ORDER_SUGGESTION_STATUS_DRAFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderSuggestionStatus.UNRECOGNIZED;
  }
}

export function orderSuggestionStatusToJSON(object: OrderSuggestionStatus): string {
  switch (object) {
    case OrderSuggestionStatus.ORDER_SUGGESTION_STATUS_UNSPECIFIED:
      return "ORDER_SUGGESTION_STATUS_UNSPECIFIED";
    case OrderSuggestionStatus.ORDER_SUGGESTION_STATUS_PENDING:
      return "ORDER_SUGGESTION_STATUS_PENDING";
    case OrderSuggestionStatus.ORDER_SUGGESTION_STATUS_REVIEWED:
      return "ORDER_SUGGESTION_STATUS_REVIEWED";
    case OrderSuggestionStatus.ORDER_SUGGESTION_STATUS_ARCHIVED:
      return "ORDER_SUGGESTION_STATUS_ARCHIVED";
    case OrderSuggestionStatus.ORDER_SUGGESTION_STATUS_DRAFT:
      return "ORDER_SUGGESTION_STATUS_DRAFT";
    case OrderSuggestionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProductPurchaseSuggestionStatus {
  PRODUCT_PURCHASE_SUGGESTION_STATUS_UNSPECIFIED = 0,
  PRODUCT_PURCHASE_SUGGESTION_STATUS_PENDING = 1,
  PRODUCT_PURCHASE_SUGGESTION_STATUS_ACCEPTED = 2,
  PRODUCT_PURCHASE_SUGGESTION_STATUS_REJECTED = 3,
  UNRECOGNIZED = -1,
}

export function productPurchaseSuggestionStatusFromJSON(object: any): ProductPurchaseSuggestionStatus {
  switch (object) {
    case 0:
    case "PRODUCT_PURCHASE_SUGGESTION_STATUS_UNSPECIFIED":
      return ProductPurchaseSuggestionStatus.PRODUCT_PURCHASE_SUGGESTION_STATUS_UNSPECIFIED;
    case 1:
    case "PRODUCT_PURCHASE_SUGGESTION_STATUS_PENDING":
      return ProductPurchaseSuggestionStatus.PRODUCT_PURCHASE_SUGGESTION_STATUS_PENDING;
    case 2:
    case "PRODUCT_PURCHASE_SUGGESTION_STATUS_ACCEPTED":
      return ProductPurchaseSuggestionStatus.PRODUCT_PURCHASE_SUGGESTION_STATUS_ACCEPTED;
    case 3:
    case "PRODUCT_PURCHASE_SUGGESTION_STATUS_REJECTED":
      return ProductPurchaseSuggestionStatus.PRODUCT_PURCHASE_SUGGESTION_STATUS_REJECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProductPurchaseSuggestionStatus.UNRECOGNIZED;
  }
}

export function productPurchaseSuggestionStatusToJSON(object: ProductPurchaseSuggestionStatus): string {
  switch (object) {
    case ProductPurchaseSuggestionStatus.PRODUCT_PURCHASE_SUGGESTION_STATUS_UNSPECIFIED:
      return "PRODUCT_PURCHASE_SUGGESTION_STATUS_UNSPECIFIED";
    case ProductPurchaseSuggestionStatus.PRODUCT_PURCHASE_SUGGESTION_STATUS_PENDING:
      return "PRODUCT_PURCHASE_SUGGESTION_STATUS_PENDING";
    case ProductPurchaseSuggestionStatus.PRODUCT_PURCHASE_SUGGESTION_STATUS_ACCEPTED:
      return "PRODUCT_PURCHASE_SUGGESTION_STATUS_ACCEPTED";
    case ProductPurchaseSuggestionStatus.PRODUCT_PURCHASE_SUGGESTION_STATUS_REJECTED:
      return "PRODUCT_PURCHASE_SUGGESTION_STATUS_REJECTED";
    case ProductPurchaseSuggestionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ShipmentStatus {
  SHIPMENT_STATUS_UNSPECIFIED = 0,
  SHIPMENT_STATUS_PENDING_SHIPPING = 1,
  SHIPMENT_STATUS_SHIPPING = 2,
  SHIPMENT_STATUS_DELIVERED = 3,
  SHIPMENT_STATUS_CANCELLED_BY_STORE = 4,
  UNRECOGNIZED = -1,
}

export function shipmentStatusFromJSON(object: any): ShipmentStatus {
  switch (object) {
    case 0:
    case "SHIPMENT_STATUS_UNSPECIFIED":
      return ShipmentStatus.SHIPMENT_STATUS_UNSPECIFIED;
    case 1:
    case "SHIPMENT_STATUS_PENDING_SHIPPING":
      return ShipmentStatus.SHIPMENT_STATUS_PENDING_SHIPPING;
    case 2:
    case "SHIPMENT_STATUS_SHIPPING":
      return ShipmentStatus.SHIPMENT_STATUS_SHIPPING;
    case 3:
    case "SHIPMENT_STATUS_DELIVERED":
      return ShipmentStatus.SHIPMENT_STATUS_DELIVERED;
    case 4:
    case "SHIPMENT_STATUS_CANCELLED_BY_STORE":
      return ShipmentStatus.SHIPMENT_STATUS_CANCELLED_BY_STORE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ShipmentStatus.UNRECOGNIZED;
  }
}

export function shipmentStatusToJSON(object: ShipmentStatus): string {
  switch (object) {
    case ShipmentStatus.SHIPMENT_STATUS_UNSPECIFIED:
      return "SHIPMENT_STATUS_UNSPECIFIED";
    case ShipmentStatus.SHIPMENT_STATUS_PENDING_SHIPPING:
      return "SHIPMENT_STATUS_PENDING_SHIPPING";
    case ShipmentStatus.SHIPMENT_STATUS_SHIPPING:
      return "SHIPMENT_STATUS_SHIPPING";
    case ShipmentStatus.SHIPMENT_STATUS_DELIVERED:
      return "SHIPMENT_STATUS_DELIVERED";
    case ShipmentStatus.SHIPMENT_STATUS_CANCELLED_BY_STORE:
      return "SHIPMENT_STATUS_CANCELLED_BY_STORE";
    case ShipmentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderType {
  ORDER_TYPE_USER_INITIATED = 0,
  ORDER_TYPE_FETCHR_INITIATED = 1,
  UNRECOGNIZED = -1,
}

export function orderTypeFromJSON(object: any): OrderType {
  switch (object) {
    case 0:
    case "ORDER_TYPE_USER_INITIATED":
      return OrderType.ORDER_TYPE_USER_INITIATED;
    case 1:
    case "ORDER_TYPE_FETCHR_INITIATED":
      return OrderType.ORDER_TYPE_FETCHR_INITIATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderType.UNRECOGNIZED;
  }
}

export function orderTypeToJSON(object: OrderType): string {
  switch (object) {
    case OrderType.ORDER_TYPE_USER_INITIATED:
      return "ORDER_TYPE_USER_INITIATED";
    case OrderType.ORDER_TYPE_FETCHR_INITIATED:
      return "ORDER_TYPE_FETCHR_INITIATED";
    case OrderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderSuggestionDetailedStatus {
  ORDER_SUGGESTION_DETAILED_STATUS_UNSPECIFIED = 0,
  ORDER_SUGGESTION_DETAILED_STATUS_FINDING_ITEMS = 1,
  ORDER_SUGGESTION_DETAILED_STATUS_PENDING_VERIFICATION = 2,
  ORDER_SUGGESTION_DETAILED_STATUS_MODIFYING_ITEMS = 3,
  ORDER_SUGGESTION_DETAILED_STATUS_PENDING_PURCHASE = 4,
  ORDER_SUGGESTION_DETAILED_STATUS_SHIPPING = 5,
  ORDER_SUGGESTION_DETAILED_STATUS_DELIVERED = 6,
  UNRECOGNIZED = -1,
}

export function orderSuggestionDetailedStatusFromJSON(object: any): OrderSuggestionDetailedStatus {
  switch (object) {
    case 0:
    case "ORDER_SUGGESTION_DETAILED_STATUS_UNSPECIFIED":
      return OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_UNSPECIFIED;
    case 1:
    case "ORDER_SUGGESTION_DETAILED_STATUS_FINDING_ITEMS":
      return OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_FINDING_ITEMS;
    case 2:
    case "ORDER_SUGGESTION_DETAILED_STATUS_PENDING_VERIFICATION":
      return OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_PENDING_VERIFICATION;
    case 3:
    case "ORDER_SUGGESTION_DETAILED_STATUS_MODIFYING_ITEMS":
      return OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_MODIFYING_ITEMS;
    case 4:
    case "ORDER_SUGGESTION_DETAILED_STATUS_PENDING_PURCHASE":
      return OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_PENDING_PURCHASE;
    case 5:
    case "ORDER_SUGGESTION_DETAILED_STATUS_SHIPPING":
      return OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_SHIPPING;
    case 6:
    case "ORDER_SUGGESTION_DETAILED_STATUS_DELIVERED":
      return OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_DELIVERED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderSuggestionDetailedStatus.UNRECOGNIZED;
  }
}

export function orderSuggestionDetailedStatusToJSON(object: OrderSuggestionDetailedStatus): string {
  switch (object) {
    case OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_UNSPECIFIED:
      return "ORDER_SUGGESTION_DETAILED_STATUS_UNSPECIFIED";
    case OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_FINDING_ITEMS:
      return "ORDER_SUGGESTION_DETAILED_STATUS_FINDING_ITEMS";
    case OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_PENDING_VERIFICATION:
      return "ORDER_SUGGESTION_DETAILED_STATUS_PENDING_VERIFICATION";
    case OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_MODIFYING_ITEMS:
      return "ORDER_SUGGESTION_DETAILED_STATUS_MODIFYING_ITEMS";
    case OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_PENDING_PURCHASE:
      return "ORDER_SUGGESTION_DETAILED_STATUS_PENDING_PURCHASE";
    case OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_SHIPPING:
      return "ORDER_SUGGESTION_DETAILED_STATUS_SHIPPING";
    case OrderSuggestionDetailedStatus.ORDER_SUGGESTION_DETAILED_STATUS_DELIVERED:
      return "ORDER_SUGGESTION_DETAILED_STATUS_DELIVERED";
    case OrderSuggestionDetailedStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StylistSuggestionStatus {
  STYLIST_SUGGESTION_STATUS_UNSPECIFIED = 0,
  STYLIST_SUGGESTION_STATUS_WAITING = 1,
  STYLIST_SUGGESTION_STATUS_ACCEPTED = 2,
  STYLIST_SUGGESTION_STATUS_MODIFICATION_REQUESTED = 3,
  UNRECOGNIZED = -1,
}

export function stylistSuggestionStatusFromJSON(object: any): StylistSuggestionStatus {
  switch (object) {
    case 0:
    case "STYLIST_SUGGESTION_STATUS_UNSPECIFIED":
      return StylistSuggestionStatus.STYLIST_SUGGESTION_STATUS_UNSPECIFIED;
    case 1:
    case "STYLIST_SUGGESTION_STATUS_WAITING":
      return StylistSuggestionStatus.STYLIST_SUGGESTION_STATUS_WAITING;
    case 2:
    case "STYLIST_SUGGESTION_STATUS_ACCEPTED":
      return StylistSuggestionStatus.STYLIST_SUGGESTION_STATUS_ACCEPTED;
    case 3:
    case "STYLIST_SUGGESTION_STATUS_MODIFICATION_REQUESTED":
      return StylistSuggestionStatus.STYLIST_SUGGESTION_STATUS_MODIFICATION_REQUESTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StylistSuggestionStatus.UNRECOGNIZED;
  }
}

export function stylistSuggestionStatusToJSON(object: StylistSuggestionStatus): string {
  switch (object) {
    case StylistSuggestionStatus.STYLIST_SUGGESTION_STATUS_UNSPECIFIED:
      return "STYLIST_SUGGESTION_STATUS_UNSPECIFIED";
    case StylistSuggestionStatus.STYLIST_SUGGESTION_STATUS_WAITING:
      return "STYLIST_SUGGESTION_STATUS_WAITING";
    case StylistSuggestionStatus.STYLIST_SUGGESTION_STATUS_ACCEPTED:
      return "STYLIST_SUGGESTION_STATUS_ACCEPTED";
    case StylistSuggestionStatus.STYLIST_SUGGESTION_STATUS_MODIFICATION_REQUESTED:
      return "STYLIST_SUGGESTION_STATUS_MODIFICATION_REQUESTED";
    case StylistSuggestionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SearchMethod {
  SEARCH_METHOD_UNSPECIFIED = 0,
  SEARCH_METHOD_TEXT = 1,
  SEARCH_METHOD_IMAGE = 2,
  SEARCH_METHOD_VOYAGE_TEXT = 3,
  SEARCH_METHOD_IMAGE_TEXT_AVERAGE = 4,
  SEARCH_METHOD_VOYAGE_MULTIMODAL = 5,
  SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE = 6,
  SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE = 7,
  SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE = 8,
  SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE_CLEAN = 9,
  SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE_CLEAN_WITH_SEMANTIC_METADATA = 10,
  UNRECOGNIZED = -1,
}

export function searchMethodFromJSON(object: any): SearchMethod {
  switch (object) {
    case 0:
    case "SEARCH_METHOD_UNSPECIFIED":
      return SearchMethod.SEARCH_METHOD_UNSPECIFIED;
    case 1:
    case "SEARCH_METHOD_TEXT":
      return SearchMethod.SEARCH_METHOD_TEXT;
    case 2:
    case "SEARCH_METHOD_IMAGE":
      return SearchMethod.SEARCH_METHOD_IMAGE;
    case 3:
    case "SEARCH_METHOD_VOYAGE_TEXT":
      return SearchMethod.SEARCH_METHOD_VOYAGE_TEXT;
    case 4:
    case "SEARCH_METHOD_IMAGE_TEXT_AVERAGE":
      return SearchMethod.SEARCH_METHOD_IMAGE_TEXT_AVERAGE;
    case 5:
    case "SEARCH_METHOD_VOYAGE_MULTIMODAL":
      return SearchMethod.SEARCH_METHOD_VOYAGE_MULTIMODAL;
    case 6:
    case "SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE":
      return SearchMethod.SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE;
    case 7:
    case "SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE":
      return SearchMethod.SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE;
    case 8:
    case "SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE":
      return SearchMethod.SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE;
    case 9:
    case "SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE_CLEAN":
      return SearchMethod.SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE_CLEAN;
    case 10:
    case "SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE_CLEAN_WITH_SEMANTIC_METADATA":
      return SearchMethod.SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE_CLEAN_WITH_SEMANTIC_METADATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchMethod.UNRECOGNIZED;
  }
}

export function searchMethodToJSON(object: SearchMethod): string {
  switch (object) {
    case SearchMethod.SEARCH_METHOD_UNSPECIFIED:
      return "SEARCH_METHOD_UNSPECIFIED";
    case SearchMethod.SEARCH_METHOD_TEXT:
      return "SEARCH_METHOD_TEXT";
    case SearchMethod.SEARCH_METHOD_IMAGE:
      return "SEARCH_METHOD_IMAGE";
    case SearchMethod.SEARCH_METHOD_VOYAGE_TEXT:
      return "SEARCH_METHOD_VOYAGE_TEXT";
    case SearchMethod.SEARCH_METHOD_IMAGE_TEXT_AVERAGE:
      return "SEARCH_METHOD_IMAGE_TEXT_AVERAGE";
    case SearchMethod.SEARCH_METHOD_VOYAGE_MULTIMODAL:
      return "SEARCH_METHOD_VOYAGE_MULTIMODAL";
    case SearchMethod.SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE:
      return "SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE";
    case SearchMethod.SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE:
      return "SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE";
    case SearchMethod.SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE:
      return "SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE";
    case SearchMethod.SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE_CLEAN:
      return "SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE_CLEAN";
    case SearchMethod.SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE_CLEAN_WITH_SEMANTIC_METADATA:
      return "SEARCH_METHOD_VOYAGE_TEXT_SIGLIP_IMAGE_AVERAGE_SPARSE_CLEAN_WITH_SEMANTIC_METADATA";
    case SearchMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExploreRequestType {
  EXPLORE_REQUEST_TYPE_UNSPECIFIED = 0,
  EXPLORE_REQUEST_TYPE_OUTFIT = 1,
  EXPLORE_REQUEST_TYPE_ITEM = 2,
  UNRECOGNIZED = -1,
}

export function exploreRequestTypeFromJSON(object: any): ExploreRequestType {
  switch (object) {
    case 0:
    case "EXPLORE_REQUEST_TYPE_UNSPECIFIED":
      return ExploreRequestType.EXPLORE_REQUEST_TYPE_UNSPECIFIED;
    case 1:
    case "EXPLORE_REQUEST_TYPE_OUTFIT":
      return ExploreRequestType.EXPLORE_REQUEST_TYPE_OUTFIT;
    case 2:
    case "EXPLORE_REQUEST_TYPE_ITEM":
      return ExploreRequestType.EXPLORE_REQUEST_TYPE_ITEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExploreRequestType.UNRECOGNIZED;
  }
}

export function exploreRequestTypeToJSON(object: ExploreRequestType): string {
  switch (object) {
    case ExploreRequestType.EXPLORE_REQUEST_TYPE_UNSPECIFIED:
      return "EXPLORE_REQUEST_TYPE_UNSPECIFIED";
    case ExploreRequestType.EXPLORE_REQUEST_TYPE_OUTFIT:
      return "EXPLORE_REQUEST_TYPE_OUTFIT";
    case ExploreRequestType.EXPLORE_REQUEST_TYPE_ITEM:
      return "EXPLORE_REQUEST_TYPE_ITEM";
    case ExploreRequestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ProductWithSearchQuery {
  product: Product | undefined;
  query: string;
}

export interface Product {
  id: string;
  brandId: string;
  brandName: string;
  subBrandId?: string | undefined;
  subBrandName?: string | undefined;
  url: string;
  imageUrls: string[];
  s3ImageUrls: string[];
  title: string;
  price: number;
  gender: Gender;
  sizes: string[];
  description: string;
  generatedDescription?: string | undefined;
  fullGeneratedDescription: string;
  colors: string[];
  materials: string[];
  category?: ProductCategory | undefined;
  style?: string | undefined;
  details?: string | undefined;
  fit?: ProductFit | undefined;
  name: string;
  compressedImageUrls: string[];
  isKidProduct: boolean;
  scrapingMetadata: Product_ScrapingMetadata | undefined;
  manuallyAdded?: boolean | undefined;
  highresWebpUrls: string[];
  originalPrice?: number | undefined;
}

export interface Product_ScrapingMetadata {
  contentQualityCheck?: boolean | undefined;
  pipelineRunId?: string | undefined;
}

export interface ProductWithScore {
  product: Product | undefined;
  score: number;
}

export interface ProductWithScoreAndSearchQuery {
  product: Product | undefined;
  score: number;
  query: string;
}

export interface UserMetadata {
  gender?: Gender | undefined;
  age?: number | undefined;
  weight?: number | undefined;
  height?: number | undefined;
}

export interface Name {
  firstName?: string | undefined;
  lastName?: string | undefined;
}

export interface UserProfile {
  id: string;
  metadata?: UserMetadata | undefined;
  name?: Name | undefined;
  socialLinks?: SocialLinks | undefined;
  isOnboardingCompleted: boolean;
  address?: UserAddress | undefined;
  email?: string | undefined;
  isPushNotificationsEnabled: boolean;
  sizing?: UserSizing | undefined;
  createdAt: number;
  role: UserRole;
  phoneNumber?: string | undefined;
  membershipType?: MembershipType | undefined;
  styleImageUrls: string[];
  favoriteBrands: string[];
  generatedProfileDescription: GeneratedProfileDescription | undefined;
  firstOrderQuery?: string | undefined;
  devices: UserDevice[];
  whatBringsYouToFetchr?: WhatBringsYouToFetchr | undefined;
  preferencesAndQuirks?: string | undefined;
  stylePickerProductIds: string[];
  selfonboardedGeneratedStyleDescription?: string | undefined;
  billing: UserBilling | undefined;
}

export interface UserDevice {
  deviceId: string;
  notificationEnabled: boolean;
  platform: Platform;
}

export interface GeneratedProfileDescription {
  description?: string | undefined;
  lastUpdatedAtNumProductPreferences?: number | undefined;
  hash?: string | undefined;
  didTriedToPopulateBioFromPendingRegisterTable?: boolean | undefined;
}

export interface SocialLinks {
  instagramHandle?: string | undefined;
}

export interface UserSizing {
  tops?: SizeTop | undefined;
  bottoms?: string | undefined;
  waist?: string | undefined;
  bust?: string | undefined;
  dress?: string | undefined;
  shoes?: string | undefined;
  hips?: string | undefined;
  inseam?: string | undefined;
  waistApproximate?: boolean | undefined;
  hipsApproximate?: boolean | undefined;
  inseamApproximate?: boolean | undefined;
  bustApproximate?: boolean | undefined;
}

export interface UserAddress {
  addressLineOne?: string | undefined;
  addressLineTwo?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  postalCode?: string | undefined;
}

export interface UserProductPreference {
  id: string;
  preferenceType?: PreferenceType | undefined;
  userId: string;
  productId: string;
  requestId: string;
  cohort: number;
  query?: string | undefined;
  comments?: string | undefined;
}

export interface PopulatedUserProductPreference {
  preference: UserProductPreference | undefined;
  productDetails: Product | undefined;
}

export interface StringList {
  values: string[];
}

export interface ProductWithSearchQueryAndPreference {
  product: Product | undefined;
  preferenceItem: ProductPreferenceItem | undefined;
  query: string;
}

export interface ProductPreferenceItem {
  itemId: string;
  preferenceType: PreferenceType;
  comments?: string | undefined;
}

export interface PopulatedProductPreferenceItem {
  preferenceItem: ProductPreferenceItem | undefined;
  product: Product | undefined;
}

export interface ProductRecommendation {
  productName: string;
  isSelected: boolean;
}

export interface ProductPurchase {
  id: string;
  productId: string;
  size: string;
  price: number;
  originalPrice?: number | undefined;
  isRefundable?: boolean | undefined;
  userFeedback?: UserProductPurchaseFeedback | undefined;
  refundStatus?: RefundStatus | undefined;
  product?: Product | undefined;
  color: string;
  paymentStatus: PaymentStatus;
  stripePaymentId?: string | undefined;
  isArchived: boolean;
  archiveReason?: string | undefined;
}

export interface UserProductPurchaseFeedback {
  feedback?: string | undefined;
  refundReason?: string | undefined;
  categories: ProductPurchaseFeedbackCategory[];
}

export interface ProductPurchaseSuggestion {
  id: string;
  productId: string;
  size: string;
  price: number;
  originalPrice?: number | undefined;
  isRefundable?: boolean | undefined;
  product: Product | undefined;
  isAccepted: boolean;
  /** User feedback note */
  note?: string | undefined;
  color: string;
  status: ProductPurchaseSuggestionStatus;
  aiJudgeAnalysis?: string | undefined;
  isArchived: boolean;
  archiveReason?: string | undefined;
  internalData?: InternalProductPurchaseSuggestionData | undefined;
}

export interface Shipment {
  id: string;
  orderId: string;
  brand: Brand | undefined;
  productPurchases: ProductPurchase[];
  status: ShipmentStatus;
  /** Shipment tracking info */
  brandOrderId?: string | undefined;
  trackingNumber?: string | undefined;
  trackingUrl?: string | undefined;
  expectedDeliveryDateStart?: number | undefined;
  expectedDeliveryDateEnd?: number | undefined;
  deliveredAt?: number | undefined;
  email?: string | undefined;
  possibleTrackingNumbers: string[];
  totalPrice?: number | undefined;
  shippingCost?: number | undefined;
  stripePaymentId?: string | undefined;
}

export interface PopulatedOrderSuggestion {
  id: string;
  createdAt: number;
  status: OrderSuggestionStatus;
  productSuggestions: ProductPurchaseSuggestion[];
  shipments: Shipment[];
  detailedStatus: OrderSuggestionDetailedStatus;
  verifySuggestionsBy?: number | undefined;
  verifyPurchasesBy?: number | undefined;
  expireSuggestionsBy?: number | undefined;
  stylistNote?: string | undefined;
  aiJudgeAnalysis?: string | undefined;
  internalData?: InternalOrderSuggestionData | undefined;
}

export interface InternalProductPurchaseSuggestionData {
  threads: Thread[];
}

export interface InternalOrderSuggestionData {
  threads: Thread[];
}

export interface OrderSummary {
  id: string;
  customerId: string;
  stylistId?: string | undefined;
  chatId?: string | undefined;
  status: OrderStatus;
  createdAt: number;
  updatedAt: number;
  customer: UserProfile | undefined;
  stylist?: UserProfile | undefined;
  userViewVersion: number;
  dashboardMetadata: DashboardMetadata | undefined;
  note?: string | undefined;
  productRecommendations: ProductRecommendation[];
  orderSuggestions: PopulatedOrderSuggestion[];
  type?: OrderType | undefined;
  generatedTitle?: string | undefined;
}

export interface StylistSuggestionSummary {
  mainSuggestion: MainStylistSuggestion | undefined;
  secondarySuggestions: SecondaryStylistSuggestion[];
}

export interface ExploreRequest {
  id: string;
  userId: string;
  query: string;
  lowerBudget?: number | undefined;
  upperBudget?: number | undefined;
  brandIds: string[];
  category?: ProductCategory | undefined;
  gender: Gender;
  generatedTitle?: string | undefined;
  devIsDevOnly?: boolean | undefined;
  devIsDeleted?: boolean | undefined;
  createdAt: string;
  messages: PopulatedExploreMessage[];
  status?: string | undefined;
  requestType?: ExploreRequestType | undefined;
  productId?: string | undefined;
}

export interface ExploreRequestSummary {
  id: string;
  query: string;
  createdAt: string;
  generatedTitle?: string | undefined;
}

export interface DashboardMetadata {
  isStarred: boolean;
}

export interface ProductChoiceToolUsageRequest {
  productIds: string[];
}

export interface ProductChoiceToolUsageResponse {
  chosenProductId: string;
}

export interface PredefinedRequestMessage {
  message: Message | undefined;
  suggestedResponses: string[];
}

export interface PopulatedExploreRequestMessage {
  message?:
    | { $case: "basicMessage"; basicMessage: Message }
    | {
      $case: "productPreferencesRequestMessage";
      productPreferencesRequestMessage: ProductPreferencesRequestPopulatedMessage;
    }
    | {
      $case: "finishFindingProductRequestMessage";
      finishFindingProductRequestMessage: FinishFindingProductRequestPopulatedMessage;
    }
    | { $case: "updateStatusMessage"; updateStatusMessage: UpdateStatusMessage }
    | { $case: "gridProductsRequestMessage"; gridProductsRequestMessage: GridProductsRequestPopulatedMessage }
    | { $case: "gridImagesRequestMessage"; gridImagesRequestMessage: GridImagesRequestPopulatedMessage }
    | { $case: "placeOrderRequestMessage"; placeOrderRequestMessage: PlaceOrderRequestPopulatedMessage }
    | //
    /** ProductChoiceRequestPopulatedMessage product_choice_request_message = 4; */
    { $case: "predefinedRequestMessage"; predefinedRequestMessage: PredefinedRequestMessage }
    | undefined;
}

export interface PlaceOrderRequestPopulatedMessage {
  orderId: string;
  orderSummary: OrderSummary | undefined;
}

export interface GridImagesRequestPopulatedMessage {
  imageUrls: ImageWithWidthAndHeight[];
  toolUseId: string;
}

export interface ImageWithWidthAndHeight {
  imageUrl: string;
  width: number;
  height: number;
}

export interface ImagePreferenceItem {
  imageUrl: string;
  preferenceType: PreferenceType;
}

export interface ImagePreferenceItemWithStyle {
  imagePreferenceItem: ImagePreferenceItem | undefined;
  style: string;
}

export interface PopulatedImagePreferenceItem {
  imagePreferenceItem: ImagePreferenceItem | undefined;
  embeddings: number[];
  style?: string | undefined;
}

export interface GridImagesResponsePopulatedMessage {
  imagePreferenceItems: ImagePreferenceItemWithStyle[];
  toolUseId: string;
}

export interface GridProductsRequestPopulatedMessage {
  products: ProductWithScoreAndSearchQuery[];
  unrankedProducts: ProductWithSearchQuery[];
  intermediateQueries: string[];
  toolUseId: string;
}

export interface PopulatedOrderManagementMessage {
  message?:
    | { $case: "stylistSuggestionsRequestMessage"; stylistSuggestionsRequestMessage: SendStylistSuggestionsRequest }
    | { $case: "stylistSuggestionsResponseMessage"; stylistSuggestionsResponseMessage: SendStylistSuggestionsResponse }
    | undefined;
}

export interface PopulatedOrderManagementRequestMessage {
  message?: {
    $case: "stylistSuggestionsRequestMessage";
    stylistSuggestionsRequestMessage: SendStylistSuggestionsRequest;
  } | undefined;
}

export interface GridProductsResponsePopulatedMessage {
  preferences: ProductPreferenceItem[];
  toolUseId: string;
}

export interface PopulatedOrderManagementResponseMessage {
  message?: {
    $case: "stylistSuggestionsResponseMessage";
    stylistSuggestionsResponseMessage: SendStylistSuggestionsResponse;
  } | undefined;
}

export interface PopulatedExploreResponseMessage {
  message?:
    | { $case: "basicMessage"; basicMessage: Message }
    | {
      $case: "productPreferencesResponseMessage";
      productPreferencesResponseMessage: ProductPreferencesResponsePopulatedMessage;
    }
    | { $case: "gridProductsResponseMessage"; gridProductsResponseMessage: GridProductsResponsePopulatedMessage }
    | //
    /**
     * ProductChoiceResponsePopulatedMessage product_choice_response_message =
     * 3;
     */
    { $case: "gridImagesResponseMessage"; gridImagesResponseMessage: GridImagesResponsePopulatedMessage }
    | undefined;
}

export interface ProductSuggestion {
  productName: string;
  isSelected: boolean;
}

export interface FinishFindingProductRequestPopulatedMessage {
  userRequirements: string[];
  productSuggestions: ProductSuggestion[];
  message?: string | undefined;
}

export interface ProductPreferencesRequestPopulatedMessage {
  products: ProductWithScoreAndSearchQuery[];
  unrankedProducts: ProductWithSearchQuery[];
  intermediateQueries: string[];
  toolUseId: string;
}

export interface ProductPreferencesResponsePopulatedMessage {
  preferences: ProductPreferenceItem[];
  toolUseId: string;
}

export interface ProductChoiceRequestPopulatedMessage {
  products: Product[];
}

export interface ProductChoiceResponsePopulatedMessage {
  chosenProduct: Product | undefined;
}

export interface PopulatedExploreMessage {
  message?:
    | { $case: "basicMessage"; basicMessage: Message }
    | {
      $case: "productPreferencesRequestMessage";
      productPreferencesRequestMessage: ProductPreferencesRequestPopulatedMessage;
    }
    | {
      $case: "productPreferencesResponseMessage";
      productPreferencesResponseMessage: ProductPreferencesResponsePopulatedMessage;
    }
    | {
      $case: "finishFindingProductRequestMessage";
      finishFindingProductRequestMessage: FinishFindingProductRequestPopulatedMessage;
    }
    | { $case: "updateStatusMessage"; updateStatusMessage: UpdateStatusMessage }
    | { $case: "gridProductsRequestMessage"; gridProductsRequestMessage: GridProductsRequestPopulatedMessage }
    | { $case: "gridProductsResponseMessage"; gridProductsResponseMessage: GridProductsResponsePopulatedMessage }
    | { $case: "gridImagesRequestMessage"; gridImagesRequestMessage: GridImagesRequestPopulatedMessage }
    | { $case: "gridImagesResponseMessage"; gridImagesResponseMessage: GridImagesResponsePopulatedMessage }
    | { $case: "placeOrderRequestMessage"; placeOrderRequestMessage: PlaceOrderRequestPopulatedMessage }
    | { $case: "predefinedRequestMessage"; predefinedRequestMessage: PredefinedRequestMessage }
    | undefined;
}

export interface UpdateStatusMessage {
  statusString?: string | undefined;
}

export interface SendStylistSuggestionsRequest {
  orderId: string;
  mainSuggestion: MainStylistSuggestion | undefined;
  secondarySuggestions: SecondaryStylistSuggestion[];
}

export interface MainStylistSuggestion {
  productId: string;
  recommendedSize: string;
  suggestionReasoning: SuggestionReasoning | undefined;
  currentPrice: number;
  originalPrice?: number | undefined;
  product?: Product | undefined;
  productCopy: string;
  userRequirements: string[];
}

export interface SecondaryStylistSuggestion {
  productId: string;
  currentPrice: number;
  originalPrice?: number | undefined;
  product?: Product | undefined;
  userRequirements: string[];
}

export interface SendStylistSuggestionsResponse {
  orderId: string;
  modificationRequest?: string | undefined;
  acceptedProduct?: AcceptedProduct | undefined;
}

export interface AcceptedProduct {
  productId: string;
  size: string;
}

export interface SuggestionReasoning {
  productReasoning: string;
  brandReasoning: string;
  sizeReasoning: string;
}

export interface SearchQuery {
  query: string;
  topK?: number | undefined;
  gender?: Gender | undefined;
  brandIds: string[];
  minPrice?: number | undefined;
  maxPrice?: number | undefined;
  productIdWhitelist: string[];
  productIdBlacklist: string[];
  category?: ProductCategory | undefined;
  searchMethod?: SearchMethod | undefined;
  embeddingVersion?: number | undefined;
}

export interface Brand {
  id: string;
  company: string;
  url: string;
  gender?: Gender | undefined;
  gptSummary?: string | undefined;
}

export interface GetBrandsRequest {
}

export interface GetBrandsResponse {
  brands: Brand[];
}

export interface CreateBrandRequest {
  brand: Brand | undefined;
}

export interface CreateBrandResponse {
  brand: Brand | undefined;
}

export interface SearchRequest {
  query: SearchQuery | undefined;
  targetUserId?: string | undefined;
  targetExploreRequestId?: string | undefined;
}

export interface SearchResponse {
  results: ProductWithScore[];
}

export interface SimilarProductsRequest {
  productId: string;
  topK?: number | undefined;
  gender?: Gender | undefined;
  brandIds: string[];
  minPrice?: number | undefined;
  maxPrice?: number | undefined;
  category?: ProductCategory | undefined;
  searchMethod?: SearchMethod | undefined;
  exploreRequestId?: string | undefined;
  productIdBlacklist: string[];
}

export interface SimilarProductsResponse {
  results: ProductWithScore[];
}

export interface StylePickerProduct {
  id: string;
  modelImage: string;
  stickerImage: string;
  category: ProductCategory;
  gender: Gender;
}

export interface ListStylePickerProductsRequest {
  limit: number;
  offset: number;
  category?: ProductCategory | undefined;
  gender?: Gender | undefined;
}

export interface ListStylePickerProductsResponse {
  products: StylePickerProduct[];
  totalCount: number;
}

export interface UpdateProductRequest {
  productId: string;
  url?: string | undefined;
  price?: number | undefined;
  originalPrice?: number | undefined;
  sizes: string[];
}

export interface UpdateProductResponse {
  product: Product | undefined;
}

export interface SearchForProductsByUrlRegexRequest {
  urlRegex: string;
}

export interface SearchForProductsByUrlRegexResponse {
  products: Product[];
}

export interface GetLatestAcceptableAppVersionRequest {
}

export interface GetLatestAcceptableAppVersionResponse {
  version: string;
  buildNumber: string;
}

export interface GetProductsRequest {
  productIds: string[];
}

export interface GetProductsResponse {
  products: Product[];
}

export interface ProcessImageExtractAndSaveStyleRequest {
  imageUrl: string;
}

export interface ProcessImageExtractAndSaveStyleResponse {
  style: string;
}

export interface UploadImageRequest {
  imageData: Uint8Array;
}

export interface UploadImageResponse {
  imageUrl: string;
}

export interface HealthCheckRequest {
}

export interface HealthCheckResponse {
  message: string;
}

export interface TextEmbeddingRequest {
  query: string;
}

export interface ImageEmbeddingRequest {
  imageData: Uint8Array;
}

export interface EmbeddingResponse {
  embedding: number[];
}

export interface StyleGenerationRequest {
  query: string;
  gender: Gender;
  category?: ProductCategory | undefined;
  numProducts?: number | undefined;
  searchMethod?: SearchMethod | undefined;
}

export interface StyleGenerationResponse {
  results: Product[];
}

export interface GetProductRequest {
  id: string;
}

export interface GetProductResponse {
  product: Product | undefined;
}

export interface CreateProductRequest {
  product: Product | undefined;
}

export interface CreateProductResponse {
  product: Product | undefined;
}

export interface Empty {
}

export interface PinterestImagePreferenceWithStyle {
  imagePreferenceItemWithStyle: ImagePreferenceItemWithStyle | undefined;
  searchQuery: string;
}

export interface ProductPreferenceToolUsage {
  toolUseId: string;
  preferences: ProductWithSearchQueryAndPreference[];
}

export interface PinterestGridToolUsage {
  toolUseId: string;
  imagePreferenceItems: PinterestImagePreferenceWithStyle[];
}

export interface PinterestImageGridToolUsage {
  toolUseId: string;
  imagePreferenceItems: PinterestImagePreferenceWithStyle[];
}

export interface FinishChatToolUsage {
  toolUseId: string;
  userRequirements: string[];
  productSuggestions: ProductSuggestion[];
}

export interface ExploreMessageV2 {
  message?:
    | { $case: "basicMessage"; basicMessage: Message }
    | { $case: "productPreferenceToolUsage"; productPreferenceToolUsage: ProductPreferenceToolUsage }
    | { $case: "pinterestGridToolUsage"; pinterestGridToolUsage: PinterestGridToolUsage }
    | { $case: "pinterestImageGridToolUsage"; pinterestImageGridToolUsage: PinterestImageGridToolUsage }
    | { $case: "finishChatToolUsage"; finishChatToolUsage: FinishChatToolUsage }
    | undefined;
}

export interface CardExpirationDate {
  month: number;
  year: number;
}

export interface Card {
  id: string;
  cardNumber: string;
  cvv: string;
  holderName: string;
  expirationDate: CardExpirationDate | undefined;
  billingAddress: string;
  mailingAddress?: string | undefined;
}

function createBaseProductWithSearchQuery(): ProductWithSearchQuery {
  return { product: undefined, query: "" };
}

export const ProductWithSearchQuery: MessageFns<ProductWithSearchQuery> = {
  encode(message: ProductWithSearchQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductWithSearchQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductWithSearchQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductWithSearchQuery {
    return {
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      query: isSet(object.query) ? globalThis.String(object.query) : "",
    };
  },

  toJSON(message: ProductWithSearchQuery): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },
};

function createBaseProduct(): Product {
  return {
    id: "",
    brandId: "",
    brandName: "",
    subBrandId: undefined,
    subBrandName: undefined,
    url: "",
    imageUrls: [],
    s3ImageUrls: [],
    title: "",
    price: 0,
    gender: 0,
    sizes: [],
    description: "",
    generatedDescription: undefined,
    fullGeneratedDescription: "",
    colors: [],
    materials: [],
    category: undefined,
    style: undefined,
    details: undefined,
    fit: undefined,
    name: "",
    compressedImageUrls: [],
    isKidProduct: false,
    scrapingMetadata: undefined,
    manuallyAdded: undefined,
    highresWebpUrls: [],
    originalPrice: undefined,
  };
}

export const Product: MessageFns<Product> = {
  encode(message: Product, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.brandId !== "") {
      writer.uint32(18).string(message.brandId);
    }
    if (message.brandName !== "") {
      writer.uint32(26).string(message.brandName);
    }
    if (message.subBrandId !== undefined) {
      writer.uint32(186).string(message.subBrandId);
    }
    if (message.subBrandName !== undefined) {
      writer.uint32(178).string(message.subBrandName);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    for (const v of message.imageUrls) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.s3ImageUrls) {
      writer.uint32(50).string(v!);
    }
    if (message.title !== "") {
      writer.uint32(58).string(message.title);
    }
    if (message.price !== 0) {
      writer.uint32(69).float(message.price);
    }
    if (message.gender !== 0) {
      writer.uint32(72).int32(message.gender);
    }
    for (const v of message.sizes) {
      writer.uint32(82).string(v!);
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.generatedDescription !== undefined) {
      writer.uint32(98).string(message.generatedDescription);
    }
    if (message.fullGeneratedDescription !== "") {
      writer.uint32(106).string(message.fullGeneratedDescription);
    }
    for (const v of message.colors) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.materials) {
      writer.uint32(122).string(v!);
    }
    if (message.category !== undefined) {
      writer.uint32(128).int32(message.category);
    }
    if (message.style !== undefined) {
      writer.uint32(138).string(message.style);
    }
    if (message.details !== undefined) {
      writer.uint32(146).string(message.details);
    }
    if (message.fit !== undefined) {
      writer.uint32(152).int32(message.fit);
    }
    if (message.name !== "") {
      writer.uint32(162).string(message.name);
    }
    for (const v of message.compressedImageUrls) {
      writer.uint32(170).string(v!);
    }
    if (message.isKidProduct !== false) {
      writer.uint32(192).bool(message.isKidProduct);
    }
    if (message.scrapingMetadata !== undefined) {
      Product_ScrapingMetadata.encode(message.scrapingMetadata, writer.uint32(202).fork()).join();
    }
    if (message.manuallyAdded !== undefined) {
      writer.uint32(208).bool(message.manuallyAdded);
    }
    for (const v of message.highresWebpUrls) {
      writer.uint32(218).string(v!);
    }
    if (message.originalPrice !== undefined) {
      writer.uint32(229).float(message.originalPrice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.brandId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.brandName = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.subBrandId = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.subBrandName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.imageUrls.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.s3ImageUrls.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.sizes.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.generatedDescription = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.fullGeneratedDescription = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.colors.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.materials.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.style = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.details = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.fit = reader.int32() as any;
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.compressedImageUrls.push(reader.string());
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.isKidProduct = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.scrapingMetadata = Product_ScrapingMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.manuallyAdded = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.highresWebpUrls.push(reader.string());
          continue;
        }
        case 28: {
          if (tag !== 229) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      brandId: isSet(object.brandId) ? globalThis.String(object.brandId) : "",
      brandName: isSet(object.brandName) ? globalThis.String(object.brandName) : "",
      subBrandId: isSet(object.subBrandId) ? globalThis.String(object.subBrandId) : undefined,
      subBrandName: isSet(object.subBrandName) ? globalThis.String(object.subBrandName) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      imageUrls: globalThis.Array.isArray(object?.imageUrls)
        ? object.imageUrls.map((e: any) => globalThis.String(e))
        : [],
      s3ImageUrls: globalThis.Array.isArray(object?.s3ImageUrls)
        ? object.s3ImageUrls.map((e: any) => globalThis.String(e))
        : [],
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : 0,
      sizes: globalThis.Array.isArray(object?.sizes) ? object.sizes.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      generatedDescription: isSet(object.generatedDescription)
        ? globalThis.String(object.generatedDescription)
        : undefined,
      fullGeneratedDescription: isSet(object.fullGeneratedDescription)
        ? globalThis.String(object.fullGeneratedDescription)
        : "",
      colors: globalThis.Array.isArray(object?.colors)
        ? object.colors.map((e: any) => globalThis.String(e))
        : [],
      materials: globalThis.Array.isArray(object?.materials)
        ? object.materials.map((e: any) => globalThis.String(e))
        : [],
      category: isSet(object.category) ? productCategoryFromJSON(object.category) : undefined,
      style: isSet(object.style) ? globalThis.String(object.style) : undefined,
      details: isSet(object.details) ? globalThis.String(object.details) : undefined,
      fit: isSet(object.fit) ? productFitFromJSON(object.fit) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      compressedImageUrls: globalThis.Array.isArray(object?.compressedImageUrls)
        ? object.compressedImageUrls.map((e: any) => globalThis.String(e))
        : [],
      isKidProduct: isSet(object.isKidProduct) ? globalThis.Boolean(object.isKidProduct) : false,
      scrapingMetadata: isSet(object.scrapingMetadata)
        ? Product_ScrapingMetadata.fromJSON(object.scrapingMetadata)
        : undefined,
      manuallyAdded: isSet(object.manuallyAdded) ? globalThis.Boolean(object.manuallyAdded) : undefined,
      highresWebpUrls: globalThis.Array.isArray(object?.highresWebpUrls)
        ? object.highresWebpUrls.map((e: any) => globalThis.String(e))
        : [],
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : undefined,
    };
  },

  toJSON(message: Product): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.brandId !== "") {
      obj.brandId = message.brandId;
    }
    if (message.brandName !== "") {
      obj.brandName = message.brandName;
    }
    if (message.subBrandId !== undefined) {
      obj.subBrandId = message.subBrandId;
    }
    if (message.subBrandName !== undefined) {
      obj.subBrandName = message.subBrandName;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.imageUrls?.length) {
      obj.imageUrls = message.imageUrls;
    }
    if (message.s3ImageUrls?.length) {
      obj.s3ImageUrls = message.s3ImageUrls;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.gender !== 0) {
      obj.gender = genderToJSON(message.gender);
    }
    if (message.sizes?.length) {
      obj.sizes = message.sizes;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.generatedDescription !== undefined) {
      obj.generatedDescription = message.generatedDescription;
    }
    if (message.fullGeneratedDescription !== "") {
      obj.fullGeneratedDescription = message.fullGeneratedDescription;
    }
    if (message.colors?.length) {
      obj.colors = message.colors;
    }
    if (message.materials?.length) {
      obj.materials = message.materials;
    }
    if (message.category !== undefined) {
      obj.category = productCategoryToJSON(message.category);
    }
    if (message.style !== undefined) {
      obj.style = message.style;
    }
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    if (message.fit !== undefined) {
      obj.fit = productFitToJSON(message.fit);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.compressedImageUrls?.length) {
      obj.compressedImageUrls = message.compressedImageUrls;
    }
    if (message.isKidProduct !== false) {
      obj.isKidProduct = message.isKidProduct;
    }
    if (message.scrapingMetadata !== undefined) {
      obj.scrapingMetadata = Product_ScrapingMetadata.toJSON(message.scrapingMetadata);
    }
    if (message.manuallyAdded !== undefined) {
      obj.manuallyAdded = message.manuallyAdded;
    }
    if (message.highresWebpUrls?.length) {
      obj.highresWebpUrls = message.highresWebpUrls;
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = message.originalPrice;
    }
    return obj;
  },
};

function createBaseProduct_ScrapingMetadata(): Product_ScrapingMetadata {
  return { contentQualityCheck: undefined, pipelineRunId: undefined };
}

export const Product_ScrapingMetadata: MessageFns<Product_ScrapingMetadata> = {
  encode(message: Product_ScrapingMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentQualityCheck !== undefined) {
      writer.uint32(8).bool(message.contentQualityCheck);
    }
    if (message.pipelineRunId !== undefined) {
      writer.uint32(18).string(message.pipelineRunId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product_ScrapingMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct_ScrapingMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.contentQualityCheck = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineRunId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product_ScrapingMetadata {
    return {
      contentQualityCheck: isSet(object.contentQualityCheck)
        ? globalThis.Boolean(object.contentQualityCheck)
        : undefined,
      pipelineRunId: isSet(object.pipelineRunId) ? globalThis.String(object.pipelineRunId) : undefined,
    };
  },

  toJSON(message: Product_ScrapingMetadata): unknown {
    const obj: any = {};
    if (message.contentQualityCheck !== undefined) {
      obj.contentQualityCheck = message.contentQualityCheck;
    }
    if (message.pipelineRunId !== undefined) {
      obj.pipelineRunId = message.pipelineRunId;
    }
    return obj;
  },
};

function createBaseProductWithScore(): ProductWithScore {
  return { product: undefined, score: 0 };
}

export const ProductWithScore: MessageFns<ProductWithScore> = {
  encode(message: ProductWithScore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductWithScore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductWithScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductWithScore {
    return {
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: ProductWithScore): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },
};

function createBaseProductWithScoreAndSearchQuery(): ProductWithScoreAndSearchQuery {
  return { product: undefined, score: 0, query: "" };
}

export const ProductWithScoreAndSearchQuery: MessageFns<ProductWithScoreAndSearchQuery> = {
  encode(message: ProductWithScoreAndSearchQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductWithScoreAndSearchQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductWithScoreAndSearchQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductWithScoreAndSearchQuery {
    return {
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      query: isSet(object.query) ? globalThis.String(object.query) : "",
    };
  },

  toJSON(message: ProductWithScoreAndSearchQuery): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },
};

function createBaseUserMetadata(): UserMetadata {
  return { gender: undefined, age: undefined, weight: undefined, height: undefined };
}

export const UserMetadata: MessageFns<UserMetadata> = {
  encode(message: UserMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gender !== undefined) {
      writer.uint32(8).int32(message.gender);
    }
    if (message.age !== undefined) {
      writer.uint32(16).int32(message.age);
    }
    if (message.weight !== undefined) {
      writer.uint32(24).int32(message.weight);
    }
    if (message.height !== undefined) {
      writer.uint32(32).int32(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.age = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMetadata {
    return {
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : undefined,
      age: isSet(object.age) ? globalThis.Number(object.age) : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
      height: isSet(object.height) ? globalThis.Number(object.height) : undefined,
    };
  },

  toJSON(message: UserMetadata): unknown {
    const obj: any = {};
    if (message.gender !== undefined) {
      obj.gender = genderToJSON(message.gender);
    }
    if (message.age !== undefined) {
      obj.age = Math.round(message.age);
    }
    if (message.weight !== undefined) {
      obj.weight = Math.round(message.weight);
    }
    if (message.height !== undefined) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },
};

function createBaseName(): Name {
  return { firstName: undefined, lastName: undefined };
}

export const Name: MessageFns<Name> = {
  encode(message: Name, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstName !== undefined) {
      writer.uint32(10).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(18).string(message.lastName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Name {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Name {
    return {
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
    };
  },

  toJSON(message: Name): unknown {
    const obj: any = {};
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    return obj;
  },
};

function createBaseUserProfile(): UserProfile {
  return {
    id: "",
    metadata: undefined,
    name: undefined,
    socialLinks: undefined,
    isOnboardingCompleted: false,
    address: undefined,
    email: undefined,
    isPushNotificationsEnabled: false,
    sizing: undefined,
    createdAt: 0,
    role: 0,
    phoneNumber: undefined,
    membershipType: undefined,
    styleImageUrls: [],
    favoriteBrands: [],
    generatedProfileDescription: undefined,
    firstOrderQuery: undefined,
    devices: [],
    whatBringsYouToFetchr: undefined,
    preferencesAndQuirks: undefined,
    stylePickerProductIds: [],
    selfonboardedGeneratedStyleDescription: undefined,
    billing: undefined,
  };
}

export const UserProfile: MessageFns<UserProfile> = {
  encode(message: UserProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.metadata !== undefined) {
      UserMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(26).fork()).join();
    }
    if (message.socialLinks !== undefined) {
      SocialLinks.encode(message.socialLinks, writer.uint32(34).fork()).join();
    }
    if (message.isOnboardingCompleted !== false) {
      writer.uint32(40).bool(message.isOnboardingCompleted);
    }
    if (message.address !== undefined) {
      UserAddress.encode(message.address, writer.uint32(50).fork()).join();
    }
    if (message.email !== undefined) {
      writer.uint32(58).string(message.email);
    }
    if (message.isPushNotificationsEnabled !== false) {
      writer.uint32(64).bool(message.isPushNotificationsEnabled);
    }
    if (message.sizing !== undefined) {
      UserSizing.encode(message.sizing, writer.uint32(74).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(80).int64(message.createdAt);
    }
    if (message.role !== 0) {
      writer.uint32(88).int32(message.role);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(98).string(message.phoneNumber);
    }
    if (message.membershipType !== undefined) {
      writer.uint32(104).int32(message.membershipType);
    }
    for (const v of message.styleImageUrls) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.favoriteBrands) {
      writer.uint32(122).string(v!);
    }
    if (message.generatedProfileDescription !== undefined) {
      GeneratedProfileDescription.encode(message.generatedProfileDescription, writer.uint32(130).fork()).join();
    }
    if (message.firstOrderQuery !== undefined) {
      writer.uint32(138).string(message.firstOrderQuery);
    }
    for (const v of message.devices) {
      UserDevice.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.whatBringsYouToFetchr !== undefined) {
      writer.uint32(168).int32(message.whatBringsYouToFetchr);
    }
    if (message.preferencesAndQuirks !== undefined) {
      writer.uint32(178).string(message.preferencesAndQuirks);
    }
    for (const v of message.stylePickerProductIds) {
      writer.uint32(186).string(v!);
    }
    if (message.selfonboardedGeneratedStyleDescription !== undefined) {
      writer.uint32(194).string(message.selfonboardedGeneratedStyleDescription);
    }
    if (message.billing !== undefined) {
      UserBilling.encode(message.billing, writer.uint32(202).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = UserMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.socialLinks = SocialLinks.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isOnboardingCompleted = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.address = UserAddress.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isPushNotificationsEnabled = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.sizing = UserSizing.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.membershipType = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.styleImageUrls.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.favoriteBrands.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.generatedProfileDescription = GeneratedProfileDescription.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.firstOrderQuery = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.devices.push(UserDevice.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.whatBringsYouToFetchr = reader.int32() as any;
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.preferencesAndQuirks = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.stylePickerProductIds.push(reader.string());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.selfonboardedGeneratedStyleDescription = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.billing = UserBilling.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfile {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      metadata: isSet(object.metadata) ? UserMetadata.fromJSON(object.metadata) : undefined,
      name: isSet(object.name) ? Name.fromJSON(object.name) : undefined,
      socialLinks: isSet(object.socialLinks) ? SocialLinks.fromJSON(object.socialLinks) : undefined,
      isOnboardingCompleted: isSet(object.isOnboardingCompleted)
        ? globalThis.Boolean(object.isOnboardingCompleted)
        : false,
      address: isSet(object.address) ? UserAddress.fromJSON(object.address) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      isPushNotificationsEnabled: isSet(object.isPushNotificationsEnabled)
        ? globalThis.Boolean(object.isPushNotificationsEnabled)
        : false,
      sizing: isSet(object.sizing) ? UserSizing.fromJSON(object.sizing) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      role: isSet(object.role) ? userRoleFromJSON(object.role) : 0,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
      membershipType: isSet(object.membershipType) ? membershipTypeFromJSON(object.membershipType) : undefined,
      styleImageUrls: globalThis.Array.isArray(object?.styleImageUrls)
        ? object.styleImageUrls.map((e: any) => globalThis.String(e))
        : [],
      favoriteBrands: globalThis.Array.isArray(object?.favoriteBrands)
        ? object.favoriteBrands.map((e: any) => globalThis.String(e))
        : [],
      generatedProfileDescription: isSet(object.generatedProfileDescription)
        ? GeneratedProfileDescription.fromJSON(object.generatedProfileDescription)
        : undefined,
      firstOrderQuery: isSet(object.firstOrderQuery) ? globalThis.String(object.firstOrderQuery) : undefined,
      devices: globalThis.Array.isArray(object?.devices)
        ? object.devices.map((e: any) => UserDevice.fromJSON(e))
        : [],
      whatBringsYouToFetchr: isSet(object.whatBringsYouToFetchr)
        ? whatBringsYouToFetchrFromJSON(object.whatBringsYouToFetchr)
        : undefined,
      preferencesAndQuirks: isSet(object.preferencesAndQuirks)
        ? globalThis.String(object.preferencesAndQuirks)
        : undefined,
      stylePickerProductIds: globalThis.Array.isArray(object?.stylePickerProductIds)
        ? object.stylePickerProductIds.map((e: any) => globalThis.String(e))
        : [],
      selfonboardedGeneratedStyleDescription: isSet(object.selfonboardedGeneratedStyleDescription)
        ? globalThis.String(object.selfonboardedGeneratedStyleDescription)
        : undefined,
      billing: isSet(object.billing) ? UserBilling.fromJSON(object.billing) : undefined,
    };
  },

  toJSON(message: UserProfile): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.metadata !== undefined) {
      obj.metadata = UserMetadata.toJSON(message.metadata);
    }
    if (message.name !== undefined) {
      obj.name = Name.toJSON(message.name);
    }
    if (message.socialLinks !== undefined) {
      obj.socialLinks = SocialLinks.toJSON(message.socialLinks);
    }
    if (message.isOnboardingCompleted !== false) {
      obj.isOnboardingCompleted = message.isOnboardingCompleted;
    }
    if (message.address !== undefined) {
      obj.address = UserAddress.toJSON(message.address);
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.isPushNotificationsEnabled !== false) {
      obj.isPushNotificationsEnabled = message.isPushNotificationsEnabled;
    }
    if (message.sizing !== undefined) {
      obj.sizing = UserSizing.toJSON(message.sizing);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.role !== 0) {
      obj.role = userRoleToJSON(message.role);
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.membershipType !== undefined) {
      obj.membershipType = membershipTypeToJSON(message.membershipType);
    }
    if (message.styleImageUrls?.length) {
      obj.styleImageUrls = message.styleImageUrls;
    }
    if (message.favoriteBrands?.length) {
      obj.favoriteBrands = message.favoriteBrands;
    }
    if (message.generatedProfileDescription !== undefined) {
      obj.generatedProfileDescription = GeneratedProfileDescription.toJSON(message.generatedProfileDescription);
    }
    if (message.firstOrderQuery !== undefined) {
      obj.firstOrderQuery = message.firstOrderQuery;
    }
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => UserDevice.toJSON(e));
    }
    if (message.whatBringsYouToFetchr !== undefined) {
      obj.whatBringsYouToFetchr = whatBringsYouToFetchrToJSON(message.whatBringsYouToFetchr);
    }
    if (message.preferencesAndQuirks !== undefined) {
      obj.preferencesAndQuirks = message.preferencesAndQuirks;
    }
    if (message.stylePickerProductIds?.length) {
      obj.stylePickerProductIds = message.stylePickerProductIds;
    }
    if (message.selfonboardedGeneratedStyleDescription !== undefined) {
      obj.selfonboardedGeneratedStyleDescription = message.selfonboardedGeneratedStyleDescription;
    }
    if (message.billing !== undefined) {
      obj.billing = UserBilling.toJSON(message.billing);
    }
    return obj;
  },
};

function createBaseUserDevice(): UserDevice {
  return { deviceId: "", notificationEnabled: false, platform: 0 };
}

export const UserDevice: MessageFns<UserDevice> = {
  encode(message: UserDevice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.notificationEnabled !== false) {
      writer.uint32(16).bool(message.notificationEnabled);
    }
    if (message.platform !== 0) {
      writer.uint32(24).int32(message.platform);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserDevice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.notificationEnabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDevice {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      notificationEnabled: isSet(object.notificationEnabled) ? globalThis.Boolean(object.notificationEnabled) : false,
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
    };
  },

  toJSON(message: UserDevice): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.notificationEnabled !== false) {
      obj.notificationEnabled = message.notificationEnabled;
    }
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    return obj;
  },
};

function createBaseGeneratedProfileDescription(): GeneratedProfileDescription {
  return {
    description: undefined,
    lastUpdatedAtNumProductPreferences: undefined,
    hash: undefined,
    didTriedToPopulateBioFromPendingRegisterTable: undefined,
  };
}

export const GeneratedProfileDescription: MessageFns<GeneratedProfileDescription> = {
  encode(message: GeneratedProfileDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== undefined) {
      writer.uint32(10).string(message.description);
    }
    if (message.lastUpdatedAtNumProductPreferences !== undefined) {
      writer.uint32(16).int64(message.lastUpdatedAtNumProductPreferences);
    }
    if (message.hash !== undefined) {
      writer.uint32(26).string(message.hash);
    }
    if (message.didTriedToPopulateBioFromPendingRegisterTable !== undefined) {
      writer.uint32(32).bool(message.didTriedToPopulateBioFromPendingRegisterTable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratedProfileDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratedProfileDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastUpdatedAtNumProductPreferences = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.didTriedToPopulateBioFromPendingRegisterTable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeneratedProfileDescription {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      lastUpdatedAtNumProductPreferences: isSet(object.lastUpdatedAtNumProductPreferences)
        ? globalThis.Number(object.lastUpdatedAtNumProductPreferences)
        : undefined,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : undefined,
      didTriedToPopulateBioFromPendingRegisterTable: isSet(object.didTriedToPopulateBioFromPendingRegisterTable)
        ? globalThis.Boolean(object.didTriedToPopulateBioFromPendingRegisterTable)
        : undefined,
    };
  },

  toJSON(message: GeneratedProfileDescription): unknown {
    const obj: any = {};
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.lastUpdatedAtNumProductPreferences !== undefined) {
      obj.lastUpdatedAtNumProductPreferences = Math.round(message.lastUpdatedAtNumProductPreferences);
    }
    if (message.hash !== undefined) {
      obj.hash = message.hash;
    }
    if (message.didTriedToPopulateBioFromPendingRegisterTable !== undefined) {
      obj.didTriedToPopulateBioFromPendingRegisterTable = message.didTriedToPopulateBioFromPendingRegisterTable;
    }
    return obj;
  },
};

function createBaseSocialLinks(): SocialLinks {
  return { instagramHandle: undefined };
}

export const SocialLinks: MessageFns<SocialLinks> = {
  encode(message: SocialLinks, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instagramHandle !== undefined) {
      writer.uint32(10).string(message.instagramHandle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SocialLinks {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSocialLinks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instagramHandle = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SocialLinks {
    return { instagramHandle: isSet(object.instagramHandle) ? globalThis.String(object.instagramHandle) : undefined };
  },

  toJSON(message: SocialLinks): unknown {
    const obj: any = {};
    if (message.instagramHandle !== undefined) {
      obj.instagramHandle = message.instagramHandle;
    }
    return obj;
  },
};

function createBaseUserSizing(): UserSizing {
  return {
    tops: undefined,
    bottoms: undefined,
    waist: undefined,
    bust: undefined,
    dress: undefined,
    shoes: undefined,
    hips: undefined,
    inseam: undefined,
    waistApproximate: undefined,
    hipsApproximate: undefined,
    inseamApproximate: undefined,
    bustApproximate: undefined,
  };
}

export const UserSizing: MessageFns<UserSizing> = {
  encode(message: UserSizing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tops !== undefined) {
      writer.uint32(8).int32(message.tops);
    }
    if (message.bottoms !== undefined) {
      writer.uint32(18).string(message.bottoms);
    }
    if (message.waist !== undefined) {
      writer.uint32(26).string(message.waist);
    }
    if (message.bust !== undefined) {
      writer.uint32(34).string(message.bust);
    }
    if (message.dress !== undefined) {
      writer.uint32(42).string(message.dress);
    }
    if (message.shoes !== undefined) {
      writer.uint32(50).string(message.shoes);
    }
    if (message.hips !== undefined) {
      writer.uint32(58).string(message.hips);
    }
    if (message.inseam !== undefined) {
      writer.uint32(66).string(message.inseam);
    }
    if (message.waistApproximate !== undefined) {
      writer.uint32(72).bool(message.waistApproximate);
    }
    if (message.hipsApproximate !== undefined) {
      writer.uint32(80).bool(message.hipsApproximate);
    }
    if (message.inseamApproximate !== undefined) {
      writer.uint32(88).bool(message.inseamApproximate);
    }
    if (message.bustApproximate !== undefined) {
      writer.uint32(96).bool(message.bustApproximate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSizing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSizing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tops = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bottoms = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.waist = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bust = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.shoes = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.hips = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inseam = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.waistApproximate = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.hipsApproximate = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.inseamApproximate = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.bustApproximate = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSizing {
    return {
      tops: isSet(object.tops) ? sizeTopFromJSON(object.tops) : undefined,
      bottoms: isSet(object.bottoms) ? globalThis.String(object.bottoms) : undefined,
      waist: isSet(object.waist) ? globalThis.String(object.waist) : undefined,
      bust: isSet(object.bust) ? globalThis.String(object.bust) : undefined,
      dress: isSet(object.dress) ? globalThis.String(object.dress) : undefined,
      shoes: isSet(object.shoes) ? globalThis.String(object.shoes) : undefined,
      hips: isSet(object.hips) ? globalThis.String(object.hips) : undefined,
      inseam: isSet(object.inseam) ? globalThis.String(object.inseam) : undefined,
      waistApproximate: isSet(object.waistApproximate) ? globalThis.Boolean(object.waistApproximate) : undefined,
      hipsApproximate: isSet(object.hipsApproximate) ? globalThis.Boolean(object.hipsApproximate) : undefined,
      inseamApproximate: isSet(object.inseamApproximate) ? globalThis.Boolean(object.inseamApproximate) : undefined,
      bustApproximate: isSet(object.bustApproximate) ? globalThis.Boolean(object.bustApproximate) : undefined,
    };
  },

  toJSON(message: UserSizing): unknown {
    const obj: any = {};
    if (message.tops !== undefined) {
      obj.tops = sizeTopToJSON(message.tops);
    }
    if (message.bottoms !== undefined) {
      obj.bottoms = message.bottoms;
    }
    if (message.waist !== undefined) {
      obj.waist = message.waist;
    }
    if (message.bust !== undefined) {
      obj.bust = message.bust;
    }
    if (message.dress !== undefined) {
      obj.dress = message.dress;
    }
    if (message.shoes !== undefined) {
      obj.shoes = message.shoes;
    }
    if (message.hips !== undefined) {
      obj.hips = message.hips;
    }
    if (message.inseam !== undefined) {
      obj.inseam = message.inseam;
    }
    if (message.waistApproximate !== undefined) {
      obj.waistApproximate = message.waistApproximate;
    }
    if (message.hipsApproximate !== undefined) {
      obj.hipsApproximate = message.hipsApproximate;
    }
    if (message.inseamApproximate !== undefined) {
      obj.inseamApproximate = message.inseamApproximate;
    }
    if (message.bustApproximate !== undefined) {
      obj.bustApproximate = message.bustApproximate;
    }
    return obj;
  },
};

function createBaseUserAddress(): UserAddress {
  return {
    addressLineOne: undefined,
    addressLineTwo: undefined,
    city: undefined,
    state: undefined,
    country: undefined,
    postalCode: undefined,
  };
}

export const UserAddress: MessageFns<UserAddress> = {
  encode(message: UserAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addressLineOne !== undefined) {
      writer.uint32(10).string(message.addressLineOne);
    }
    if (message.addressLineTwo !== undefined) {
      writer.uint32(18).string(message.addressLineTwo);
    }
    if (message.city !== undefined) {
      writer.uint32(26).string(message.city);
    }
    if (message.state !== undefined) {
      writer.uint32(34).string(message.state);
    }
    if (message.country !== undefined) {
      writer.uint32(42).string(message.country);
    }
    if (message.postalCode !== undefined) {
      writer.uint32(50).string(message.postalCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addressLineOne = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addressLineTwo = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserAddress {
    return {
      addressLineOne: isSet(object.addressLineOne) ? globalThis.String(object.addressLineOne) : undefined,
      addressLineTwo: isSet(object.addressLineTwo) ? globalThis.String(object.addressLineTwo) : undefined,
      city: isSet(object.city) ? globalThis.String(object.city) : undefined,
      state: isSet(object.state) ? globalThis.String(object.state) : undefined,
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : undefined,
    };
  },

  toJSON(message: UserAddress): unknown {
    const obj: any = {};
    if (message.addressLineOne !== undefined) {
      obj.addressLineOne = message.addressLineOne;
    }
    if (message.addressLineTwo !== undefined) {
      obj.addressLineTwo = message.addressLineTwo;
    }
    if (message.city !== undefined) {
      obj.city = message.city;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    if (message.postalCode !== undefined) {
      obj.postalCode = message.postalCode;
    }
    return obj;
  },
};

function createBaseUserProductPreference(): UserProductPreference {
  return {
    id: "",
    preferenceType: undefined,
    userId: "",
    productId: "",
    requestId: "",
    cohort: 0,
    query: undefined,
    comments: undefined,
  };
}

export const UserProductPreference: MessageFns<UserProductPreference> = {
  encode(message: UserProductPreference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.preferenceType !== undefined) {
      writer.uint32(16).int32(message.preferenceType);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.productId !== "") {
      writer.uint32(34).string(message.productId);
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    if (message.cohort !== 0) {
      writer.uint32(48).int32(message.cohort);
    }
    if (message.query !== undefined) {
      writer.uint32(58).string(message.query);
    }
    if (message.comments !== undefined) {
      writer.uint32(66).string(message.comments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProductPreference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProductPreference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.preferenceType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cohort = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.comments = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProductPreference {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      preferenceType: isSet(object.preferenceType) ? preferenceTypeFromJSON(object.preferenceType) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      cohort: isSet(object.cohort) ? globalThis.Number(object.cohort) : 0,
      query: isSet(object.query) ? globalThis.String(object.query) : undefined,
      comments: isSet(object.comments) ? globalThis.String(object.comments) : undefined,
    };
  },

  toJSON(message: UserProductPreference): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.preferenceType !== undefined) {
      obj.preferenceType = preferenceTypeToJSON(message.preferenceType);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.cohort !== 0) {
      obj.cohort = Math.round(message.cohort);
    }
    if (message.query !== undefined) {
      obj.query = message.query;
    }
    if (message.comments !== undefined) {
      obj.comments = message.comments;
    }
    return obj;
  },
};

function createBasePopulatedUserProductPreference(): PopulatedUserProductPreference {
  return { preference: undefined, productDetails: undefined };
}

export const PopulatedUserProductPreference: MessageFns<PopulatedUserProductPreference> = {
  encode(message: PopulatedUserProductPreference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preference !== undefined) {
      UserProductPreference.encode(message.preference, writer.uint32(10).fork()).join();
    }
    if (message.productDetails !== undefined) {
      Product.encode(message.productDetails, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopulatedUserProductPreference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopulatedUserProductPreference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preference = UserProductPreference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productDetails = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopulatedUserProductPreference {
    return {
      preference: isSet(object.preference) ? UserProductPreference.fromJSON(object.preference) : undefined,
      productDetails: isSet(object.productDetails) ? Product.fromJSON(object.productDetails) : undefined,
    };
  },

  toJSON(message: PopulatedUserProductPreference): unknown {
    const obj: any = {};
    if (message.preference !== undefined) {
      obj.preference = UserProductPreference.toJSON(message.preference);
    }
    if (message.productDetails !== undefined) {
      obj.productDetails = Product.toJSON(message.productDetails);
    }
    return obj;
  },
};

function createBaseStringList(): StringList {
  return { values: [] };
}

export const StringList: MessageFns<StringList> = {
  encode(message: StringList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringList {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: StringList): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },
};

function createBaseProductWithSearchQueryAndPreference(): ProductWithSearchQueryAndPreference {
  return { product: undefined, preferenceItem: undefined, query: "" };
}

export const ProductWithSearchQueryAndPreference: MessageFns<ProductWithSearchQueryAndPreference> = {
  encode(message: ProductWithSearchQueryAndPreference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    if (message.preferenceItem !== undefined) {
      ProductPreferenceItem.encode(message.preferenceItem, writer.uint32(18).fork()).join();
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductWithSearchQueryAndPreference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductWithSearchQueryAndPreference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preferenceItem = ProductPreferenceItem.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductWithSearchQueryAndPreference {
    return {
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      preferenceItem: isSet(object.preferenceItem) ? ProductPreferenceItem.fromJSON(object.preferenceItem) : undefined,
      query: isSet(object.query) ? globalThis.String(object.query) : "",
    };
  },

  toJSON(message: ProductWithSearchQueryAndPreference): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.preferenceItem !== undefined) {
      obj.preferenceItem = ProductPreferenceItem.toJSON(message.preferenceItem);
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },
};

function createBaseProductPreferenceItem(): ProductPreferenceItem {
  return { itemId: "", preferenceType: 0, comments: undefined };
}

export const ProductPreferenceItem: MessageFns<ProductPreferenceItem> = {
  encode(message: ProductPreferenceItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemId !== "") {
      writer.uint32(10).string(message.itemId);
    }
    if (message.preferenceType !== 0) {
      writer.uint32(16).int32(message.preferenceType);
    }
    if (message.comments !== undefined) {
      writer.uint32(26).string(message.comments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductPreferenceItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductPreferenceItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.preferenceType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comments = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductPreferenceItem {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "",
      preferenceType: isSet(object.preferenceType) ? preferenceTypeFromJSON(object.preferenceType) : 0,
      comments: isSet(object.comments) ? globalThis.String(object.comments) : undefined,
    };
  },

  toJSON(message: ProductPreferenceItem): unknown {
    const obj: any = {};
    if (message.itemId !== "") {
      obj.itemId = message.itemId;
    }
    if (message.preferenceType !== 0) {
      obj.preferenceType = preferenceTypeToJSON(message.preferenceType);
    }
    if (message.comments !== undefined) {
      obj.comments = message.comments;
    }
    return obj;
  },
};

function createBasePopulatedProductPreferenceItem(): PopulatedProductPreferenceItem {
  return { preferenceItem: undefined, product: undefined };
}

export const PopulatedProductPreferenceItem: MessageFns<PopulatedProductPreferenceItem> = {
  encode(message: PopulatedProductPreferenceItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preferenceItem !== undefined) {
      ProductPreferenceItem.encode(message.preferenceItem, writer.uint32(10).fork()).join();
    }
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopulatedProductPreferenceItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopulatedProductPreferenceItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preferenceItem = ProductPreferenceItem.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopulatedProductPreferenceItem {
    return {
      preferenceItem: isSet(object.preferenceItem) ? ProductPreferenceItem.fromJSON(object.preferenceItem) : undefined,
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
    };
  },

  toJSON(message: PopulatedProductPreferenceItem): unknown {
    const obj: any = {};
    if (message.preferenceItem !== undefined) {
      obj.preferenceItem = ProductPreferenceItem.toJSON(message.preferenceItem);
    }
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },
};

function createBaseProductRecommendation(): ProductRecommendation {
  return { productName: "", isSelected: false };
}

export const ProductRecommendation: MessageFns<ProductRecommendation> = {
  encode(message: ProductRecommendation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productName !== "") {
      writer.uint32(10).string(message.productName);
    }
    if (message.isSelected !== false) {
      writer.uint32(16).bool(message.isSelected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductRecommendation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductRecommendation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSelected = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductRecommendation {
    return {
      productName: isSet(object.productName) ? globalThis.String(object.productName) : "",
      isSelected: isSet(object.isSelected) ? globalThis.Boolean(object.isSelected) : false,
    };
  },

  toJSON(message: ProductRecommendation): unknown {
    const obj: any = {};
    if (message.productName !== "") {
      obj.productName = message.productName;
    }
    if (message.isSelected !== false) {
      obj.isSelected = message.isSelected;
    }
    return obj;
  },
};

function createBaseProductPurchase(): ProductPurchase {
  return {
    id: "",
    productId: "",
    size: "",
    price: 0,
    originalPrice: undefined,
    isRefundable: undefined,
    userFeedback: undefined,
    refundStatus: undefined,
    product: undefined,
    color: "",
    paymentStatus: 0,
    stripePaymentId: undefined,
    isArchived: false,
    archiveReason: undefined,
  };
}

export const ProductPurchase: MessageFns<ProductPurchase> = {
  encode(message: ProductPurchase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.size !== "") {
      writer.uint32(26).string(message.size);
    }
    if (message.price !== 0) {
      writer.uint32(37).float(message.price);
    }
    if (message.originalPrice !== undefined) {
      writer.uint32(45).float(message.originalPrice);
    }
    if (message.isRefundable !== undefined) {
      writer.uint32(48).bool(message.isRefundable);
    }
    if (message.userFeedback !== undefined) {
      UserProductPurchaseFeedback.encode(message.userFeedback, writer.uint32(58).fork()).join();
    }
    if (message.refundStatus !== undefined) {
      writer.uint32(64).int32(message.refundStatus);
    }
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(74).fork()).join();
    }
    if (message.color !== "") {
      writer.uint32(82).string(message.color);
    }
    if (message.paymentStatus !== 0) {
      writer.uint32(88).int32(message.paymentStatus);
    }
    if (message.stripePaymentId !== undefined) {
      writer.uint32(98).string(message.stripePaymentId);
    }
    if (message.isArchived !== false) {
      writer.uint32(104).bool(message.isArchived);
    }
    if (message.archiveReason !== undefined) {
      writer.uint32(114).string(message.archiveReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductPurchase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductPurchase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.size = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isRefundable = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userFeedback = UserProductPurchaseFeedback.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.refundStatus = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.paymentStatus = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.stripePaymentId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isArchived = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.archiveReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductPurchase {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      size: isSet(object.size) ? globalThis.String(object.size) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : undefined,
      isRefundable: isSet(object.isRefundable) ? globalThis.Boolean(object.isRefundable) : undefined,
      userFeedback: isSet(object.userFeedback) ? UserProductPurchaseFeedback.fromJSON(object.userFeedback) : undefined,
      refundStatus: isSet(object.refundStatus) ? refundStatusFromJSON(object.refundStatus) : undefined,
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      paymentStatus: isSet(object.paymentStatus) ? paymentStatusFromJSON(object.paymentStatus) : 0,
      stripePaymentId: isSet(object.stripePaymentId) ? globalThis.String(object.stripePaymentId) : undefined,
      isArchived: isSet(object.isArchived) ? globalThis.Boolean(object.isArchived) : false,
      archiveReason: isSet(object.archiveReason) ? globalThis.String(object.archiveReason) : undefined,
    };
  },

  toJSON(message: ProductPurchase): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.size !== "") {
      obj.size = message.size;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = message.originalPrice;
    }
    if (message.isRefundable !== undefined) {
      obj.isRefundable = message.isRefundable;
    }
    if (message.userFeedback !== undefined) {
      obj.userFeedback = UserProductPurchaseFeedback.toJSON(message.userFeedback);
    }
    if (message.refundStatus !== undefined) {
      obj.refundStatus = refundStatusToJSON(message.refundStatus);
    }
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.paymentStatus !== 0) {
      obj.paymentStatus = paymentStatusToJSON(message.paymentStatus);
    }
    if (message.stripePaymentId !== undefined) {
      obj.stripePaymentId = message.stripePaymentId;
    }
    if (message.isArchived !== false) {
      obj.isArchived = message.isArchived;
    }
    if (message.archiveReason !== undefined) {
      obj.archiveReason = message.archiveReason;
    }
    return obj;
  },
};

function createBaseUserProductPurchaseFeedback(): UserProductPurchaseFeedback {
  return { feedback: undefined, refundReason: undefined, categories: [] };
}

export const UserProductPurchaseFeedback: MessageFns<UserProductPurchaseFeedback> = {
  encode(message: UserProductPurchaseFeedback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feedback !== undefined) {
      writer.uint32(10).string(message.feedback);
    }
    if (message.refundReason !== undefined) {
      writer.uint32(18).string(message.refundReason);
    }
    writer.uint32(26).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProductPurchaseFeedback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProductPurchaseFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feedback = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundReason = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.categories.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProductPurchaseFeedback {
    return {
      feedback: isSet(object.feedback) ? globalThis.String(object.feedback) : undefined,
      refundReason: isSet(object.refundReason) ? globalThis.String(object.refundReason) : undefined,
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => productPurchaseFeedbackCategoryFromJSON(e))
        : [],
    };
  },

  toJSON(message: UserProductPurchaseFeedback): unknown {
    const obj: any = {};
    if (message.feedback !== undefined) {
      obj.feedback = message.feedback;
    }
    if (message.refundReason !== undefined) {
      obj.refundReason = message.refundReason;
    }
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => productPurchaseFeedbackCategoryToJSON(e));
    }
    return obj;
  },
};

function createBaseProductPurchaseSuggestion(): ProductPurchaseSuggestion {
  return {
    id: "",
    productId: "",
    size: "",
    price: 0,
    originalPrice: undefined,
    isRefundable: undefined,
    product: undefined,
    isAccepted: false,
    note: undefined,
    color: "",
    status: 0,
    aiJudgeAnalysis: undefined,
    isArchived: false,
    archiveReason: undefined,
    internalData: undefined,
  };
}

export const ProductPurchaseSuggestion: MessageFns<ProductPurchaseSuggestion> = {
  encode(message: ProductPurchaseSuggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.size !== "") {
      writer.uint32(26).string(message.size);
    }
    if (message.price !== 0) {
      writer.uint32(37).float(message.price);
    }
    if (message.originalPrice !== undefined) {
      writer.uint32(45).float(message.originalPrice);
    }
    if (message.isRefundable !== undefined) {
      writer.uint32(48).bool(message.isRefundable);
    }
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(66).fork()).join();
    }
    if (message.isAccepted !== false) {
      writer.uint32(56).bool(message.isAccepted);
    }
    if (message.note !== undefined) {
      writer.uint32(74).string(message.note);
    }
    if (message.color !== "") {
      writer.uint32(82).string(message.color);
    }
    if (message.status !== 0) {
      writer.uint32(88).int32(message.status);
    }
    if (message.aiJudgeAnalysis !== undefined) {
      writer.uint32(98).string(message.aiJudgeAnalysis);
    }
    if (message.isArchived !== false) {
      writer.uint32(104).bool(message.isArchived);
    }
    if (message.archiveReason !== undefined) {
      writer.uint32(114).string(message.archiveReason);
    }
    if (message.internalData !== undefined) {
      InternalProductPurchaseSuggestionData.encode(message.internalData, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductPurchaseSuggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductPurchaseSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.size = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isRefundable = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isAccepted = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.note = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.aiJudgeAnalysis = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isArchived = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.archiveReason = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.internalData = InternalProductPurchaseSuggestionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductPurchaseSuggestion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      size: isSet(object.size) ? globalThis.String(object.size) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : undefined,
      isRefundable: isSet(object.isRefundable) ? globalThis.Boolean(object.isRefundable) : undefined,
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      isAccepted: isSet(object.isAccepted) ? globalThis.Boolean(object.isAccepted) : false,
      note: isSet(object.note) ? globalThis.String(object.note) : undefined,
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      status: isSet(object.status) ? productPurchaseSuggestionStatusFromJSON(object.status) : 0,
      aiJudgeAnalysis: isSet(object.aiJudgeAnalysis) ? globalThis.String(object.aiJudgeAnalysis) : undefined,
      isArchived: isSet(object.isArchived) ? globalThis.Boolean(object.isArchived) : false,
      archiveReason: isSet(object.archiveReason) ? globalThis.String(object.archiveReason) : undefined,
      internalData: isSet(object.internalData)
        ? InternalProductPurchaseSuggestionData.fromJSON(object.internalData)
        : undefined,
    };
  },

  toJSON(message: ProductPurchaseSuggestion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.size !== "") {
      obj.size = message.size;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = message.originalPrice;
    }
    if (message.isRefundable !== undefined) {
      obj.isRefundable = message.isRefundable;
    }
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.isAccepted !== false) {
      obj.isAccepted = message.isAccepted;
    }
    if (message.note !== undefined) {
      obj.note = message.note;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.status !== 0) {
      obj.status = productPurchaseSuggestionStatusToJSON(message.status);
    }
    if (message.aiJudgeAnalysis !== undefined) {
      obj.aiJudgeAnalysis = message.aiJudgeAnalysis;
    }
    if (message.isArchived !== false) {
      obj.isArchived = message.isArchived;
    }
    if (message.archiveReason !== undefined) {
      obj.archiveReason = message.archiveReason;
    }
    if (message.internalData !== undefined) {
      obj.internalData = InternalProductPurchaseSuggestionData.toJSON(message.internalData);
    }
    return obj;
  },
};

function createBaseShipment(): Shipment {
  return {
    id: "",
    orderId: "",
    brand: undefined,
    productPurchases: [],
    status: 0,
    brandOrderId: undefined,
    trackingNumber: undefined,
    trackingUrl: undefined,
    expectedDeliveryDateStart: undefined,
    expectedDeliveryDateEnd: undefined,
    deliveredAt: undefined,
    email: undefined,
    possibleTrackingNumbers: [],
    totalPrice: undefined,
    shippingCost: undefined,
    stripePaymentId: undefined,
  };
}

export const Shipment: MessageFns<Shipment> = {
  encode(message: Shipment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(26).fork()).join();
    }
    for (const v of message.productPurchases) {
      ProductPurchase.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.brandOrderId !== undefined) {
      writer.uint32(50).string(message.brandOrderId);
    }
    if (message.trackingNumber !== undefined) {
      writer.uint32(58).string(message.trackingNumber);
    }
    if (message.trackingUrl !== undefined) {
      writer.uint32(66).string(message.trackingUrl);
    }
    if (message.expectedDeliveryDateStart !== undefined) {
      writer.uint32(72).int64(message.expectedDeliveryDateStart);
    }
    if (message.expectedDeliveryDateEnd !== undefined) {
      writer.uint32(80).int64(message.expectedDeliveryDateEnd);
    }
    if (message.deliveredAt !== undefined) {
      writer.uint32(88).int64(message.deliveredAt);
    }
    if (message.email !== undefined) {
      writer.uint32(98).string(message.email);
    }
    for (const v of message.possibleTrackingNumbers) {
      writer.uint32(106).string(v!);
    }
    if (message.totalPrice !== undefined) {
      writer.uint32(117).float(message.totalPrice);
    }
    if (message.shippingCost !== undefined) {
      writer.uint32(125).float(message.shippingCost);
    }
    if (message.stripePaymentId !== undefined) {
      writer.uint32(130).string(message.stripePaymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shipment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.productPurchases.push(ProductPurchase.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.brandOrderId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.trackingNumber = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.trackingUrl = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.expectedDeliveryDateStart = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.expectedDeliveryDateEnd = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.deliveredAt = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.possibleTrackingNumbers.push(reader.string());
          continue;
        }
        case 14: {
          if (tag !== 117) {
            break;
          }

          message.totalPrice = reader.float();
          continue;
        }
        case 15: {
          if (tag !== 125) {
            break;
          }

          message.shippingCost = reader.float();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.stripePaymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shipment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined,
      productPurchases: globalThis.Array.isArray(object?.productPurchases)
        ? object.productPurchases.map((e: any) => ProductPurchase.fromJSON(e))
        : [],
      status: isSet(object.status) ? shipmentStatusFromJSON(object.status) : 0,
      brandOrderId: isSet(object.brandOrderId) ? globalThis.String(object.brandOrderId) : undefined,
      trackingNumber: isSet(object.trackingNumber) ? globalThis.String(object.trackingNumber) : undefined,
      trackingUrl: isSet(object.trackingUrl) ? globalThis.String(object.trackingUrl) : undefined,
      expectedDeliveryDateStart: isSet(object.expectedDeliveryDateStart)
        ? globalThis.Number(object.expectedDeliveryDateStart)
        : undefined,
      expectedDeliveryDateEnd: isSet(object.expectedDeliveryDateEnd)
        ? globalThis.Number(object.expectedDeliveryDateEnd)
        : undefined,
      deliveredAt: isSet(object.deliveredAt) ? globalThis.Number(object.deliveredAt) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      possibleTrackingNumbers: globalThis.Array.isArray(object?.possibleTrackingNumbers)
        ? object.possibleTrackingNumbers.map((e: any) => globalThis.String(e))
        : [],
      totalPrice: isSet(object.totalPrice) ? globalThis.Number(object.totalPrice) : undefined,
      shippingCost: isSet(object.shippingCost) ? globalThis.Number(object.shippingCost) : undefined,
      stripePaymentId: isSet(object.stripePaymentId) ? globalThis.String(object.stripePaymentId) : undefined,
    };
  },

  toJSON(message: Shipment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    if (message.productPurchases?.length) {
      obj.productPurchases = message.productPurchases.map((e) => ProductPurchase.toJSON(e));
    }
    if (message.status !== 0) {
      obj.status = shipmentStatusToJSON(message.status);
    }
    if (message.brandOrderId !== undefined) {
      obj.brandOrderId = message.brandOrderId;
    }
    if (message.trackingNumber !== undefined) {
      obj.trackingNumber = message.trackingNumber;
    }
    if (message.trackingUrl !== undefined) {
      obj.trackingUrl = message.trackingUrl;
    }
    if (message.expectedDeliveryDateStart !== undefined) {
      obj.expectedDeliveryDateStart = Math.round(message.expectedDeliveryDateStart);
    }
    if (message.expectedDeliveryDateEnd !== undefined) {
      obj.expectedDeliveryDateEnd = Math.round(message.expectedDeliveryDateEnd);
    }
    if (message.deliveredAt !== undefined) {
      obj.deliveredAt = Math.round(message.deliveredAt);
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.possibleTrackingNumbers?.length) {
      obj.possibleTrackingNumbers = message.possibleTrackingNumbers;
    }
    if (message.totalPrice !== undefined) {
      obj.totalPrice = message.totalPrice;
    }
    if (message.shippingCost !== undefined) {
      obj.shippingCost = message.shippingCost;
    }
    if (message.stripePaymentId !== undefined) {
      obj.stripePaymentId = message.stripePaymentId;
    }
    return obj;
  },
};

function createBasePopulatedOrderSuggestion(): PopulatedOrderSuggestion {
  return {
    id: "",
    createdAt: 0,
    status: 0,
    productSuggestions: [],
    shipments: [],
    detailedStatus: 0,
    verifySuggestionsBy: undefined,
    verifyPurchasesBy: undefined,
    expireSuggestionsBy: undefined,
    stylistNote: undefined,
    aiJudgeAnalysis: undefined,
    internalData: undefined,
  };
}

export const PopulatedOrderSuggestion: MessageFns<PopulatedOrderSuggestion> = {
  encode(message: PopulatedOrderSuggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== 0) {
      writer.uint32(16).int64(message.createdAt);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    for (const v of message.productSuggestions) {
      ProductPurchaseSuggestion.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.shipments) {
      Shipment.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.detailedStatus !== 0) {
      writer.uint32(48).int32(message.detailedStatus);
    }
    if (message.verifySuggestionsBy !== undefined) {
      writer.uint32(56).int64(message.verifySuggestionsBy);
    }
    if (message.verifyPurchasesBy !== undefined) {
      writer.uint32(64).int64(message.verifyPurchasesBy);
    }
    if (message.expireSuggestionsBy !== undefined) {
      writer.uint32(72).int64(message.expireSuggestionsBy);
    }
    if (message.stylistNote !== undefined) {
      writer.uint32(82).string(message.stylistNote);
    }
    if (message.aiJudgeAnalysis !== undefined) {
      writer.uint32(90).string(message.aiJudgeAnalysis);
    }
    if (message.internalData !== undefined) {
      InternalOrderSuggestionData.encode(message.internalData, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopulatedOrderSuggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopulatedOrderSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.productSuggestions.push(ProductPurchaseSuggestion.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shipments.push(Shipment.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.detailedStatus = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.verifySuggestionsBy = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.verifyPurchasesBy = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.expireSuggestionsBy = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.stylistNote = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.aiJudgeAnalysis = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.internalData = InternalOrderSuggestionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopulatedOrderSuggestion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      status: isSet(object.status) ? orderSuggestionStatusFromJSON(object.status) : 0,
      productSuggestions: globalThis.Array.isArray(object?.productSuggestions)
        ? object.productSuggestions.map((e: any) => ProductPurchaseSuggestion.fromJSON(e))
        : [],
      shipments: globalThis.Array.isArray(object?.shipments)
        ? object.shipments.map((e: any) => Shipment.fromJSON(e))
        : [],
      detailedStatus: isSet(object.detailedStatus) ? orderSuggestionDetailedStatusFromJSON(object.detailedStatus) : 0,
      verifySuggestionsBy: isSet(object.verifySuggestionsBy)
        ? globalThis.Number(object.verifySuggestionsBy)
        : undefined,
      verifyPurchasesBy: isSet(object.verifyPurchasesBy) ? globalThis.Number(object.verifyPurchasesBy) : undefined,
      expireSuggestionsBy: isSet(object.expireSuggestionsBy)
        ? globalThis.Number(object.expireSuggestionsBy)
        : undefined,
      stylistNote: isSet(object.stylistNote) ? globalThis.String(object.stylistNote) : undefined,
      aiJudgeAnalysis: isSet(object.aiJudgeAnalysis) ? globalThis.String(object.aiJudgeAnalysis) : undefined,
      internalData: isSet(object.internalData) ? InternalOrderSuggestionData.fromJSON(object.internalData) : undefined,
    };
  },

  toJSON(message: PopulatedOrderSuggestion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.status !== 0) {
      obj.status = orderSuggestionStatusToJSON(message.status);
    }
    if (message.productSuggestions?.length) {
      obj.productSuggestions = message.productSuggestions.map((e) => ProductPurchaseSuggestion.toJSON(e));
    }
    if (message.shipments?.length) {
      obj.shipments = message.shipments.map((e) => Shipment.toJSON(e));
    }
    if (message.detailedStatus !== 0) {
      obj.detailedStatus = orderSuggestionDetailedStatusToJSON(message.detailedStatus);
    }
    if (message.verifySuggestionsBy !== undefined) {
      obj.verifySuggestionsBy = Math.round(message.verifySuggestionsBy);
    }
    if (message.verifyPurchasesBy !== undefined) {
      obj.verifyPurchasesBy = Math.round(message.verifyPurchasesBy);
    }
    if (message.expireSuggestionsBy !== undefined) {
      obj.expireSuggestionsBy = Math.round(message.expireSuggestionsBy);
    }
    if (message.stylistNote !== undefined) {
      obj.stylistNote = message.stylistNote;
    }
    if (message.aiJudgeAnalysis !== undefined) {
      obj.aiJudgeAnalysis = message.aiJudgeAnalysis;
    }
    if (message.internalData !== undefined) {
      obj.internalData = InternalOrderSuggestionData.toJSON(message.internalData);
    }
    return obj;
  },
};

function createBaseInternalProductPurchaseSuggestionData(): InternalProductPurchaseSuggestionData {
  return { threads: [] };
}

export const InternalProductPurchaseSuggestionData: MessageFns<InternalProductPurchaseSuggestionData> = {
  encode(message: InternalProductPurchaseSuggestionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.threads) {
      Thread.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InternalProductPurchaseSuggestionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalProductPurchaseSuggestionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.threads.push(Thread.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InternalProductPurchaseSuggestionData {
    return {
      threads: globalThis.Array.isArray(object?.threads) ? object.threads.map((e: any) => Thread.fromJSON(e)) : [],
    };
  },

  toJSON(message: InternalProductPurchaseSuggestionData): unknown {
    const obj: any = {};
    if (message.threads?.length) {
      obj.threads = message.threads.map((e) => Thread.toJSON(e));
    }
    return obj;
  },
};

function createBaseInternalOrderSuggestionData(): InternalOrderSuggestionData {
  return { threads: [] };
}

export const InternalOrderSuggestionData: MessageFns<InternalOrderSuggestionData> = {
  encode(message: InternalOrderSuggestionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.threads) {
      Thread.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InternalOrderSuggestionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalOrderSuggestionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.threads.push(Thread.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InternalOrderSuggestionData {
    return {
      threads: globalThis.Array.isArray(object?.threads) ? object.threads.map((e: any) => Thread.fromJSON(e)) : [],
    };
  },

  toJSON(message: InternalOrderSuggestionData): unknown {
    const obj: any = {};
    if (message.threads?.length) {
      obj.threads = message.threads.map((e) => Thread.toJSON(e));
    }
    return obj;
  },
};

function createBaseOrderSummary(): OrderSummary {
  return {
    id: "",
    customerId: "",
    stylistId: undefined,
    chatId: undefined,
    status: 0,
    createdAt: 0,
    updatedAt: 0,
    customer: undefined,
    stylist: undefined,
    userViewVersion: 0,
    dashboardMetadata: undefined,
    note: undefined,
    productRecommendations: [],
    orderSuggestions: [],
    type: undefined,
    generatedTitle: undefined,
  };
}

export const OrderSummary: MessageFns<OrderSummary> = {
  encode(message: OrderSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.stylistId !== undefined) {
      writer.uint32(26).string(message.stylistId);
    }
    if (message.chatId !== undefined) {
      writer.uint32(34).string(message.chatId);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.createdAt !== 0) {
      writer.uint32(48).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(56).int64(message.updatedAt);
    }
    if (message.customer !== undefined) {
      UserProfile.encode(message.customer, writer.uint32(66).fork()).join();
    }
    if (message.stylist !== undefined) {
      UserProfile.encode(message.stylist, writer.uint32(74).fork()).join();
    }
    if (message.userViewVersion !== 0) {
      writer.uint32(88).int32(message.userViewVersion);
    }
    if (message.dashboardMetadata !== undefined) {
      DashboardMetadata.encode(message.dashboardMetadata, writer.uint32(98).fork()).join();
    }
    if (message.note !== undefined) {
      writer.uint32(106).string(message.note);
    }
    for (const v of message.productRecommendations) {
      ProductRecommendation.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.orderSuggestions) {
      PopulatedOrderSuggestion.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.type !== undefined) {
      writer.uint32(128).int32(message.type);
    }
    if (message.generatedTitle !== undefined) {
      writer.uint32(138).string(message.generatedTitle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stylistId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.customer = UserProfile.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.stylist = UserProfile.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.userViewVersion = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.dashboardMetadata = DashboardMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.note = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.productRecommendations.push(ProductRecommendation.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.orderSuggestions.push(PopulatedOrderSuggestion.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.generatedTitle = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderSummary {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      stylistId: isSet(object.stylistId) ? globalThis.String(object.stylistId) : undefined,
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : undefined,
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
      customer: isSet(object.customer) ? UserProfile.fromJSON(object.customer) : undefined,
      stylist: isSet(object.stylist) ? UserProfile.fromJSON(object.stylist) : undefined,
      userViewVersion: isSet(object.userViewVersion) ? globalThis.Number(object.userViewVersion) : 0,
      dashboardMetadata: isSet(object.dashboardMetadata)
        ? DashboardMetadata.fromJSON(object.dashboardMetadata)
        : undefined,
      note: isSet(object.note) ? globalThis.String(object.note) : undefined,
      productRecommendations: globalThis.Array.isArray(object?.productRecommendations)
        ? object.productRecommendations.map((e: any) => ProductRecommendation.fromJSON(e))
        : [],
      orderSuggestions: globalThis.Array.isArray(object?.orderSuggestions)
        ? object.orderSuggestions.map((e: any) => PopulatedOrderSuggestion.fromJSON(e))
        : [],
      type: isSet(object.type) ? orderTypeFromJSON(object.type) : undefined,
      generatedTitle: isSet(object.generatedTitle) ? globalThis.String(object.generatedTitle) : undefined,
    };
  },

  toJSON(message: OrderSummary): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.stylistId !== undefined) {
      obj.stylistId = message.stylistId;
    }
    if (message.chatId !== undefined) {
      obj.chatId = message.chatId;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.customer !== undefined) {
      obj.customer = UserProfile.toJSON(message.customer);
    }
    if (message.stylist !== undefined) {
      obj.stylist = UserProfile.toJSON(message.stylist);
    }
    if (message.userViewVersion !== 0) {
      obj.userViewVersion = Math.round(message.userViewVersion);
    }
    if (message.dashboardMetadata !== undefined) {
      obj.dashboardMetadata = DashboardMetadata.toJSON(message.dashboardMetadata);
    }
    if (message.note !== undefined) {
      obj.note = message.note;
    }
    if (message.productRecommendations?.length) {
      obj.productRecommendations = message.productRecommendations.map((e) => ProductRecommendation.toJSON(e));
    }
    if (message.orderSuggestions?.length) {
      obj.orderSuggestions = message.orderSuggestions.map((e) => PopulatedOrderSuggestion.toJSON(e));
    }
    if (message.type !== undefined) {
      obj.type = orderTypeToJSON(message.type);
    }
    if (message.generatedTitle !== undefined) {
      obj.generatedTitle = message.generatedTitle;
    }
    return obj;
  },
};

function createBaseStylistSuggestionSummary(): StylistSuggestionSummary {
  return { mainSuggestion: undefined, secondarySuggestions: [] };
}

export const StylistSuggestionSummary: MessageFns<StylistSuggestionSummary> = {
  encode(message: StylistSuggestionSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mainSuggestion !== undefined) {
      MainStylistSuggestion.encode(message.mainSuggestion, writer.uint32(10).fork()).join();
    }
    for (const v of message.secondarySuggestions) {
      SecondaryStylistSuggestion.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StylistSuggestionSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStylistSuggestionSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mainSuggestion = MainStylistSuggestion.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secondarySuggestions.push(SecondaryStylistSuggestion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StylistSuggestionSummary {
    return {
      mainSuggestion: isSet(object.mainSuggestion) ? MainStylistSuggestion.fromJSON(object.mainSuggestion) : undefined,
      secondarySuggestions: globalThis.Array.isArray(object?.secondarySuggestions)
        ? object.secondarySuggestions.map((e: any) => SecondaryStylistSuggestion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StylistSuggestionSummary): unknown {
    const obj: any = {};
    if (message.mainSuggestion !== undefined) {
      obj.mainSuggestion = MainStylistSuggestion.toJSON(message.mainSuggestion);
    }
    if (message.secondarySuggestions?.length) {
      obj.secondarySuggestions = message.secondarySuggestions.map((e) => SecondaryStylistSuggestion.toJSON(e));
    }
    return obj;
  },
};

function createBaseExploreRequest(): ExploreRequest {
  return {
    id: "",
    userId: "",
    query: "",
    lowerBudget: undefined,
    upperBudget: undefined,
    brandIds: [],
    category: undefined,
    gender: 0,
    generatedTitle: undefined,
    devIsDevOnly: undefined,
    devIsDeleted: undefined,
    createdAt: "",
    messages: [],
    status: undefined,
    requestType: undefined,
    productId: undefined,
  };
}

export const ExploreRequest: MessageFns<ExploreRequest> = {
  encode(message: ExploreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    if (message.lowerBudget !== undefined) {
      writer.uint32(37).float(message.lowerBudget);
    }
    if (message.upperBudget !== undefined) {
      writer.uint32(45).float(message.upperBudget);
    }
    for (const v of message.brandIds) {
      writer.uint32(50).string(v!);
    }
    if (message.category !== undefined) {
      writer.uint32(56).int32(message.category);
    }
    if (message.gender !== 0) {
      writer.uint32(64).int32(message.gender);
    }
    if (message.generatedTitle !== undefined) {
      writer.uint32(74).string(message.generatedTitle);
    }
    if (message.devIsDevOnly !== undefined) {
      writer.uint32(80).bool(message.devIsDevOnly);
    }
    if (message.devIsDeleted !== undefined) {
      writer.uint32(88).bool(message.devIsDeleted);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    for (const v of message.messages) {
      PopulatedExploreMessage.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.status !== undefined) {
      writer.uint32(130).string(message.status);
    }
    if (message.requestType !== undefined) {
      writer.uint32(136).int32(message.requestType);
    }
    if (message.productId !== undefined) {
      writer.uint32(146).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExploreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExploreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.lowerBudget = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.upperBudget = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.brandIds.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.generatedTitle = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.devIsDevOnly = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.devIsDeleted = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.messages.push(PopulatedExploreMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.requestType = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExploreRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      lowerBudget: isSet(object.lowerBudget) ? globalThis.Number(object.lowerBudget) : undefined,
      upperBudget: isSet(object.upperBudget) ? globalThis.Number(object.upperBudget) : undefined,
      brandIds: globalThis.Array.isArray(object?.brandIds) ? object.brandIds.map((e: any) => globalThis.String(e)) : [],
      category: isSet(object.category) ? productCategoryFromJSON(object.category) : undefined,
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : 0,
      generatedTitle: isSet(object.generatedTitle) ? globalThis.String(object.generatedTitle) : undefined,
      devIsDevOnly: isSet(object.devIsDevOnly) ? globalThis.Boolean(object.devIsDevOnly) : undefined,
      devIsDeleted: isSet(object.devIsDeleted) ? globalThis.Boolean(object.devIsDeleted) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => PopulatedExploreMessage.fromJSON(e))
        : [],
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      requestType: isSet(object.requestType) ? exploreRequestTypeFromJSON(object.requestType) : undefined,
      productId: isSet(object.productId) ? globalThis.String(object.productId) : undefined,
    };
  },

  toJSON(message: ExploreRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.lowerBudget !== undefined) {
      obj.lowerBudget = message.lowerBudget;
    }
    if (message.upperBudget !== undefined) {
      obj.upperBudget = message.upperBudget;
    }
    if (message.brandIds?.length) {
      obj.brandIds = message.brandIds;
    }
    if (message.category !== undefined) {
      obj.category = productCategoryToJSON(message.category);
    }
    if (message.gender !== 0) {
      obj.gender = genderToJSON(message.gender);
    }
    if (message.generatedTitle !== undefined) {
      obj.generatedTitle = message.generatedTitle;
    }
    if (message.devIsDevOnly !== undefined) {
      obj.devIsDevOnly = message.devIsDevOnly;
    }
    if (message.devIsDeleted !== undefined) {
      obj.devIsDeleted = message.devIsDeleted;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => PopulatedExploreMessage.toJSON(e));
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.requestType !== undefined) {
      obj.requestType = exploreRequestTypeToJSON(message.requestType);
    }
    if (message.productId !== undefined) {
      obj.productId = message.productId;
    }
    return obj;
  },
};

function createBaseExploreRequestSummary(): ExploreRequestSummary {
  return { id: "", query: "", createdAt: "", generatedTitle: undefined };
}

export const ExploreRequestSummary: MessageFns<ExploreRequestSummary> = {
  encode(message: ExploreRequestSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.createdAt !== "") {
      writer.uint32(26).string(message.createdAt);
    }
    if (message.generatedTitle !== undefined) {
      writer.uint32(34).string(message.generatedTitle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExploreRequestSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExploreRequestSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.generatedTitle = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExploreRequestSummary {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      generatedTitle: isSet(object.generatedTitle) ? globalThis.String(object.generatedTitle) : undefined,
    };
  },

  toJSON(message: ExploreRequestSummary): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.generatedTitle !== undefined) {
      obj.generatedTitle = message.generatedTitle;
    }
    return obj;
  },
};

function createBaseDashboardMetadata(): DashboardMetadata {
  return { isStarred: false };
}

export const DashboardMetadata: MessageFns<DashboardMetadata> = {
  encode(message: DashboardMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isStarred !== false) {
      writer.uint32(8).bool(message.isStarred);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DashboardMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDashboardMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isStarred = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DashboardMetadata {
    return { isStarred: isSet(object.isStarred) ? globalThis.Boolean(object.isStarred) : false };
  },

  toJSON(message: DashboardMetadata): unknown {
    const obj: any = {};
    if (message.isStarred !== false) {
      obj.isStarred = message.isStarred;
    }
    return obj;
  },
};

function createBaseProductChoiceToolUsageRequest(): ProductChoiceToolUsageRequest {
  return { productIds: [] };
}

export const ProductChoiceToolUsageRequest: MessageFns<ProductChoiceToolUsageRequest> = {
  encode(message: ProductChoiceToolUsageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.productIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductChoiceToolUsageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductChoiceToolUsageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductChoiceToolUsageRequest {
    return {
      productIds: globalThis.Array.isArray(object?.productIds)
        ? object.productIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ProductChoiceToolUsageRequest): unknown {
    const obj: any = {};
    if (message.productIds?.length) {
      obj.productIds = message.productIds;
    }
    return obj;
  },
};

function createBaseProductChoiceToolUsageResponse(): ProductChoiceToolUsageResponse {
  return { chosenProductId: "" };
}

export const ProductChoiceToolUsageResponse: MessageFns<ProductChoiceToolUsageResponse> = {
  encode(message: ProductChoiceToolUsageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chosenProductId !== "") {
      writer.uint32(10).string(message.chosenProductId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductChoiceToolUsageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductChoiceToolUsageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chosenProductId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductChoiceToolUsageResponse {
    return { chosenProductId: isSet(object.chosenProductId) ? globalThis.String(object.chosenProductId) : "" };
  },

  toJSON(message: ProductChoiceToolUsageResponse): unknown {
    const obj: any = {};
    if (message.chosenProductId !== "") {
      obj.chosenProductId = message.chosenProductId;
    }
    return obj;
  },
};

function createBasePredefinedRequestMessage(): PredefinedRequestMessage {
  return { message: undefined, suggestedResponses: [] };
}

export const PredefinedRequestMessage: MessageFns<PredefinedRequestMessage> = {
  encode(message: PredefinedRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(10).fork()).join();
    }
    for (const v of message.suggestedResponses) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PredefinedRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePredefinedRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.suggestedResponses.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PredefinedRequestMessage {
    return {
      message: isSet(object.message) ? Message.fromJSON(object.message) : undefined,
      suggestedResponses: globalThis.Array.isArray(object?.suggestedResponses)
        ? object.suggestedResponses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PredefinedRequestMessage): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    if (message.suggestedResponses?.length) {
      obj.suggestedResponses = message.suggestedResponses;
    }
    return obj;
  },
};

function createBasePopulatedExploreRequestMessage(): PopulatedExploreRequestMessage {
  return { message: undefined };
}

export const PopulatedExploreRequestMessage: MessageFns<PopulatedExploreRequestMessage> = {
  encode(message: PopulatedExploreRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.message?.$case) {
      case "basicMessage":
        Message.encode(message.message.basicMessage, writer.uint32(10).fork()).join();
        break;
      case "productPreferencesRequestMessage":
        ProductPreferencesRequestPopulatedMessage.encode(
          message.message.productPreferencesRequestMessage,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "finishFindingProductRequestMessage":
        FinishFindingProductRequestPopulatedMessage.encode(
          message.message.finishFindingProductRequestMessage,
          writer.uint32(26).fork(),
        ).join();
        break;
      case "updateStatusMessage":
        UpdateStatusMessage.encode(message.message.updateStatusMessage, writer.uint32(34).fork()).join();
        break;
      case "gridProductsRequestMessage":
        GridProductsRequestPopulatedMessage.encode(message.message.gridProductsRequestMessage, writer.uint32(42).fork())
          .join();
        break;
      case "gridImagesRequestMessage":
        GridImagesRequestPopulatedMessage.encode(message.message.gridImagesRequestMessage, writer.uint32(50).fork())
          .join();
        break;
      case "placeOrderRequestMessage":
        PlaceOrderRequestPopulatedMessage.encode(message.message.placeOrderRequestMessage, writer.uint32(58).fork())
          .join();
        break;
      case "predefinedRequestMessage":
        PredefinedRequestMessage.encode(message.message.predefinedRequestMessage, writer.uint32(66).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopulatedExploreRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopulatedExploreRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = { $case: "basicMessage", basicMessage: Message.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = {
            $case: "productPreferencesRequestMessage",
            productPreferencesRequestMessage: ProductPreferencesRequestPopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = {
            $case: "finishFindingProductRequestMessage",
            finishFindingProductRequestMessage: FinishFindingProductRequestPopulatedMessage.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = {
            $case: "updateStatusMessage",
            updateStatusMessage: UpdateStatusMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = {
            $case: "gridProductsRequestMessage",
            gridProductsRequestMessage: GridProductsRequestPopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.message = {
            $case: "gridImagesRequestMessage",
            gridImagesRequestMessage: GridImagesRequestPopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.message = {
            $case: "placeOrderRequestMessage",
            placeOrderRequestMessage: PlaceOrderRequestPopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.message = {
            $case: "predefinedRequestMessage",
            predefinedRequestMessage: PredefinedRequestMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopulatedExploreRequestMessage {
    return {
      message: isSet(object.basicMessage)
        ? { $case: "basicMessage", basicMessage: Message.fromJSON(object.basicMessage) }
        : isSet(object.productPreferencesRequestMessage)
        ? {
          $case: "productPreferencesRequestMessage",
          productPreferencesRequestMessage: ProductPreferencesRequestPopulatedMessage.fromJSON(
            object.productPreferencesRequestMessage,
          ),
        }
        : isSet(object.finishFindingProductRequestMessage)
        ? {
          $case: "finishFindingProductRequestMessage",
          finishFindingProductRequestMessage: FinishFindingProductRequestPopulatedMessage.fromJSON(
            object.finishFindingProductRequestMessage,
          ),
        }
        : isSet(object.updateStatusMessage)
        ? {
          $case: "updateStatusMessage",
          updateStatusMessage: UpdateStatusMessage.fromJSON(object.updateStatusMessage),
        }
        : isSet(object.gridProductsRequestMessage)
        ? {
          $case: "gridProductsRequestMessage",
          gridProductsRequestMessage: GridProductsRequestPopulatedMessage.fromJSON(object.gridProductsRequestMessage),
        }
        : isSet(object.gridImagesRequestMessage)
        ? {
          $case: "gridImagesRequestMessage",
          gridImagesRequestMessage: GridImagesRequestPopulatedMessage.fromJSON(object.gridImagesRequestMessage),
        }
        : isSet(object.placeOrderRequestMessage)
        ? {
          $case: "placeOrderRequestMessage",
          placeOrderRequestMessage: PlaceOrderRequestPopulatedMessage.fromJSON(object.placeOrderRequestMessage),
        }
        : isSet(object.predefinedRequestMessage)
        ? {
          $case: "predefinedRequestMessage",
          predefinedRequestMessage: PredefinedRequestMessage.fromJSON(object.predefinedRequestMessage),
        }
        : undefined,
    };
  },

  toJSON(message: PopulatedExploreRequestMessage): unknown {
    const obj: any = {};
    if (message.message?.$case === "basicMessage") {
      obj.basicMessage = Message.toJSON(message.message.basicMessage);
    } else if (message.message?.$case === "productPreferencesRequestMessage") {
      obj.productPreferencesRequestMessage = ProductPreferencesRequestPopulatedMessage.toJSON(
        message.message.productPreferencesRequestMessage,
      );
    } else if (message.message?.$case === "finishFindingProductRequestMessage") {
      obj.finishFindingProductRequestMessage = FinishFindingProductRequestPopulatedMessage.toJSON(
        message.message.finishFindingProductRequestMessage,
      );
    } else if (message.message?.$case === "updateStatusMessage") {
      obj.updateStatusMessage = UpdateStatusMessage.toJSON(message.message.updateStatusMessage);
    } else if (message.message?.$case === "gridProductsRequestMessage") {
      obj.gridProductsRequestMessage = GridProductsRequestPopulatedMessage.toJSON(
        message.message.gridProductsRequestMessage,
      );
    } else if (message.message?.$case === "gridImagesRequestMessage") {
      obj.gridImagesRequestMessage = GridImagesRequestPopulatedMessage.toJSON(message.message.gridImagesRequestMessage);
    } else if (message.message?.$case === "placeOrderRequestMessage") {
      obj.placeOrderRequestMessage = PlaceOrderRequestPopulatedMessage.toJSON(message.message.placeOrderRequestMessage);
    } else if (message.message?.$case === "predefinedRequestMessage") {
      obj.predefinedRequestMessage = PredefinedRequestMessage.toJSON(message.message.predefinedRequestMessage);
    }
    return obj;
  },
};

function createBasePlaceOrderRequestPopulatedMessage(): PlaceOrderRequestPopulatedMessage {
  return { orderId: "", orderSummary: undefined };
}

export const PlaceOrderRequestPopulatedMessage: MessageFns<PlaceOrderRequestPopulatedMessage> = {
  encode(message: PlaceOrderRequestPopulatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.orderSummary !== undefined) {
      OrderSummary.encode(message.orderSummary, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceOrderRequestPopulatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceOrderRequestPopulatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderSummary = OrderSummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceOrderRequestPopulatedMessage {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      orderSummary: isSet(object.orderSummary) ? OrderSummary.fromJSON(object.orderSummary) : undefined,
    };
  },

  toJSON(message: PlaceOrderRequestPopulatedMessage): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.orderSummary !== undefined) {
      obj.orderSummary = OrderSummary.toJSON(message.orderSummary);
    }
    return obj;
  },
};

function createBaseGridImagesRequestPopulatedMessage(): GridImagesRequestPopulatedMessage {
  return { imageUrls: [], toolUseId: "" };
}

export const GridImagesRequestPopulatedMessage: MessageFns<GridImagesRequestPopulatedMessage> = {
  encode(message: GridImagesRequestPopulatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.imageUrls) {
      ImageWithWidthAndHeight.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.toolUseId !== "") {
      writer.uint32(18).string(message.toolUseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GridImagesRequestPopulatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGridImagesRequestPopulatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageUrls.push(ImageWithWidthAndHeight.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolUseId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GridImagesRequestPopulatedMessage {
    return {
      imageUrls: globalThis.Array.isArray(object?.imageUrls)
        ? object.imageUrls.map((e: any) => ImageWithWidthAndHeight.fromJSON(e))
        : [],
      toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
    };
  },

  toJSON(message: GridImagesRequestPopulatedMessage): unknown {
    const obj: any = {};
    if (message.imageUrls?.length) {
      obj.imageUrls = message.imageUrls.map((e) => ImageWithWidthAndHeight.toJSON(e));
    }
    if (message.toolUseId !== "") {
      obj.toolUseId = message.toolUseId;
    }
    return obj;
  },
};

function createBaseImageWithWidthAndHeight(): ImageWithWidthAndHeight {
  return { imageUrl: "", width: 0, height: 0 };
}

export const ImageWithWidthAndHeight: MessageFns<ImageWithWidthAndHeight> = {
  encode(message: ImageWithWidthAndHeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageWithWidthAndHeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageWithWidthAndHeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageWithWidthAndHeight {
    return {
      imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: ImageWithWidthAndHeight): unknown {
    const obj: any = {};
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },
};

function createBaseImagePreferenceItem(): ImagePreferenceItem {
  return { imageUrl: "", preferenceType: 0 };
}

export const ImagePreferenceItem: MessageFns<ImagePreferenceItem> = {
  encode(message: ImagePreferenceItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    if (message.preferenceType !== 0) {
      writer.uint32(16).int32(message.preferenceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImagePreferenceItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImagePreferenceItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.preferenceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImagePreferenceItem {
    return {
      imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "",
      preferenceType: isSet(object.preferenceType) ? preferenceTypeFromJSON(object.preferenceType) : 0,
    };
  },

  toJSON(message: ImagePreferenceItem): unknown {
    const obj: any = {};
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    if (message.preferenceType !== 0) {
      obj.preferenceType = preferenceTypeToJSON(message.preferenceType);
    }
    return obj;
  },
};

function createBaseImagePreferenceItemWithStyle(): ImagePreferenceItemWithStyle {
  return { imagePreferenceItem: undefined, style: "" };
}

export const ImagePreferenceItemWithStyle: MessageFns<ImagePreferenceItemWithStyle> = {
  encode(message: ImagePreferenceItemWithStyle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imagePreferenceItem !== undefined) {
      ImagePreferenceItem.encode(message.imagePreferenceItem, writer.uint32(10).fork()).join();
    }
    if (message.style !== "") {
      writer.uint32(18).string(message.style);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImagePreferenceItemWithStyle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImagePreferenceItemWithStyle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imagePreferenceItem = ImagePreferenceItem.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.style = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImagePreferenceItemWithStyle {
    return {
      imagePreferenceItem: isSet(object.imagePreferenceItem)
        ? ImagePreferenceItem.fromJSON(object.imagePreferenceItem)
        : undefined,
      style: isSet(object.style) ? globalThis.String(object.style) : "",
    };
  },

  toJSON(message: ImagePreferenceItemWithStyle): unknown {
    const obj: any = {};
    if (message.imagePreferenceItem !== undefined) {
      obj.imagePreferenceItem = ImagePreferenceItem.toJSON(message.imagePreferenceItem);
    }
    if (message.style !== "") {
      obj.style = message.style;
    }
    return obj;
  },
};

function createBasePopulatedImagePreferenceItem(): PopulatedImagePreferenceItem {
  return { imagePreferenceItem: undefined, embeddings: [], style: undefined };
}

export const PopulatedImagePreferenceItem: MessageFns<PopulatedImagePreferenceItem> = {
  encode(message: PopulatedImagePreferenceItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imagePreferenceItem !== undefined) {
      ImagePreferenceItem.encode(message.imagePreferenceItem, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.embeddings) {
      writer.float(v);
    }
    writer.join();
    if (message.style !== undefined) {
      writer.uint32(26).string(message.style);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopulatedImagePreferenceItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopulatedImagePreferenceItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imagePreferenceItem = ImagePreferenceItem.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.embeddings.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.embeddings.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.style = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopulatedImagePreferenceItem {
    return {
      imagePreferenceItem: isSet(object.imagePreferenceItem)
        ? ImagePreferenceItem.fromJSON(object.imagePreferenceItem)
        : undefined,
      embeddings: globalThis.Array.isArray(object?.embeddings)
        ? object.embeddings.map((e: any) => globalThis.Number(e))
        : [],
      style: isSet(object.style) ? globalThis.String(object.style) : undefined,
    };
  },

  toJSON(message: PopulatedImagePreferenceItem): unknown {
    const obj: any = {};
    if (message.imagePreferenceItem !== undefined) {
      obj.imagePreferenceItem = ImagePreferenceItem.toJSON(message.imagePreferenceItem);
    }
    if (message.embeddings?.length) {
      obj.embeddings = message.embeddings;
    }
    if (message.style !== undefined) {
      obj.style = message.style;
    }
    return obj;
  },
};

function createBaseGridImagesResponsePopulatedMessage(): GridImagesResponsePopulatedMessage {
  return { imagePreferenceItems: [], toolUseId: "" };
}

export const GridImagesResponsePopulatedMessage: MessageFns<GridImagesResponsePopulatedMessage> = {
  encode(message: GridImagesResponsePopulatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.imagePreferenceItems) {
      ImagePreferenceItemWithStyle.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.toolUseId !== "") {
      writer.uint32(18).string(message.toolUseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GridImagesResponsePopulatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGridImagesResponsePopulatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imagePreferenceItems.push(ImagePreferenceItemWithStyle.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolUseId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GridImagesResponsePopulatedMessage {
    return {
      imagePreferenceItems: globalThis.Array.isArray(object?.imagePreferenceItems)
        ? object.imagePreferenceItems.map((e: any) => ImagePreferenceItemWithStyle.fromJSON(e))
        : [],
      toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
    };
  },

  toJSON(message: GridImagesResponsePopulatedMessage): unknown {
    const obj: any = {};
    if (message.imagePreferenceItems?.length) {
      obj.imagePreferenceItems = message.imagePreferenceItems.map((e) => ImagePreferenceItemWithStyle.toJSON(e));
    }
    if (message.toolUseId !== "") {
      obj.toolUseId = message.toolUseId;
    }
    return obj;
  },
};

function createBaseGridProductsRequestPopulatedMessage(): GridProductsRequestPopulatedMessage {
  return { products: [], unrankedProducts: [], intermediateQueries: [], toolUseId: "" };
}

export const GridProductsRequestPopulatedMessage: MessageFns<GridProductsRequestPopulatedMessage> = {
  encode(message: GridProductsRequestPopulatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      ProductWithScoreAndSearchQuery.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.unrankedProducts) {
      ProductWithSearchQuery.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.intermediateQueries) {
      writer.uint32(26).string(v!);
    }
    if (message.toolUseId !== "") {
      writer.uint32(34).string(message.toolUseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GridProductsRequestPopulatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGridProductsRequestPopulatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(ProductWithScoreAndSearchQuery.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unrankedProducts.push(ProductWithSearchQuery.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.intermediateQueries.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toolUseId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GridProductsRequestPopulatedMessage {
    return {
      products: globalThis.Array.isArray(object?.products)
        ? object.products.map((e: any) => ProductWithScoreAndSearchQuery.fromJSON(e))
        : [],
      unrankedProducts: globalThis.Array.isArray(object?.unrankedProducts)
        ? object.unrankedProducts.map((e: any) => ProductWithSearchQuery.fromJSON(e))
        : [],
      intermediateQueries: globalThis.Array.isArray(object?.intermediateQueries)
        ? object.intermediateQueries.map((e: any) => globalThis.String(e))
        : [],
      toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
    };
  },

  toJSON(message: GridProductsRequestPopulatedMessage): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => ProductWithScoreAndSearchQuery.toJSON(e));
    }
    if (message.unrankedProducts?.length) {
      obj.unrankedProducts = message.unrankedProducts.map((e) => ProductWithSearchQuery.toJSON(e));
    }
    if (message.intermediateQueries?.length) {
      obj.intermediateQueries = message.intermediateQueries;
    }
    if (message.toolUseId !== "") {
      obj.toolUseId = message.toolUseId;
    }
    return obj;
  },
};

function createBasePopulatedOrderManagementMessage(): PopulatedOrderManagementMessage {
  return { message: undefined };
}

export const PopulatedOrderManagementMessage: MessageFns<PopulatedOrderManagementMessage> = {
  encode(message: PopulatedOrderManagementMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.message?.$case) {
      case "stylistSuggestionsRequestMessage":
        SendStylistSuggestionsRequest.encode(message.message.stylistSuggestionsRequestMessage, writer.uint32(18).fork())
          .join();
        break;
      case "stylistSuggestionsResponseMessage":
        SendStylistSuggestionsResponse.encode(
          message.message.stylistSuggestionsResponseMessage,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopulatedOrderManagementMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopulatedOrderManagementMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = {
            $case: "stylistSuggestionsRequestMessage",
            stylistSuggestionsRequestMessage: SendStylistSuggestionsRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = {
            $case: "stylistSuggestionsResponseMessage",
            stylistSuggestionsResponseMessage: SendStylistSuggestionsResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopulatedOrderManagementMessage {
    return {
      message: isSet(object.stylistSuggestionsRequestMessage)
        ? {
          $case: "stylistSuggestionsRequestMessage",
          stylistSuggestionsRequestMessage: SendStylistSuggestionsRequest.fromJSON(
            object.stylistSuggestionsRequestMessage,
          ),
        }
        : isSet(object.stylistSuggestionsResponseMessage)
        ? {
          $case: "stylistSuggestionsResponseMessage",
          stylistSuggestionsResponseMessage: SendStylistSuggestionsResponse.fromJSON(
            object.stylistSuggestionsResponseMessage,
          ),
        }
        : undefined,
    };
  },

  toJSON(message: PopulatedOrderManagementMessage): unknown {
    const obj: any = {};
    if (message.message?.$case === "stylistSuggestionsRequestMessage") {
      obj.stylistSuggestionsRequestMessage = SendStylistSuggestionsRequest.toJSON(
        message.message.stylistSuggestionsRequestMessage,
      );
    } else if (message.message?.$case === "stylistSuggestionsResponseMessage") {
      obj.stylistSuggestionsResponseMessage = SendStylistSuggestionsResponse.toJSON(
        message.message.stylistSuggestionsResponseMessage,
      );
    }
    return obj;
  },
};

function createBasePopulatedOrderManagementRequestMessage(): PopulatedOrderManagementRequestMessage {
  return { message: undefined };
}

export const PopulatedOrderManagementRequestMessage: MessageFns<PopulatedOrderManagementRequestMessage> = {
  encode(message: PopulatedOrderManagementRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.message?.$case) {
      case "stylistSuggestionsRequestMessage":
        SendStylistSuggestionsRequest.encode(message.message.stylistSuggestionsRequestMessage, writer.uint32(10).fork())
          .join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopulatedOrderManagementRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopulatedOrderManagementRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = {
            $case: "stylistSuggestionsRequestMessage",
            stylistSuggestionsRequestMessage: SendStylistSuggestionsRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopulatedOrderManagementRequestMessage {
    return {
      message: isSet(object.stylistSuggestionsRequestMessage)
        ? {
          $case: "stylistSuggestionsRequestMessage",
          stylistSuggestionsRequestMessage: SendStylistSuggestionsRequest.fromJSON(
            object.stylistSuggestionsRequestMessage,
          ),
        }
        : undefined,
    };
  },

  toJSON(message: PopulatedOrderManagementRequestMessage): unknown {
    const obj: any = {};
    if (message.message?.$case === "stylistSuggestionsRequestMessage") {
      obj.stylistSuggestionsRequestMessage = SendStylistSuggestionsRequest.toJSON(
        message.message.stylistSuggestionsRequestMessage,
      );
    }
    return obj;
  },
};

function createBaseGridProductsResponsePopulatedMessage(): GridProductsResponsePopulatedMessage {
  return { preferences: [], toolUseId: "" };
}

export const GridProductsResponsePopulatedMessage: MessageFns<GridProductsResponsePopulatedMessage> = {
  encode(message: GridProductsResponsePopulatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.preferences) {
      ProductPreferenceItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.toolUseId !== "") {
      writer.uint32(18).string(message.toolUseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GridProductsResponsePopulatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGridProductsResponsePopulatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preferences.push(ProductPreferenceItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolUseId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GridProductsResponsePopulatedMessage {
    return {
      preferences: globalThis.Array.isArray(object?.preferences)
        ? object.preferences.map((e: any) => ProductPreferenceItem.fromJSON(e))
        : [],
      toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
    };
  },

  toJSON(message: GridProductsResponsePopulatedMessage): unknown {
    const obj: any = {};
    if (message.preferences?.length) {
      obj.preferences = message.preferences.map((e) => ProductPreferenceItem.toJSON(e));
    }
    if (message.toolUseId !== "") {
      obj.toolUseId = message.toolUseId;
    }
    return obj;
  },
};

function createBasePopulatedOrderManagementResponseMessage(): PopulatedOrderManagementResponseMessage {
  return { message: undefined };
}

export const PopulatedOrderManagementResponseMessage: MessageFns<PopulatedOrderManagementResponseMessage> = {
  encode(message: PopulatedOrderManagementResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.message?.$case) {
      case "stylistSuggestionsResponseMessage":
        SendStylistSuggestionsResponse.encode(
          message.message.stylistSuggestionsResponseMessage,
          writer.uint32(10).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopulatedOrderManagementResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopulatedOrderManagementResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = {
            $case: "stylistSuggestionsResponseMessage",
            stylistSuggestionsResponseMessage: SendStylistSuggestionsResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopulatedOrderManagementResponseMessage {
    return {
      message: isSet(object.stylistSuggestionsResponseMessage)
        ? {
          $case: "stylistSuggestionsResponseMessage",
          stylistSuggestionsResponseMessage: SendStylistSuggestionsResponse.fromJSON(
            object.stylistSuggestionsResponseMessage,
          ),
        }
        : undefined,
    };
  },

  toJSON(message: PopulatedOrderManagementResponseMessage): unknown {
    const obj: any = {};
    if (message.message?.$case === "stylistSuggestionsResponseMessage") {
      obj.stylistSuggestionsResponseMessage = SendStylistSuggestionsResponse.toJSON(
        message.message.stylistSuggestionsResponseMessage,
      );
    }
    return obj;
  },
};

function createBasePopulatedExploreResponseMessage(): PopulatedExploreResponseMessage {
  return { message: undefined };
}

export const PopulatedExploreResponseMessage: MessageFns<PopulatedExploreResponseMessage> = {
  encode(message: PopulatedExploreResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.message?.$case) {
      case "basicMessage":
        Message.encode(message.message.basicMessage, writer.uint32(10).fork()).join();
        break;
      case "productPreferencesResponseMessage":
        ProductPreferencesResponsePopulatedMessage.encode(
          message.message.productPreferencesResponseMessage,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "gridProductsResponseMessage":
        GridProductsResponsePopulatedMessage.encode(
          message.message.gridProductsResponseMessage,
          writer.uint32(34).fork(),
        ).join();
        break;
      case "gridImagesResponseMessage":
        GridImagesResponsePopulatedMessage.encode(message.message.gridImagesResponseMessage, writer.uint32(42).fork())
          .join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopulatedExploreResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopulatedExploreResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = { $case: "basicMessage", basicMessage: Message.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = {
            $case: "productPreferencesResponseMessage",
            productPreferencesResponseMessage: ProductPreferencesResponsePopulatedMessage.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = {
            $case: "gridProductsResponseMessage",
            gridProductsResponseMessage: GridProductsResponsePopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = {
            $case: "gridImagesResponseMessage",
            gridImagesResponseMessage: GridImagesResponsePopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopulatedExploreResponseMessage {
    return {
      message: isSet(object.basicMessage)
        ? { $case: "basicMessage", basicMessage: Message.fromJSON(object.basicMessage) }
        : isSet(object.productPreferencesResponseMessage)
        ? {
          $case: "productPreferencesResponseMessage",
          productPreferencesResponseMessage: ProductPreferencesResponsePopulatedMessage.fromJSON(
            object.productPreferencesResponseMessage,
          ),
        }
        : isSet(object.gridProductsResponseMessage)
        ? {
          $case: "gridProductsResponseMessage",
          gridProductsResponseMessage: GridProductsResponsePopulatedMessage.fromJSON(
            object.gridProductsResponseMessage,
          ),
        }
        : isSet(object.gridImagesResponseMessage)
        ? {
          $case: "gridImagesResponseMessage",
          gridImagesResponseMessage: GridImagesResponsePopulatedMessage.fromJSON(object.gridImagesResponseMessage),
        }
        : undefined,
    };
  },

  toJSON(message: PopulatedExploreResponseMessage): unknown {
    const obj: any = {};
    if (message.message?.$case === "basicMessage") {
      obj.basicMessage = Message.toJSON(message.message.basicMessage);
    } else if (message.message?.$case === "productPreferencesResponseMessage") {
      obj.productPreferencesResponseMessage = ProductPreferencesResponsePopulatedMessage.toJSON(
        message.message.productPreferencesResponseMessage,
      );
    } else if (message.message?.$case === "gridProductsResponseMessage") {
      obj.gridProductsResponseMessage = GridProductsResponsePopulatedMessage.toJSON(
        message.message.gridProductsResponseMessage,
      );
    } else if (message.message?.$case === "gridImagesResponseMessage") {
      obj.gridImagesResponseMessage = GridImagesResponsePopulatedMessage.toJSON(
        message.message.gridImagesResponseMessage,
      );
    }
    return obj;
  },
};

function createBaseProductSuggestion(): ProductSuggestion {
  return { productName: "", isSelected: false };
}

export const ProductSuggestion: MessageFns<ProductSuggestion> = {
  encode(message: ProductSuggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productName !== "") {
      writer.uint32(10).string(message.productName);
    }
    if (message.isSelected !== false) {
      writer.uint32(16).bool(message.isSelected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductSuggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSelected = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductSuggestion {
    return {
      productName: isSet(object.productName) ? globalThis.String(object.productName) : "",
      isSelected: isSet(object.isSelected) ? globalThis.Boolean(object.isSelected) : false,
    };
  },

  toJSON(message: ProductSuggestion): unknown {
    const obj: any = {};
    if (message.productName !== "") {
      obj.productName = message.productName;
    }
    if (message.isSelected !== false) {
      obj.isSelected = message.isSelected;
    }
    return obj;
  },
};

function createBaseFinishFindingProductRequestPopulatedMessage(): FinishFindingProductRequestPopulatedMessage {
  return { userRequirements: [], productSuggestions: [], message: undefined };
}

export const FinishFindingProductRequestPopulatedMessage: MessageFns<FinishFindingProductRequestPopulatedMessage> = {
  encode(
    message: FinishFindingProductRequestPopulatedMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.userRequirements) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.productSuggestions) {
      ProductSuggestion.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.message !== undefined) {
      writer.uint32(34).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinishFindingProductRequestPopulatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishFindingProductRequestPopulatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userRequirements.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productSuggestions.push(ProductSuggestion.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinishFindingProductRequestPopulatedMessage {
    return {
      userRequirements: globalThis.Array.isArray(object?.userRequirements)
        ? object.userRequirements.map((e: any) => globalThis.String(e))
        : [],
      productSuggestions: globalThis.Array.isArray(object?.productSuggestions)
        ? object.productSuggestions.map((e: any) => ProductSuggestion.fromJSON(e))
        : [],
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: FinishFindingProductRequestPopulatedMessage): unknown {
    const obj: any = {};
    if (message.userRequirements?.length) {
      obj.userRequirements = message.userRequirements;
    }
    if (message.productSuggestions?.length) {
      obj.productSuggestions = message.productSuggestions.map((e) => ProductSuggestion.toJSON(e));
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseProductPreferencesRequestPopulatedMessage(): ProductPreferencesRequestPopulatedMessage {
  return { products: [], unrankedProducts: [], intermediateQueries: [], toolUseId: "" };
}

export const ProductPreferencesRequestPopulatedMessage: MessageFns<ProductPreferencesRequestPopulatedMessage> = {
  encode(message: ProductPreferencesRequestPopulatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      ProductWithScoreAndSearchQuery.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.unrankedProducts) {
      ProductWithSearchQuery.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.intermediateQueries) {
      writer.uint32(26).string(v!);
    }
    if (message.toolUseId !== "") {
      writer.uint32(34).string(message.toolUseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductPreferencesRequestPopulatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductPreferencesRequestPopulatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(ProductWithScoreAndSearchQuery.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unrankedProducts.push(ProductWithSearchQuery.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.intermediateQueries.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toolUseId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductPreferencesRequestPopulatedMessage {
    return {
      products: globalThis.Array.isArray(object?.products)
        ? object.products.map((e: any) => ProductWithScoreAndSearchQuery.fromJSON(e))
        : [],
      unrankedProducts: globalThis.Array.isArray(object?.unrankedProducts)
        ? object.unrankedProducts.map((e: any) => ProductWithSearchQuery.fromJSON(e))
        : [],
      intermediateQueries: globalThis.Array.isArray(object?.intermediateQueries)
        ? object.intermediateQueries.map((e: any) => globalThis.String(e))
        : [],
      toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
    };
  },

  toJSON(message: ProductPreferencesRequestPopulatedMessage): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => ProductWithScoreAndSearchQuery.toJSON(e));
    }
    if (message.unrankedProducts?.length) {
      obj.unrankedProducts = message.unrankedProducts.map((e) => ProductWithSearchQuery.toJSON(e));
    }
    if (message.intermediateQueries?.length) {
      obj.intermediateQueries = message.intermediateQueries;
    }
    if (message.toolUseId !== "") {
      obj.toolUseId = message.toolUseId;
    }
    return obj;
  },
};

function createBaseProductPreferencesResponsePopulatedMessage(): ProductPreferencesResponsePopulatedMessage {
  return { preferences: [], toolUseId: "" };
}

export const ProductPreferencesResponsePopulatedMessage: MessageFns<ProductPreferencesResponsePopulatedMessage> = {
  encode(message: ProductPreferencesResponsePopulatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.preferences) {
      ProductPreferenceItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.toolUseId !== "") {
      writer.uint32(18).string(message.toolUseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductPreferencesResponsePopulatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductPreferencesResponsePopulatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preferences.push(ProductPreferenceItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolUseId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductPreferencesResponsePopulatedMessage {
    return {
      preferences: globalThis.Array.isArray(object?.preferences)
        ? object.preferences.map((e: any) => ProductPreferenceItem.fromJSON(e))
        : [],
      toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
    };
  },

  toJSON(message: ProductPreferencesResponsePopulatedMessage): unknown {
    const obj: any = {};
    if (message.preferences?.length) {
      obj.preferences = message.preferences.map((e) => ProductPreferenceItem.toJSON(e));
    }
    if (message.toolUseId !== "") {
      obj.toolUseId = message.toolUseId;
    }
    return obj;
  },
};

function createBaseProductChoiceRequestPopulatedMessage(): ProductChoiceRequestPopulatedMessage {
  return { products: [] };
}

export const ProductChoiceRequestPopulatedMessage: MessageFns<ProductChoiceRequestPopulatedMessage> = {
  encode(message: ProductChoiceRequestPopulatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductChoiceRequestPopulatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductChoiceRequestPopulatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductChoiceRequestPopulatedMessage {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
    };
  },

  toJSON(message: ProductChoiceRequestPopulatedMessage): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    return obj;
  },
};

function createBaseProductChoiceResponsePopulatedMessage(): ProductChoiceResponsePopulatedMessage {
  return { chosenProduct: undefined };
}

export const ProductChoiceResponsePopulatedMessage: MessageFns<ProductChoiceResponsePopulatedMessage> = {
  encode(message: ProductChoiceResponsePopulatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chosenProduct !== undefined) {
      Product.encode(message.chosenProduct, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductChoiceResponsePopulatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductChoiceResponsePopulatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chosenProduct = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductChoiceResponsePopulatedMessage {
    return { chosenProduct: isSet(object.chosenProduct) ? Product.fromJSON(object.chosenProduct) : undefined };
  },

  toJSON(message: ProductChoiceResponsePopulatedMessage): unknown {
    const obj: any = {};
    if (message.chosenProduct !== undefined) {
      obj.chosenProduct = Product.toJSON(message.chosenProduct);
    }
    return obj;
  },
};

function createBasePopulatedExploreMessage(): PopulatedExploreMessage {
  return { message: undefined };
}

export const PopulatedExploreMessage: MessageFns<PopulatedExploreMessage> = {
  encode(message: PopulatedExploreMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.message?.$case) {
      case "basicMessage":
        Message.encode(message.message.basicMessage, writer.uint32(10).fork()).join();
        break;
      case "productPreferencesRequestMessage":
        ProductPreferencesRequestPopulatedMessage.encode(
          message.message.productPreferencesRequestMessage,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "productPreferencesResponseMessage":
        ProductPreferencesResponsePopulatedMessage.encode(
          message.message.productPreferencesResponseMessage,
          writer.uint32(26).fork(),
        ).join();
        break;
      case "finishFindingProductRequestMessage":
        FinishFindingProductRequestPopulatedMessage.encode(
          message.message.finishFindingProductRequestMessage,
          writer.uint32(34).fork(),
        ).join();
        break;
      case "updateStatusMessage":
        UpdateStatusMessage.encode(message.message.updateStatusMessage, writer.uint32(42).fork()).join();
        break;
      case "gridProductsRequestMessage":
        GridProductsRequestPopulatedMessage.encode(message.message.gridProductsRequestMessage, writer.uint32(50).fork())
          .join();
        break;
      case "gridProductsResponseMessage":
        GridProductsResponsePopulatedMessage.encode(
          message.message.gridProductsResponseMessage,
          writer.uint32(58).fork(),
        ).join();
        break;
      case "gridImagesRequestMessage":
        GridImagesRequestPopulatedMessage.encode(message.message.gridImagesRequestMessage, writer.uint32(66).fork())
          .join();
        break;
      case "gridImagesResponseMessage":
        GridImagesResponsePopulatedMessage.encode(message.message.gridImagesResponseMessage, writer.uint32(74).fork())
          .join();
        break;
      case "placeOrderRequestMessage":
        PlaceOrderRequestPopulatedMessage.encode(message.message.placeOrderRequestMessage, writer.uint32(82).fork())
          .join();
        break;
      case "predefinedRequestMessage":
        PredefinedRequestMessage.encode(message.message.predefinedRequestMessage, writer.uint32(90).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopulatedExploreMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopulatedExploreMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = { $case: "basicMessage", basicMessage: Message.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = {
            $case: "productPreferencesRequestMessage",
            productPreferencesRequestMessage: ProductPreferencesRequestPopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = {
            $case: "productPreferencesResponseMessage",
            productPreferencesResponseMessage: ProductPreferencesResponsePopulatedMessage.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = {
            $case: "finishFindingProductRequestMessage",
            finishFindingProductRequestMessage: FinishFindingProductRequestPopulatedMessage.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = {
            $case: "updateStatusMessage",
            updateStatusMessage: UpdateStatusMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.message = {
            $case: "gridProductsRequestMessage",
            gridProductsRequestMessage: GridProductsRequestPopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.message = {
            $case: "gridProductsResponseMessage",
            gridProductsResponseMessage: GridProductsResponsePopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.message = {
            $case: "gridImagesRequestMessage",
            gridImagesRequestMessage: GridImagesRequestPopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.message = {
            $case: "gridImagesResponseMessage",
            gridImagesResponseMessage: GridImagesResponsePopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.message = {
            $case: "placeOrderRequestMessage",
            placeOrderRequestMessage: PlaceOrderRequestPopulatedMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.message = {
            $case: "predefinedRequestMessage",
            predefinedRequestMessage: PredefinedRequestMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopulatedExploreMessage {
    return {
      message: isSet(object.basicMessage)
        ? { $case: "basicMessage", basicMessage: Message.fromJSON(object.basicMessage) }
        : isSet(object.productPreferencesRequestMessage)
        ? {
          $case: "productPreferencesRequestMessage",
          productPreferencesRequestMessage: ProductPreferencesRequestPopulatedMessage.fromJSON(
            object.productPreferencesRequestMessage,
          ),
        }
        : isSet(object.productPreferencesResponseMessage)
        ? {
          $case: "productPreferencesResponseMessage",
          productPreferencesResponseMessage: ProductPreferencesResponsePopulatedMessage.fromJSON(
            object.productPreferencesResponseMessage,
          ),
        }
        : isSet(object.finishFindingProductRequestMessage)
        ? {
          $case: "finishFindingProductRequestMessage",
          finishFindingProductRequestMessage: FinishFindingProductRequestPopulatedMessage.fromJSON(
            object.finishFindingProductRequestMessage,
          ),
        }
        : isSet(object.updateStatusMessage)
        ? {
          $case: "updateStatusMessage",
          updateStatusMessage: UpdateStatusMessage.fromJSON(object.updateStatusMessage),
        }
        : isSet(object.gridProductsRequestMessage)
        ? {
          $case: "gridProductsRequestMessage",
          gridProductsRequestMessage: GridProductsRequestPopulatedMessage.fromJSON(object.gridProductsRequestMessage),
        }
        : isSet(object.gridProductsResponseMessage)
        ? {
          $case: "gridProductsResponseMessage",
          gridProductsResponseMessage: GridProductsResponsePopulatedMessage.fromJSON(
            object.gridProductsResponseMessage,
          ),
        }
        : isSet(object.gridImagesRequestMessage)
        ? {
          $case: "gridImagesRequestMessage",
          gridImagesRequestMessage: GridImagesRequestPopulatedMessage.fromJSON(object.gridImagesRequestMessage),
        }
        : isSet(object.gridImagesResponseMessage)
        ? {
          $case: "gridImagesResponseMessage",
          gridImagesResponseMessage: GridImagesResponsePopulatedMessage.fromJSON(object.gridImagesResponseMessage),
        }
        : isSet(object.placeOrderRequestMessage)
        ? {
          $case: "placeOrderRequestMessage",
          placeOrderRequestMessage: PlaceOrderRequestPopulatedMessage.fromJSON(object.placeOrderRequestMessage),
        }
        : isSet(object.predefinedRequestMessage)
        ? {
          $case: "predefinedRequestMessage",
          predefinedRequestMessage: PredefinedRequestMessage.fromJSON(object.predefinedRequestMessage),
        }
        : undefined,
    };
  },

  toJSON(message: PopulatedExploreMessage): unknown {
    const obj: any = {};
    if (message.message?.$case === "basicMessage") {
      obj.basicMessage = Message.toJSON(message.message.basicMessage);
    } else if (message.message?.$case === "productPreferencesRequestMessage") {
      obj.productPreferencesRequestMessage = ProductPreferencesRequestPopulatedMessage.toJSON(
        message.message.productPreferencesRequestMessage,
      );
    } else if (message.message?.$case === "productPreferencesResponseMessage") {
      obj.productPreferencesResponseMessage = ProductPreferencesResponsePopulatedMessage.toJSON(
        message.message.productPreferencesResponseMessage,
      );
    } else if (message.message?.$case === "finishFindingProductRequestMessage") {
      obj.finishFindingProductRequestMessage = FinishFindingProductRequestPopulatedMessage.toJSON(
        message.message.finishFindingProductRequestMessage,
      );
    } else if (message.message?.$case === "updateStatusMessage") {
      obj.updateStatusMessage = UpdateStatusMessage.toJSON(message.message.updateStatusMessage);
    } else if (message.message?.$case === "gridProductsRequestMessage") {
      obj.gridProductsRequestMessage = GridProductsRequestPopulatedMessage.toJSON(
        message.message.gridProductsRequestMessage,
      );
    } else if (message.message?.$case === "gridProductsResponseMessage") {
      obj.gridProductsResponseMessage = GridProductsResponsePopulatedMessage.toJSON(
        message.message.gridProductsResponseMessage,
      );
    } else if (message.message?.$case === "gridImagesRequestMessage") {
      obj.gridImagesRequestMessage = GridImagesRequestPopulatedMessage.toJSON(message.message.gridImagesRequestMessage);
    } else if (message.message?.$case === "gridImagesResponseMessage") {
      obj.gridImagesResponseMessage = GridImagesResponsePopulatedMessage.toJSON(
        message.message.gridImagesResponseMessage,
      );
    } else if (message.message?.$case === "placeOrderRequestMessage") {
      obj.placeOrderRequestMessage = PlaceOrderRequestPopulatedMessage.toJSON(message.message.placeOrderRequestMessage);
    } else if (message.message?.$case === "predefinedRequestMessage") {
      obj.predefinedRequestMessage = PredefinedRequestMessage.toJSON(message.message.predefinedRequestMessage);
    }
    return obj;
  },
};

function createBaseUpdateStatusMessage(): UpdateStatusMessage {
  return { statusString: undefined };
}

export const UpdateStatusMessage: MessageFns<UpdateStatusMessage> = {
  encode(message: UpdateStatusMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statusString !== undefined) {
      writer.uint32(10).string(message.statusString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateStatusMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStatusMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statusString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateStatusMessage {
    return { statusString: isSet(object.statusString) ? globalThis.String(object.statusString) : undefined };
  },

  toJSON(message: UpdateStatusMessage): unknown {
    const obj: any = {};
    if (message.statusString !== undefined) {
      obj.statusString = message.statusString;
    }
    return obj;
  },
};

function createBaseSendStylistSuggestionsRequest(): SendStylistSuggestionsRequest {
  return { orderId: "", mainSuggestion: undefined, secondarySuggestions: [] };
}

export const SendStylistSuggestionsRequest: MessageFns<SendStylistSuggestionsRequest> = {
  encode(message: SendStylistSuggestionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.mainSuggestion !== undefined) {
      MainStylistSuggestion.encode(message.mainSuggestion, writer.uint32(18).fork()).join();
    }
    for (const v of message.secondarySuggestions) {
      SecondaryStylistSuggestion.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendStylistSuggestionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendStylistSuggestionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mainSuggestion = MainStylistSuggestion.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.secondarySuggestions.push(SecondaryStylistSuggestion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendStylistSuggestionsRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      mainSuggestion: isSet(object.mainSuggestion) ? MainStylistSuggestion.fromJSON(object.mainSuggestion) : undefined,
      secondarySuggestions: globalThis.Array.isArray(object?.secondarySuggestions)
        ? object.secondarySuggestions.map((e: any) => SecondaryStylistSuggestion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SendStylistSuggestionsRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.mainSuggestion !== undefined) {
      obj.mainSuggestion = MainStylistSuggestion.toJSON(message.mainSuggestion);
    }
    if (message.secondarySuggestions?.length) {
      obj.secondarySuggestions = message.secondarySuggestions.map((e) => SecondaryStylistSuggestion.toJSON(e));
    }
    return obj;
  },
};

function createBaseMainStylistSuggestion(): MainStylistSuggestion {
  return {
    productId: "",
    recommendedSize: "",
    suggestionReasoning: undefined,
    currentPrice: 0,
    originalPrice: undefined,
    product: undefined,
    productCopy: "",
    userRequirements: [],
  };
}

export const MainStylistSuggestion: MessageFns<MainStylistSuggestion> = {
  encode(message: MainStylistSuggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.recommendedSize !== "") {
      writer.uint32(18).string(message.recommendedSize);
    }
    if (message.suggestionReasoning !== undefined) {
      SuggestionReasoning.encode(message.suggestionReasoning, writer.uint32(26).fork()).join();
    }
    if (message.currentPrice !== 0) {
      writer.uint32(37).float(message.currentPrice);
    }
    if (message.originalPrice !== undefined) {
      writer.uint32(45).float(message.originalPrice);
    }
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(50).fork()).join();
    }
    if (message.productCopy !== "") {
      writer.uint32(58).string(message.productCopy);
    }
    for (const v of message.userRequirements) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MainStylistSuggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMainStylistSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recommendedSize = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.suggestionReasoning = SuggestionReasoning.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.currentPrice = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.productCopy = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userRequirements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MainStylistSuggestion {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      recommendedSize: isSet(object.recommendedSize) ? globalThis.String(object.recommendedSize) : "",
      suggestionReasoning: isSet(object.suggestionReasoning)
        ? SuggestionReasoning.fromJSON(object.suggestionReasoning)
        : undefined,
      currentPrice: isSet(object.currentPrice) ? globalThis.Number(object.currentPrice) : 0,
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : undefined,
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      productCopy: isSet(object.productCopy) ? globalThis.String(object.productCopy) : "",
      userRequirements: globalThis.Array.isArray(object?.userRequirements)
        ? object.userRequirements.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MainStylistSuggestion): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.recommendedSize !== "") {
      obj.recommendedSize = message.recommendedSize;
    }
    if (message.suggestionReasoning !== undefined) {
      obj.suggestionReasoning = SuggestionReasoning.toJSON(message.suggestionReasoning);
    }
    if (message.currentPrice !== 0) {
      obj.currentPrice = message.currentPrice;
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = message.originalPrice;
    }
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.productCopy !== "") {
      obj.productCopy = message.productCopy;
    }
    if (message.userRequirements?.length) {
      obj.userRequirements = message.userRequirements;
    }
    return obj;
  },
};

function createBaseSecondaryStylistSuggestion(): SecondaryStylistSuggestion {
  return { productId: "", currentPrice: 0, originalPrice: undefined, product: undefined, userRequirements: [] };
}

export const SecondaryStylistSuggestion: MessageFns<SecondaryStylistSuggestion> = {
  encode(message: SecondaryStylistSuggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.currentPrice !== 0) {
      writer.uint32(21).float(message.currentPrice);
    }
    if (message.originalPrice !== undefined) {
      writer.uint32(29).float(message.originalPrice);
    }
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(34).fork()).join();
    }
    for (const v of message.userRequirements) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecondaryStylistSuggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecondaryStylistSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.currentPrice = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userRequirements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecondaryStylistSuggestion {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      currentPrice: isSet(object.currentPrice) ? globalThis.Number(object.currentPrice) : 0,
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : undefined,
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      userRequirements: globalThis.Array.isArray(object?.userRequirements)
        ? object.userRequirements.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SecondaryStylistSuggestion): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.currentPrice !== 0) {
      obj.currentPrice = message.currentPrice;
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = message.originalPrice;
    }
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.userRequirements?.length) {
      obj.userRequirements = message.userRequirements;
    }
    return obj;
  },
};

function createBaseSendStylistSuggestionsResponse(): SendStylistSuggestionsResponse {
  return { orderId: "", modificationRequest: undefined, acceptedProduct: undefined };
}

export const SendStylistSuggestionsResponse: MessageFns<SendStylistSuggestionsResponse> = {
  encode(message: SendStylistSuggestionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.modificationRequest !== undefined) {
      writer.uint32(18).string(message.modificationRequest);
    }
    if (message.acceptedProduct !== undefined) {
      AcceptedProduct.encode(message.acceptedProduct, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendStylistSuggestionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendStylistSuggestionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modificationRequest = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.acceptedProduct = AcceptedProduct.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendStylistSuggestionsResponse {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      modificationRequest: isSet(object.modificationRequest)
        ? globalThis.String(object.modificationRequest)
        : undefined,
      acceptedProduct: isSet(object.acceptedProduct) ? AcceptedProduct.fromJSON(object.acceptedProduct) : undefined,
    };
  },

  toJSON(message: SendStylistSuggestionsResponse): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.modificationRequest !== undefined) {
      obj.modificationRequest = message.modificationRequest;
    }
    if (message.acceptedProduct !== undefined) {
      obj.acceptedProduct = AcceptedProduct.toJSON(message.acceptedProduct);
    }
    return obj;
  },
};

function createBaseAcceptedProduct(): AcceptedProduct {
  return { productId: "", size: "" };
}

export const AcceptedProduct: MessageFns<AcceptedProduct> = {
  encode(message: AcceptedProduct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.size !== "") {
      writer.uint32(18).string(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceptedProduct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceptedProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.size = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceptedProduct {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      size: isSet(object.size) ? globalThis.String(object.size) : "",
    };
  },

  toJSON(message: AcceptedProduct): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.size !== "") {
      obj.size = message.size;
    }
    return obj;
  },
};

function createBaseSuggestionReasoning(): SuggestionReasoning {
  return { productReasoning: "", brandReasoning: "", sizeReasoning: "" };
}

export const SuggestionReasoning: MessageFns<SuggestionReasoning> = {
  encode(message: SuggestionReasoning, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productReasoning !== "") {
      writer.uint32(10).string(message.productReasoning);
    }
    if (message.brandReasoning !== "") {
      writer.uint32(18).string(message.brandReasoning);
    }
    if (message.sizeReasoning !== "") {
      writer.uint32(26).string(message.sizeReasoning);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestionReasoning {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestionReasoning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productReasoning = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.brandReasoning = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sizeReasoning = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestionReasoning {
    return {
      productReasoning: isSet(object.productReasoning) ? globalThis.String(object.productReasoning) : "",
      brandReasoning: isSet(object.brandReasoning) ? globalThis.String(object.brandReasoning) : "",
      sizeReasoning: isSet(object.sizeReasoning) ? globalThis.String(object.sizeReasoning) : "",
    };
  },

  toJSON(message: SuggestionReasoning): unknown {
    const obj: any = {};
    if (message.productReasoning !== "") {
      obj.productReasoning = message.productReasoning;
    }
    if (message.brandReasoning !== "") {
      obj.brandReasoning = message.brandReasoning;
    }
    if (message.sizeReasoning !== "") {
      obj.sizeReasoning = message.sizeReasoning;
    }
    return obj;
  },
};

function createBaseSearchQuery(): SearchQuery {
  return {
    query: "",
    topK: undefined,
    gender: undefined,
    brandIds: [],
    minPrice: undefined,
    maxPrice: undefined,
    productIdWhitelist: [],
    productIdBlacklist: [],
    category: undefined,
    searchMethod: undefined,
    embeddingVersion: undefined,
  };
}

export const SearchQuery: MessageFns<SearchQuery> = {
  encode(message: SearchQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.topK !== undefined) {
      writer.uint32(16).int32(message.topK);
    }
    if (message.gender !== undefined) {
      writer.uint32(24).int32(message.gender);
    }
    for (const v of message.brandIds) {
      writer.uint32(34).string(v!);
    }
    if (message.minPrice !== undefined) {
      writer.uint32(45).float(message.minPrice);
    }
    if (message.maxPrice !== undefined) {
      writer.uint32(53).float(message.maxPrice);
    }
    for (const v of message.productIdWhitelist) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.productIdBlacklist) {
      writer.uint32(66).string(v!);
    }
    if (message.category !== undefined) {
      writer.uint32(72).int32(message.category);
    }
    if (message.searchMethod !== undefined) {
      writer.uint32(80).int32(message.searchMethod);
    }
    if (message.embeddingVersion !== undefined) {
      writer.uint32(88).int32(message.embeddingVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topK = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.brandIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.minPrice = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.maxPrice = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.productIdWhitelist.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.productIdBlacklist.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.searchMethod = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.embeddingVersion = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchQuery {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      topK: isSet(object.topK) ? globalThis.Number(object.topK) : undefined,
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : undefined,
      brandIds: globalThis.Array.isArray(object?.brandIds) ? object.brandIds.map((e: any) => globalThis.String(e)) : [],
      minPrice: isSet(object.minPrice) ? globalThis.Number(object.minPrice) : undefined,
      maxPrice: isSet(object.maxPrice) ? globalThis.Number(object.maxPrice) : undefined,
      productIdWhitelist: globalThis.Array.isArray(object?.productIdWhitelist)
        ? object.productIdWhitelist.map((e: any) => globalThis.String(e))
        : [],
      productIdBlacklist: globalThis.Array.isArray(object?.productIdBlacklist)
        ? object.productIdBlacklist.map((e: any) => globalThis.String(e))
        : [],
      category: isSet(object.category) ? productCategoryFromJSON(object.category) : undefined,
      searchMethod: isSet(object.searchMethod) ? searchMethodFromJSON(object.searchMethod) : undefined,
      embeddingVersion: isSet(object.embeddingVersion) ? globalThis.Number(object.embeddingVersion) : undefined,
    };
  },

  toJSON(message: SearchQuery): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.topK !== undefined) {
      obj.topK = Math.round(message.topK);
    }
    if (message.gender !== undefined) {
      obj.gender = genderToJSON(message.gender);
    }
    if (message.brandIds?.length) {
      obj.brandIds = message.brandIds;
    }
    if (message.minPrice !== undefined) {
      obj.minPrice = message.minPrice;
    }
    if (message.maxPrice !== undefined) {
      obj.maxPrice = message.maxPrice;
    }
    if (message.productIdWhitelist?.length) {
      obj.productIdWhitelist = message.productIdWhitelist;
    }
    if (message.productIdBlacklist?.length) {
      obj.productIdBlacklist = message.productIdBlacklist;
    }
    if (message.category !== undefined) {
      obj.category = productCategoryToJSON(message.category);
    }
    if (message.searchMethod !== undefined) {
      obj.searchMethod = searchMethodToJSON(message.searchMethod);
    }
    if (message.embeddingVersion !== undefined) {
      obj.embeddingVersion = Math.round(message.embeddingVersion);
    }
    return obj;
  },
};

function createBaseBrand(): Brand {
  return { id: "", company: "", url: "", gender: undefined, gptSummary: undefined };
}

export const Brand: MessageFns<Brand> = {
  encode(message: Brand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.company !== "") {
      writer.uint32(18).string(message.company);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.gender !== undefined) {
      writer.uint32(32).int32(message.gender);
    }
    if (message.gptSummary !== undefined) {
      writer.uint32(42).string(message.gptSummary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Brand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.company = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gptSummary = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Brand {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      company: isSet(object.company) ? globalThis.String(object.company) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : undefined,
      gptSummary: isSet(object.gptSummary) ? globalThis.String(object.gptSummary) : undefined,
    };
  },

  toJSON(message: Brand): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.company !== "") {
      obj.company = message.company;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.gender !== undefined) {
      obj.gender = genderToJSON(message.gender);
    }
    if (message.gptSummary !== undefined) {
      obj.gptSummary = message.gptSummary;
    }
    return obj;
  },
};

function createBaseGetBrandsRequest(): GetBrandsRequest {
  return {};
}

export const GetBrandsRequest: MessageFns<GetBrandsRequest> = {
  encode(_: GetBrandsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBrandsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBrandsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetBrandsRequest {
    return {};
  },

  toJSON(_: GetBrandsRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetBrandsResponse(): GetBrandsResponse {
  return { brands: [] };
}

export const GetBrandsResponse: MessageFns<GetBrandsResponse> = {
  encode(message: GetBrandsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.brands) {
      Brand.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBrandsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBrandsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brands.push(Brand.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBrandsResponse {
    return { brands: globalThis.Array.isArray(object?.brands) ? object.brands.map((e: any) => Brand.fromJSON(e)) : [] };
  },

  toJSON(message: GetBrandsResponse): unknown {
    const obj: any = {};
    if (message.brands?.length) {
      obj.brands = message.brands.map((e) => Brand.toJSON(e));
    }
    return obj;
  },
};

function createBaseCreateBrandRequest(): CreateBrandRequest {
  return { brand: undefined };
}

export const CreateBrandRequest: MessageFns<CreateBrandRequest> = {
  encode(message: CreateBrandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBrandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBrandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBrandRequest {
    return { brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined };
  },

  toJSON(message: CreateBrandRequest): unknown {
    const obj: any = {};
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },
};

function createBaseCreateBrandResponse(): CreateBrandResponse {
  return { brand: undefined };
}

export const CreateBrandResponse: MessageFns<CreateBrandResponse> = {
  encode(message: CreateBrandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBrandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBrandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBrandResponse {
    return { brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined };
  },

  toJSON(message: CreateBrandResponse): unknown {
    const obj: any = {};
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },
};

function createBaseSearchRequest(): SearchRequest {
  return { query: undefined, targetUserId: undefined, targetExploreRequestId: undefined };
}

export const SearchRequest: MessageFns<SearchRequest> = {
  encode(message: SearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== undefined) {
      SearchQuery.encode(message.query, writer.uint32(10).fork()).join();
    }
    if (message.targetUserId !== undefined) {
      writer.uint32(18).string(message.targetUserId);
    }
    if (message.targetExploreRequestId !== undefined) {
      writer.uint32(26).string(message.targetExploreRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = SearchQuery.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetUserId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetExploreRequestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      query: isSet(object.query) ? SearchQuery.fromJSON(object.query) : undefined,
      targetUserId: isSet(object.targetUserId) ? globalThis.String(object.targetUserId) : undefined,
      targetExploreRequestId: isSet(object.targetExploreRequestId)
        ? globalThis.String(object.targetExploreRequestId)
        : undefined,
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.query !== undefined) {
      obj.query = SearchQuery.toJSON(message.query);
    }
    if (message.targetUserId !== undefined) {
      obj.targetUserId = message.targetUserId;
    }
    if (message.targetExploreRequestId !== undefined) {
      obj.targetExploreRequestId = message.targetExploreRequestId;
    }
    return obj;
  },
};

function createBaseSearchResponse(): SearchResponse {
  return { results: [] };
}

export const SearchResponse: MessageFns<SearchResponse> = {
  encode(message: SearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      ProductWithScore.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(ProductWithScore.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ProductWithScore.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => ProductWithScore.toJSON(e));
    }
    return obj;
  },
};

function createBaseSimilarProductsRequest(): SimilarProductsRequest {
  return {
    productId: "",
    topK: undefined,
    gender: undefined,
    brandIds: [],
    minPrice: undefined,
    maxPrice: undefined,
    category: undefined,
    searchMethod: undefined,
    exploreRequestId: undefined,
    productIdBlacklist: [],
  };
}

export const SimilarProductsRequest: MessageFns<SimilarProductsRequest> = {
  encode(message: SimilarProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.topK !== undefined) {
      writer.uint32(16).int32(message.topK);
    }
    if (message.gender !== undefined) {
      writer.uint32(24).int32(message.gender);
    }
    for (const v of message.brandIds) {
      writer.uint32(34).string(v!);
    }
    if (message.minPrice !== undefined) {
      writer.uint32(45).float(message.minPrice);
    }
    if (message.maxPrice !== undefined) {
      writer.uint32(53).float(message.maxPrice);
    }
    if (message.category !== undefined) {
      writer.uint32(56).int32(message.category);
    }
    if (message.searchMethod !== undefined) {
      writer.uint32(64).int32(message.searchMethod);
    }
    if (message.exploreRequestId !== undefined) {
      writer.uint32(74).string(message.exploreRequestId);
    }
    for (const v of message.productIdBlacklist) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimilarProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimilarProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topK = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.brandIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.minPrice = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.maxPrice = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.searchMethod = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.exploreRequestId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.productIdBlacklist.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimilarProductsRequest {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      topK: isSet(object.topK) ? globalThis.Number(object.topK) : undefined,
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : undefined,
      brandIds: globalThis.Array.isArray(object?.brandIds) ? object.brandIds.map((e: any) => globalThis.String(e)) : [],
      minPrice: isSet(object.minPrice) ? globalThis.Number(object.minPrice) : undefined,
      maxPrice: isSet(object.maxPrice) ? globalThis.Number(object.maxPrice) : undefined,
      category: isSet(object.category) ? productCategoryFromJSON(object.category) : undefined,
      searchMethod: isSet(object.searchMethod) ? searchMethodFromJSON(object.searchMethod) : undefined,
      exploreRequestId: isSet(object.exploreRequestId) ? globalThis.String(object.exploreRequestId) : undefined,
      productIdBlacklist: globalThis.Array.isArray(object?.productIdBlacklist)
        ? object.productIdBlacklist.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SimilarProductsRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.topK !== undefined) {
      obj.topK = Math.round(message.topK);
    }
    if (message.gender !== undefined) {
      obj.gender = genderToJSON(message.gender);
    }
    if (message.brandIds?.length) {
      obj.brandIds = message.brandIds;
    }
    if (message.minPrice !== undefined) {
      obj.minPrice = message.minPrice;
    }
    if (message.maxPrice !== undefined) {
      obj.maxPrice = message.maxPrice;
    }
    if (message.category !== undefined) {
      obj.category = productCategoryToJSON(message.category);
    }
    if (message.searchMethod !== undefined) {
      obj.searchMethod = searchMethodToJSON(message.searchMethod);
    }
    if (message.exploreRequestId !== undefined) {
      obj.exploreRequestId = message.exploreRequestId;
    }
    if (message.productIdBlacklist?.length) {
      obj.productIdBlacklist = message.productIdBlacklist;
    }
    return obj;
  },
};

function createBaseSimilarProductsResponse(): SimilarProductsResponse {
  return { results: [] };
}

export const SimilarProductsResponse: MessageFns<SimilarProductsResponse> = {
  encode(message: SimilarProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      ProductWithScore.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimilarProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimilarProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(ProductWithScore.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimilarProductsResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ProductWithScore.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SimilarProductsResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => ProductWithScore.toJSON(e));
    }
    return obj;
  },
};

function createBaseStylePickerProduct(): StylePickerProduct {
  return { id: "", modelImage: "", stickerImage: "", category: 0, gender: 0 };
}

export const StylePickerProduct: MessageFns<StylePickerProduct> = {
  encode(message: StylePickerProduct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.modelImage !== "") {
      writer.uint32(18).string(message.modelImage);
    }
    if (message.stickerImage !== "") {
      writer.uint32(26).string(message.stickerImage);
    }
    if (message.category !== 0) {
      writer.uint32(32).int32(message.category);
    }
    if (message.gender !== 0) {
      writer.uint32(40).int32(message.gender);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StylePickerProduct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStylePickerProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelImage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stickerImage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StylePickerProduct {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      modelImage: isSet(object.modelImage) ? globalThis.String(object.modelImage) : "",
      stickerImage: isSet(object.stickerImage) ? globalThis.String(object.stickerImage) : "",
      category: isSet(object.category) ? productCategoryFromJSON(object.category) : 0,
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : 0,
    };
  },

  toJSON(message: StylePickerProduct): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.modelImage !== "") {
      obj.modelImage = message.modelImage;
    }
    if (message.stickerImage !== "") {
      obj.stickerImage = message.stickerImage;
    }
    if (message.category !== 0) {
      obj.category = productCategoryToJSON(message.category);
    }
    if (message.gender !== 0) {
      obj.gender = genderToJSON(message.gender);
    }
    return obj;
  },
};

function createBaseListStylePickerProductsRequest(): ListStylePickerProductsRequest {
  return { limit: 0, offset: 0, category: undefined, gender: undefined };
}

export const ListStylePickerProductsRequest: MessageFns<ListStylePickerProductsRequest> = {
  encode(message: ListStylePickerProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int32(message.offset);
    }
    if (message.category !== undefined) {
      writer.uint32(24).int32(message.category);
    }
    if (message.gender !== undefined) {
      writer.uint32(32).int32(message.gender);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStylePickerProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStylePickerProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStylePickerProductsRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      category: isSet(object.category) ? productCategoryFromJSON(object.category) : undefined,
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : undefined,
    };
  },

  toJSON(message: ListStylePickerProductsRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.category !== undefined) {
      obj.category = productCategoryToJSON(message.category);
    }
    if (message.gender !== undefined) {
      obj.gender = genderToJSON(message.gender);
    }
    return obj;
  },
};

function createBaseListStylePickerProductsResponse(): ListStylePickerProductsResponse {
  return { products: [], totalCount: 0 };
}

export const ListStylePickerProductsResponse: MessageFns<ListStylePickerProductsResponse> = {
  encode(message: ListStylePickerProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      StylePickerProduct.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStylePickerProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStylePickerProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(StylePickerProduct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStylePickerProductsResponse {
    return {
      products: globalThis.Array.isArray(object?.products)
        ? object.products.map((e: any) => StylePickerProduct.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListStylePickerProductsResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => StylePickerProduct.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },
};

function createBaseUpdateProductRequest(): UpdateProductRequest {
  return { productId: "", url: undefined, price: undefined, originalPrice: undefined, sizes: [] };
}

export const UpdateProductRequest: MessageFns<UpdateProductRequest> = {
  encode(message: UpdateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.url !== undefined) {
      writer.uint32(18).string(message.url);
    }
    if (message.price !== undefined) {
      writer.uint32(37).float(message.price);
    }
    if (message.originalPrice !== undefined) {
      writer.uint32(45).float(message.originalPrice);
    }
    for (const v of message.sizes) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sizes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductRequest {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
      price: isSet(object.price) ? globalThis.Number(object.price) : undefined,
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : undefined,
      sizes: globalThis.Array.isArray(object?.sizes) ? object.sizes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UpdateProductRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    if (message.price !== undefined) {
      obj.price = message.price;
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = message.originalPrice;
    }
    if (message.sizes?.length) {
      obj.sizes = message.sizes;
    }
    return obj;
  },
};

function createBaseUpdateProductResponse(): UpdateProductResponse {
  return { product: undefined };
}

export const UpdateProductResponse: MessageFns<UpdateProductResponse> = {
  encode(message: UpdateProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: UpdateProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },
};

function createBaseSearchForProductsByUrlRegexRequest(): SearchForProductsByUrlRegexRequest {
  return { urlRegex: "" };
}

export const SearchForProductsByUrlRegexRequest: MessageFns<SearchForProductsByUrlRegexRequest> = {
  encode(message: SearchForProductsByUrlRegexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.urlRegex !== "") {
      writer.uint32(10).string(message.urlRegex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchForProductsByUrlRegexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchForProductsByUrlRegexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urlRegex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchForProductsByUrlRegexRequest {
    return { urlRegex: isSet(object.urlRegex) ? globalThis.String(object.urlRegex) : "" };
  },

  toJSON(message: SearchForProductsByUrlRegexRequest): unknown {
    const obj: any = {};
    if (message.urlRegex !== "") {
      obj.urlRegex = message.urlRegex;
    }
    return obj;
  },
};

function createBaseSearchForProductsByUrlRegexResponse(): SearchForProductsByUrlRegexResponse {
  return { products: [] };
}

export const SearchForProductsByUrlRegexResponse: MessageFns<SearchForProductsByUrlRegexResponse> = {
  encode(message: SearchForProductsByUrlRegexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchForProductsByUrlRegexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchForProductsByUrlRegexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchForProductsByUrlRegexResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
    };
  },

  toJSON(message: SearchForProductsByUrlRegexResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    return obj;
  },
};

function createBaseGetLatestAcceptableAppVersionRequest(): GetLatestAcceptableAppVersionRequest {
  return {};
}

export const GetLatestAcceptableAppVersionRequest: MessageFns<GetLatestAcceptableAppVersionRequest> = {
  encode(_: GetLatestAcceptableAppVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestAcceptableAppVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestAcceptableAppVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetLatestAcceptableAppVersionRequest {
    return {};
  },

  toJSON(_: GetLatestAcceptableAppVersionRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetLatestAcceptableAppVersionResponse(): GetLatestAcceptableAppVersionResponse {
  return { version: "", buildNumber: "" };
}

export const GetLatestAcceptableAppVersionResponse: MessageFns<GetLatestAcceptableAppVersionResponse> = {
  encode(message: GetLatestAcceptableAppVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.buildNumber !== "") {
      writer.uint32(18).string(message.buildNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestAcceptableAppVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestAcceptableAppVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.buildNumber = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLatestAcceptableAppVersionResponse {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      buildNumber: isSet(object.buildNumber) ? globalThis.String(object.buildNumber) : "",
    };
  },

  toJSON(message: GetLatestAcceptableAppVersionResponse): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.buildNumber !== "") {
      obj.buildNumber = message.buildNumber;
    }
    return obj;
  },
};

function createBaseGetProductsRequest(): GetProductsRequest {
  return { productIds: [] };
}

export const GetProductsRequest: MessageFns<GetProductsRequest> = {
  encode(message: GetProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.productIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductsRequest {
    return {
      productIds: globalThis.Array.isArray(object?.productIds)
        ? object.productIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetProductsRequest): unknown {
    const obj: any = {};
    if (message.productIds?.length) {
      obj.productIds = message.productIds;
    }
    return obj;
  },
};

function createBaseGetProductsResponse(): GetProductsResponse {
  return { products: [] };
}

export const GetProductsResponse: MessageFns<GetProductsResponse> = {
  encode(message: GetProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductsResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetProductsResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    return obj;
  },
};

function createBaseProcessImageExtractAndSaveStyleRequest(): ProcessImageExtractAndSaveStyleRequest {
  return { imageUrl: "" };
}

export const ProcessImageExtractAndSaveStyleRequest: MessageFns<ProcessImageExtractAndSaveStyleRequest> = {
  encode(message: ProcessImageExtractAndSaveStyleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessImageExtractAndSaveStyleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessImageExtractAndSaveStyleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessImageExtractAndSaveStyleRequest {
    return { imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "" };
  },

  toJSON(message: ProcessImageExtractAndSaveStyleRequest): unknown {
    const obj: any = {};
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    return obj;
  },
};

function createBaseProcessImageExtractAndSaveStyleResponse(): ProcessImageExtractAndSaveStyleResponse {
  return { style: "" };
}

export const ProcessImageExtractAndSaveStyleResponse: MessageFns<ProcessImageExtractAndSaveStyleResponse> = {
  encode(message: ProcessImageExtractAndSaveStyleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.style !== "") {
      writer.uint32(10).string(message.style);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessImageExtractAndSaveStyleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessImageExtractAndSaveStyleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.style = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessImageExtractAndSaveStyleResponse {
    return { style: isSet(object.style) ? globalThis.String(object.style) : "" };
  },

  toJSON(message: ProcessImageExtractAndSaveStyleResponse): unknown {
    const obj: any = {};
    if (message.style !== "") {
      obj.style = message.style;
    }
    return obj;
  },
};

function createBaseUploadImageRequest(): UploadImageRequest {
  return { imageData: new Uint8Array(0) };
}

export const UploadImageRequest: MessageFns<UploadImageRequest> = {
  encode(message: UploadImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageData.length !== 0) {
      writer.uint32(10).bytes(message.imageData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadImageRequest {
    return { imageData: isSet(object.imageData) ? bytesFromBase64(object.imageData) : new Uint8Array(0) };
  },

  toJSON(message: UploadImageRequest): unknown {
    const obj: any = {};
    if (message.imageData.length !== 0) {
      obj.imageData = base64FromBytes(message.imageData);
    }
    return obj;
  },
};

function createBaseUploadImageResponse(): UploadImageResponse {
  return { imageUrl: "" };
}

export const UploadImageResponse: MessageFns<UploadImageResponse> = {
  encode(message: UploadImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadImageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadImageResponse {
    return { imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "" };
  },

  toJSON(message: UploadImageResponse): unknown {
    const obj: any = {};
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    return obj;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(_: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthCheckRequest {
    return {};
  },

  toJSON(_: HealthCheckRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { message: "" };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseTextEmbeddingRequest(): TextEmbeddingRequest {
  return { query: "" };
}

export const TextEmbeddingRequest: MessageFns<TextEmbeddingRequest> = {
  encode(message: TextEmbeddingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextEmbeddingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextEmbeddingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextEmbeddingRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: TextEmbeddingRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },
};

function createBaseImageEmbeddingRequest(): ImageEmbeddingRequest {
  return { imageData: new Uint8Array(0) };
}

export const ImageEmbeddingRequest: MessageFns<ImageEmbeddingRequest> = {
  encode(message: ImageEmbeddingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageData.length !== 0) {
      writer.uint32(10).bytes(message.imageData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageEmbeddingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageEmbeddingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageEmbeddingRequest {
    return { imageData: isSet(object.imageData) ? bytesFromBase64(object.imageData) : new Uint8Array(0) };
  },

  toJSON(message: ImageEmbeddingRequest): unknown {
    const obj: any = {};
    if (message.imageData.length !== 0) {
      obj.imageData = base64FromBytes(message.imageData);
    }
    return obj;
  },
};

function createBaseEmbeddingResponse(): EmbeddingResponse {
  return { embedding: [] };
}

export const EmbeddingResponse: MessageFns<EmbeddingResponse> = {
  encode(message: EmbeddingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.embedding) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbeddingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbeddingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.embedding.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.embedding.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbeddingResponse {
    return {
      embedding: globalThis.Array.isArray(object?.embedding)
        ? object.embedding.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: EmbeddingResponse): unknown {
    const obj: any = {};
    if (message.embedding?.length) {
      obj.embedding = message.embedding;
    }
    return obj;
  },
};

function createBaseStyleGenerationRequest(): StyleGenerationRequest {
  return { query: "", gender: 0, category: undefined, numProducts: undefined, searchMethod: undefined };
}

export const StyleGenerationRequest: MessageFns<StyleGenerationRequest> = {
  encode(message: StyleGenerationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.gender !== 0) {
      writer.uint32(16).int32(message.gender);
    }
    if (message.category !== undefined) {
      writer.uint32(24).int32(message.category);
    }
    if (message.numProducts !== undefined) {
      writer.uint32(32).int32(message.numProducts);
    }
    if (message.searchMethod !== undefined) {
      writer.uint32(40).int32(message.searchMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StyleGenerationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStyleGenerationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numProducts = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.searchMethod = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StyleGenerationRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : 0,
      category: isSet(object.category) ? productCategoryFromJSON(object.category) : undefined,
      numProducts: isSet(object.numProducts) ? globalThis.Number(object.numProducts) : undefined,
      searchMethod: isSet(object.searchMethod) ? searchMethodFromJSON(object.searchMethod) : undefined,
    };
  },

  toJSON(message: StyleGenerationRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.gender !== 0) {
      obj.gender = genderToJSON(message.gender);
    }
    if (message.category !== undefined) {
      obj.category = productCategoryToJSON(message.category);
    }
    if (message.numProducts !== undefined) {
      obj.numProducts = Math.round(message.numProducts);
    }
    if (message.searchMethod !== undefined) {
      obj.searchMethod = searchMethodToJSON(message.searchMethod);
    }
    return obj;
  },
};

function createBaseStyleGenerationResponse(): StyleGenerationResponse {
  return { results: [] };
}

export const StyleGenerationResponse: MessageFns<StyleGenerationResponse> = {
  encode(message: StyleGenerationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StyleGenerationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStyleGenerationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StyleGenerationResponse {
    return {
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => Product.fromJSON(e)) : [],
    };
  },

  toJSON(message: StyleGenerationResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => Product.toJSON(e));
    }
    return obj;
  },
};

function createBaseGetProductRequest(): GetProductRequest {
  return { id: "" };
}

export const GetProductRequest: MessageFns<GetProductRequest> = {
  encode(message: GetProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetProductRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
};

function createBaseGetProductResponse(): GetProductResponse {
  return { product: undefined };
}

export const GetProductResponse: MessageFns<GetProductResponse> = {
  encode(message: GetProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: GetProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },
};

function createBaseCreateProductRequest(): CreateProductRequest {
  return { product: undefined };
}

export const CreateProductRequest: MessageFns<CreateProductRequest> = {
  encode(message: CreateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductRequest {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: CreateProductRequest): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },
};

function createBaseCreateProductResponse(): CreateProductResponse {
  return { product: undefined };
}

export const CreateProductResponse: MessageFns<CreateProductResponse> = {
  encode(message: CreateProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: CreateProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBasePinterestImagePreferenceWithStyle(): PinterestImagePreferenceWithStyle {
  return { imagePreferenceItemWithStyle: undefined, searchQuery: "" };
}

export const PinterestImagePreferenceWithStyle: MessageFns<PinterestImagePreferenceWithStyle> = {
  encode(message: PinterestImagePreferenceWithStyle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imagePreferenceItemWithStyle !== undefined) {
      ImagePreferenceItemWithStyle.encode(message.imagePreferenceItemWithStyle, writer.uint32(10).fork()).join();
    }
    if (message.searchQuery !== "") {
      writer.uint32(18).string(message.searchQuery);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PinterestImagePreferenceWithStyle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePinterestImagePreferenceWithStyle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imagePreferenceItemWithStyle = ImagePreferenceItemWithStyle.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PinterestImagePreferenceWithStyle {
    return {
      imagePreferenceItemWithStyle: isSet(object.imagePreferenceItemWithStyle)
        ? ImagePreferenceItemWithStyle.fromJSON(object.imagePreferenceItemWithStyle)
        : undefined,
      searchQuery: isSet(object.searchQuery) ? globalThis.String(object.searchQuery) : "",
    };
  },

  toJSON(message: PinterestImagePreferenceWithStyle): unknown {
    const obj: any = {};
    if (message.imagePreferenceItemWithStyle !== undefined) {
      obj.imagePreferenceItemWithStyle = ImagePreferenceItemWithStyle.toJSON(message.imagePreferenceItemWithStyle);
    }
    if (message.searchQuery !== "") {
      obj.searchQuery = message.searchQuery;
    }
    return obj;
  },
};

function createBaseProductPreferenceToolUsage(): ProductPreferenceToolUsage {
  return { toolUseId: "", preferences: [] };
}

export const ProductPreferenceToolUsage: MessageFns<ProductPreferenceToolUsage> = {
  encode(message: ProductPreferenceToolUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolUseId !== "") {
      writer.uint32(10).string(message.toolUseId);
    }
    for (const v of message.preferences) {
      ProductWithSearchQueryAndPreference.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductPreferenceToolUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductPreferenceToolUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolUseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preferences.push(ProductWithSearchQueryAndPreference.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductPreferenceToolUsage {
    return {
      toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
      preferences: globalThis.Array.isArray(object?.preferences)
        ? object.preferences.map((e: any) => ProductWithSearchQueryAndPreference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProductPreferenceToolUsage): unknown {
    const obj: any = {};
    if (message.toolUseId !== "") {
      obj.toolUseId = message.toolUseId;
    }
    if (message.preferences?.length) {
      obj.preferences = message.preferences.map((e) => ProductWithSearchQueryAndPreference.toJSON(e));
    }
    return obj;
  },
};

function createBasePinterestGridToolUsage(): PinterestGridToolUsage {
  return { toolUseId: "", imagePreferenceItems: [] };
}

export const PinterestGridToolUsage: MessageFns<PinterestGridToolUsage> = {
  encode(message: PinterestGridToolUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolUseId !== "") {
      writer.uint32(10).string(message.toolUseId);
    }
    for (const v of message.imagePreferenceItems) {
      PinterestImagePreferenceWithStyle.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PinterestGridToolUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePinterestGridToolUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolUseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.imagePreferenceItems.push(PinterestImagePreferenceWithStyle.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PinterestGridToolUsage {
    return {
      toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
      imagePreferenceItems: globalThis.Array.isArray(object?.imagePreferenceItems)
        ? object.imagePreferenceItems.map((e: any) => PinterestImagePreferenceWithStyle.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PinterestGridToolUsage): unknown {
    const obj: any = {};
    if (message.toolUseId !== "") {
      obj.toolUseId = message.toolUseId;
    }
    if (message.imagePreferenceItems?.length) {
      obj.imagePreferenceItems = message.imagePreferenceItems.map((e) => PinterestImagePreferenceWithStyle.toJSON(e));
    }
    return obj;
  },
};

function createBasePinterestImageGridToolUsage(): PinterestImageGridToolUsage {
  return { toolUseId: "", imagePreferenceItems: [] };
}

export const PinterestImageGridToolUsage: MessageFns<PinterestImageGridToolUsage> = {
  encode(message: PinterestImageGridToolUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolUseId !== "") {
      writer.uint32(10).string(message.toolUseId);
    }
    for (const v of message.imagePreferenceItems) {
      PinterestImagePreferenceWithStyle.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PinterestImageGridToolUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePinterestImageGridToolUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolUseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.imagePreferenceItems.push(PinterestImagePreferenceWithStyle.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PinterestImageGridToolUsage {
    return {
      toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
      imagePreferenceItems: globalThis.Array.isArray(object?.imagePreferenceItems)
        ? object.imagePreferenceItems.map((e: any) => PinterestImagePreferenceWithStyle.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PinterestImageGridToolUsage): unknown {
    const obj: any = {};
    if (message.toolUseId !== "") {
      obj.toolUseId = message.toolUseId;
    }
    if (message.imagePreferenceItems?.length) {
      obj.imagePreferenceItems = message.imagePreferenceItems.map((e) => PinterestImagePreferenceWithStyle.toJSON(e));
    }
    return obj;
  },
};

function createBaseFinishChatToolUsage(): FinishChatToolUsage {
  return { toolUseId: "", userRequirements: [], productSuggestions: [] };
}

export const FinishChatToolUsage: MessageFns<FinishChatToolUsage> = {
  encode(message: FinishChatToolUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolUseId !== "") {
      writer.uint32(10).string(message.toolUseId);
    }
    for (const v of message.userRequirements) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.productSuggestions) {
      ProductSuggestion.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinishChatToolUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishChatToolUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolUseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userRequirements.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productSuggestions.push(ProductSuggestion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinishChatToolUsage {
    return {
      toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
      userRequirements: globalThis.Array.isArray(object?.userRequirements)
        ? object.userRequirements.map((e: any) => globalThis.String(e))
        : [],
      productSuggestions: globalThis.Array.isArray(object?.productSuggestions)
        ? object.productSuggestions.map((e: any) => ProductSuggestion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FinishChatToolUsage): unknown {
    const obj: any = {};
    if (message.toolUseId !== "") {
      obj.toolUseId = message.toolUseId;
    }
    if (message.userRequirements?.length) {
      obj.userRequirements = message.userRequirements;
    }
    if (message.productSuggestions?.length) {
      obj.productSuggestions = message.productSuggestions.map((e) => ProductSuggestion.toJSON(e));
    }
    return obj;
  },
};

function createBaseExploreMessageV2(): ExploreMessageV2 {
  return { message: undefined };
}

export const ExploreMessageV2: MessageFns<ExploreMessageV2> = {
  encode(message: ExploreMessageV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.message?.$case) {
      case "basicMessage":
        Message.encode(message.message.basicMessage, writer.uint32(10).fork()).join();
        break;
      case "productPreferenceToolUsage":
        ProductPreferenceToolUsage.encode(message.message.productPreferenceToolUsage, writer.uint32(18).fork()).join();
        break;
      case "pinterestGridToolUsage":
        PinterestGridToolUsage.encode(message.message.pinterestGridToolUsage, writer.uint32(26).fork()).join();
        break;
      case "pinterestImageGridToolUsage":
        PinterestImageGridToolUsage.encode(message.message.pinterestImageGridToolUsage, writer.uint32(34).fork())
          .join();
        break;
      case "finishChatToolUsage":
        FinishChatToolUsage.encode(message.message.finishChatToolUsage, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExploreMessageV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExploreMessageV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = { $case: "basicMessage", basicMessage: Message.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = {
            $case: "productPreferenceToolUsage",
            productPreferenceToolUsage: ProductPreferenceToolUsage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = {
            $case: "pinterestGridToolUsage",
            pinterestGridToolUsage: PinterestGridToolUsage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = {
            $case: "pinterestImageGridToolUsage",
            pinterestImageGridToolUsage: PinterestImageGridToolUsage.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = {
            $case: "finishChatToolUsage",
            finishChatToolUsage: FinishChatToolUsage.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExploreMessageV2 {
    return {
      message: isSet(object.basicMessage)
        ? { $case: "basicMessage", basicMessage: Message.fromJSON(object.basicMessage) }
        : isSet(object.productPreferenceToolUsage)
        ? {
          $case: "productPreferenceToolUsage",
          productPreferenceToolUsage: ProductPreferenceToolUsage.fromJSON(object.productPreferenceToolUsage),
        }
        : isSet(object.pinterestGridToolUsage)
        ? {
          $case: "pinterestGridToolUsage",
          pinterestGridToolUsage: PinterestGridToolUsage.fromJSON(object.pinterestGridToolUsage),
        }
        : isSet(object.pinterestImageGridToolUsage)
        ? {
          $case: "pinterestImageGridToolUsage",
          pinterestImageGridToolUsage: PinterestImageGridToolUsage.fromJSON(object.pinterestImageGridToolUsage),
        }
        : isSet(object.finishChatToolUsage)
        ? {
          $case: "finishChatToolUsage",
          finishChatToolUsage: FinishChatToolUsage.fromJSON(object.finishChatToolUsage),
        }
        : undefined,
    };
  },

  toJSON(message: ExploreMessageV2): unknown {
    const obj: any = {};
    if (message.message?.$case === "basicMessage") {
      obj.basicMessage = Message.toJSON(message.message.basicMessage);
    } else if (message.message?.$case === "productPreferenceToolUsage") {
      obj.productPreferenceToolUsage = ProductPreferenceToolUsage.toJSON(message.message.productPreferenceToolUsage);
    } else if (message.message?.$case === "pinterestGridToolUsage") {
      obj.pinterestGridToolUsage = PinterestGridToolUsage.toJSON(message.message.pinterestGridToolUsage);
    } else if (message.message?.$case === "pinterestImageGridToolUsage") {
      obj.pinterestImageGridToolUsage = PinterestImageGridToolUsage.toJSON(message.message.pinterestImageGridToolUsage);
    } else if (message.message?.$case === "finishChatToolUsage") {
      obj.finishChatToolUsage = FinishChatToolUsage.toJSON(message.message.finishChatToolUsage);
    }
    return obj;
  },
};

function createBaseCardExpirationDate(): CardExpirationDate {
  return { month: 0, year: 0 };
}

export const CardExpirationDate: MessageFns<CardExpirationDate> = {
  encode(message: CardExpirationDate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.month !== 0) {
      writer.uint32(8).int32(message.month);
    }
    if (message.year !== 0) {
      writer.uint32(16).int32(message.year);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CardExpirationDate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCardExpirationDate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.month = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CardExpirationDate {
    return {
      month: isSet(object.month) ? globalThis.Number(object.month) : 0,
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
    };
  },

  toJSON(message: CardExpirationDate): unknown {
    const obj: any = {};
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    return obj;
  },
};

function createBaseCard(): Card {
  return {
    id: "",
    cardNumber: "",
    cvv: "",
    holderName: "",
    expirationDate: undefined,
    billingAddress: "",
    mailingAddress: undefined,
  };
}

export const Card: MessageFns<Card> = {
  encode(message: Card, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.cardNumber !== "") {
      writer.uint32(18).string(message.cardNumber);
    }
    if (message.cvv !== "") {
      writer.uint32(26).string(message.cvv);
    }
    if (message.holderName !== "") {
      writer.uint32(34).string(message.holderName);
    }
    if (message.expirationDate !== undefined) {
      CardExpirationDate.encode(message.expirationDate, writer.uint32(42).fork()).join();
    }
    if (message.billingAddress !== "") {
      writer.uint32(50).string(message.billingAddress);
    }
    if (message.mailingAddress !== undefined) {
      writer.uint32(58).string(message.mailingAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Card {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cardNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cvv = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.holderName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expirationDate = CardExpirationDate.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.billingAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mailingAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Card {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      cardNumber: isSet(object.cardNumber) ? globalThis.String(object.cardNumber) : "",
      cvv: isSet(object.cvv) ? globalThis.String(object.cvv) : "",
      holderName: isSet(object.holderName) ? globalThis.String(object.holderName) : "",
      expirationDate: isSet(object.expirationDate) ? CardExpirationDate.fromJSON(object.expirationDate) : undefined,
      billingAddress: isSet(object.billingAddress) ? globalThis.String(object.billingAddress) : "",
      mailingAddress: isSet(object.mailingAddress) ? globalThis.String(object.mailingAddress) : undefined,
    };
  },

  toJSON(message: Card): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.cardNumber !== "") {
      obj.cardNumber = message.cardNumber;
    }
    if (message.cvv !== "") {
      obj.cvv = message.cvv;
    }
    if (message.holderName !== "") {
      obj.holderName = message.holderName;
    }
    if (message.expirationDate !== undefined) {
      obj.expirationDate = CardExpirationDate.toJSON(message.expirationDate);
    }
    if (message.billingAddress !== "") {
      obj.billingAddress = message.billingAddress;
    }
    if (message.mailingAddress !== undefined) {
      obj.mailingAddress = message.mailingAddress;
    }
    return obj;
  },
};

export type BaseServiceDefinition = typeof BaseServiceDefinition;
export const BaseServiceDefinition = {
  name: "BaseService",
  fullName: "base.BaseService",
  methods: {
    getProduct: {
      name: "GetProduct",
      requestType: GetProductRequest,
      requestStream: false,
      responseType: GetProductResponse,
      responseStream: false,
      options: {},
    },
    getProducts: {
      name: "GetProducts",
      requestType: GetProductsRequest,
      requestStream: false,
      responseType: GetProductsResponse,
      responseStream: false,
      options: {},
    },
    search: {
      name: "Search",
      requestType: SearchRequest,
      requestStream: false,
      responseType: SearchResponse,
      responseStream: false,
      options: {},
    },
    getTextEmbedding: {
      name: "GetTextEmbedding",
      requestType: TextEmbeddingRequest,
      requestStream: false,
      responseType: EmbeddingResponse,
      responseStream: false,
      options: {},
    },
    getImageEmbedding: {
      name: "GetImageEmbedding",
      requestType: ImageEmbeddingRequest,
      requestStream: false,
      responseType: EmbeddingResponse,
      responseStream: false,
      options: {},
    },
    generateStyles: {
      name: "GenerateStyles",
      requestType: StyleGenerationRequest,
      requestStream: false,
      responseType: StyleGenerationResponse,
      responseStream: false,
      options: {},
    },
    healthCheck: {
      name: "HealthCheck",
      requestType: HealthCheckRequest,
      requestStream: false,
      responseType: HealthCheckResponse,
      responseStream: false,
      options: {},
    },
    createProduct: {
      name: "CreateProduct",
      requestType: CreateProductRequest,
      requestStream: false,
      responseType: CreateProductResponse,
      responseStream: false,
      options: {},
    },
    updateProduct: {
      name: "UpdateProduct",
      requestType: UpdateProductRequest,
      requestStream: false,
      responseType: UpdateProductResponse,
      responseStream: false,
      options: {},
    },
    getBrands: {
      name: "GetBrands",
      requestType: GetBrandsRequest,
      requestStream: false,
      responseType: GetBrandsResponse,
      responseStream: false,
      options: {},
    },
    createBrand: {
      name: "CreateBrand",
      requestType: CreateBrandRequest,
      requestStream: false,
      responseType: CreateBrandResponse,
      responseStream: false,
      options: {},
    },
    getSimilarProducts: {
      name: "GetSimilarProducts",
      requestType: SimilarProductsRequest,
      requestStream: false,
      responseType: SimilarProductsResponse,
      responseStream: false,
      options: {},
    },
    uploadImage: {
      name: "UploadImage",
      requestType: UploadImageRequest,
      requestStream: false,
      responseType: UploadImageResponse,
      responseStream: false,
      options: {},
    },
    getLatestAcceptableAppVersion: {
      name: "GetLatestAcceptableAppVersion",
      requestType: GetLatestAcceptableAppVersionRequest,
      requestStream: false,
      responseType: GetLatestAcceptableAppVersionResponse,
      responseStream: false,
      options: {},
    },
    searchForProductsByUrlRegex: {
      name: "SearchForProductsByUrlRegex",
      requestType: SearchForProductsByUrlRegexRequest,
      requestStream: false,
      responseType: SearchForProductsByUrlRegexResponse,
      responseStream: false,
      options: {},
    },
    listStylePickerProducts: {
      name: "ListStylePickerProducts",
      requestType: ListStylePickerProductsRequest,
      requestStream: false,
      responseType: ListStylePickerProductsResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface BaseServiceImplementation<CallContextExt = {}> {
  getProduct(request: GetProductRequest, context: CallContext & CallContextExt): Promise<GetProductResponse>;
  getProducts(request: GetProductsRequest, context: CallContext & CallContextExt): Promise<GetProductsResponse>;
  search(request: SearchRequest, context: CallContext & CallContextExt): Promise<SearchResponse>;
  getTextEmbedding(request: TextEmbeddingRequest, context: CallContext & CallContextExt): Promise<EmbeddingResponse>;
  getImageEmbedding(request: ImageEmbeddingRequest, context: CallContext & CallContextExt): Promise<EmbeddingResponse>;
  generateStyles(
    request: StyleGenerationRequest,
    context: CallContext & CallContextExt,
  ): Promise<StyleGenerationResponse>;
  healthCheck(request: HealthCheckRequest, context: CallContext & CallContextExt): Promise<HealthCheckResponse>;
  createProduct(request: CreateProductRequest, context: CallContext & CallContextExt): Promise<CreateProductResponse>;
  updateProduct(request: UpdateProductRequest, context: CallContext & CallContextExt): Promise<UpdateProductResponse>;
  getBrands(request: GetBrandsRequest, context: CallContext & CallContextExt): Promise<GetBrandsResponse>;
  createBrand(request: CreateBrandRequest, context: CallContext & CallContextExt): Promise<CreateBrandResponse>;
  getSimilarProducts(
    request: SimilarProductsRequest,
    context: CallContext & CallContextExt,
  ): Promise<SimilarProductsResponse>;
  uploadImage(request: UploadImageRequest, context: CallContext & CallContextExt): Promise<UploadImageResponse>;
  getLatestAcceptableAppVersion(
    request: GetLatestAcceptableAppVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<GetLatestAcceptableAppVersionResponse>;
  searchForProductsByUrlRegex(
    request: SearchForProductsByUrlRegexRequest,
    context: CallContext & CallContextExt,
  ): Promise<SearchForProductsByUrlRegexResponse>;
  listStylePickerProducts(
    request: ListStylePickerProductsRequest,
    context: CallContext & CallContextExt,
  ): Promise<ListStylePickerProductsResponse>;
}

export interface BaseServiceClient<CallOptionsExt = {}> {
  getProduct(request: GetProductRequest, options?: CallOptions & CallOptionsExt): Promise<GetProductResponse>;
  getProducts(request: GetProductsRequest, options?: CallOptions & CallOptionsExt): Promise<GetProductsResponse>;
  search(request: SearchRequest, options?: CallOptions & CallOptionsExt): Promise<SearchResponse>;
  getTextEmbedding(request: TextEmbeddingRequest, options?: CallOptions & CallOptionsExt): Promise<EmbeddingResponse>;
  getImageEmbedding(request: ImageEmbeddingRequest, options?: CallOptions & CallOptionsExt): Promise<EmbeddingResponse>;
  generateStyles(
    request: StyleGenerationRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StyleGenerationResponse>;
  healthCheck(request: HealthCheckRequest, options?: CallOptions & CallOptionsExt): Promise<HealthCheckResponse>;
  createProduct(request: CreateProductRequest, options?: CallOptions & CallOptionsExt): Promise<CreateProductResponse>;
  updateProduct(request: UpdateProductRequest, options?: CallOptions & CallOptionsExt): Promise<UpdateProductResponse>;
  getBrands(request: GetBrandsRequest, options?: CallOptions & CallOptionsExt): Promise<GetBrandsResponse>;
  createBrand(request: CreateBrandRequest, options?: CallOptions & CallOptionsExt): Promise<CreateBrandResponse>;
  getSimilarProducts(
    request: SimilarProductsRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SimilarProductsResponse>;
  uploadImage(request: UploadImageRequest, options?: CallOptions & CallOptionsExt): Promise<UploadImageResponse>;
  getLatestAcceptableAppVersion(
    request: GetLatestAcceptableAppVersionRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetLatestAcceptableAppVersionResponse>;
  searchForProductsByUrlRegex(
    request: SearchForProductsByUrlRegexRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchForProductsByUrlRegexResponse>;
  listStylePickerProducts(
    request: ListStylePickerProductsRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListStylePickerProductsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
