// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v5.29.3
// source: orderManagement/orderManagement.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  Card,
  Empty,
  ExploreRequest,
  OrderStatus,
  orderStatusFromJSON,
  orderStatusToJSON,
  OrderSummary,
  OrderType,
  orderTypeFromJSON,
  orderTypeToJSON,
  PaymentStatus,
  paymentStatusFromJSON,
  paymentStatusToJSON,
  PopulatedOrderSuggestion,
  ProductPurchase,
  ProductPurchaseFeedbackCategory,
  productPurchaseFeedbackCategoryFromJSON,
  productPurchaseFeedbackCategoryToJSON,
  ProductPurchaseSuggestion,
  ProductPurchaseSuggestionStatus,
  productPurchaseSuggestionStatusFromJSON,
  productPurchaseSuggestionStatusToJSON,
  ProductRecommendation,
  RefundStatus,
  refundStatusFromJSON,
  refundStatusToJSON,
  ShipmentStatus,
  shipmentStatusFromJSON,
  shipmentStatusToJSON,
} from "../base/base";

export const protobufPackage = "orderManagement";

export interface EnrichedOrderDetail {
  order: OrderSummary | undefined;
  requestChat?: ExploreRequest | undefined;
}

export interface CreateOrderRequest {
  customerId?: string | undefined;
  stylistId?: string | undefined;
  chatId: string;
  productRecommendations: ProductRecommendation[];
  note?: string | undefined;
  type?: OrderType | undefined;
}

export interface CreateOrderResponse {
  order: OrderSummary | undefined;
}

export interface GetOrderRequest {
  orderId: string;
}

export interface GetOrderResponse {
  order: OrderSummary | undefined;
}

export interface ListOrdersRequest {
  customerId?: string | undefined;
  stylistId?: string | undefined;
  status?: OrderStatus | undefined;
  shouldIncludeArchivedSuggestions?: boolean | undefined;
}

export interface ListOrdersResponse {
  orders: OrderSummary[];
}

export interface UpdateOrderRequest {
  orderId: string;
  stylistId?: string | undefined;
  status?: OrderStatus | undefined;
  isStarred?: boolean | undefined;
}

export interface UpdateOrderResponse {
  order: OrderSummary | undefined;
}

export interface DeleteOrderRequest {
  orderId: string;
}

export interface DeleteOrderResponse {
  success: boolean;
}

export interface GetEnrichedOrderResponse {
  enrichedOrder: EnrichedOrderDetail | undefined;
}

export interface EditProductPurchaseSuggestionRequest {
  productPurchaseSuggestionId: string;
  productPurchaseId?: string | undefined;
  size: string;
  color: string;
  price: number;
  originalPrice?: number | undefined;
  isRefundable?: boolean | undefined;
  status?: ProductPurchaseSuggestionStatus | undefined;
}

export interface EditProductPurchaseSuggestionResponse {
}

export interface ToggleProductPurchaseSuggestionArchivedRequest {
  productPurchaseSuggestionId: string;
  productPurchaseId?: string | undefined;
  isArchived: boolean;
  archiveReason: string;
}

export interface ToggleProductPurchaseSuggestionArchivedResponse {
}

export interface DeleteOrderSuggestionsRequest {
  orderSuggestionIds: string[];
}

export interface DeleteOrderSuggestionsResponse {
}

export interface RemoveProductSuggestionFromOrderSuggestionRequest {
  orderSuggestionId: string;
  productSuggestionId?: string | undefined;
  productPurchaseId?: string | undefined;
}

export interface RemoveProductSuggestionFromOrderSuggestionResponse {
}

export interface AddProductSuggestionToOrderSuggestionRequest {
  orderSuggestionId: string;
  productId: string;
  size: string;
  color: string;
}

export interface AddProductSuggestionToOrderSuggestionResponse {
}

export interface PublishDraftSuggestionRequest {
  orderSuggestionId: string;
}

export interface PublishDraftSuggestionResponse {
}

export interface UpdateOrderSuggestionStylistNoteRequest {
  orderSuggestionId: string;
  stylistNote?: string | undefined;
}

export interface UpdateOrderSuggestionStylistNoteResponse {
}

export interface UpdateProductPurchaseRequest {
  productPurchaseId: string;
  refundStatus?: RefundStatus | undefined;
  paymentStatus?: PaymentStatus | undefined;
  stripePaymentId?: string | undefined;
}

export interface UpdateProductPurchaseResponse {
  productPurchase: ProductPurchase | undefined;
}

export interface GetShipmentIntentInfoRequest {
}

export interface GetShipmentIntentInfoResponse {
  email: string;
  creditCard: Card | undefined;
}

export interface SetSuggestionArchivedRequest {
  orderSuggestionId: string;
  isArchived: boolean;
}

export interface SetSuggestionArchivedResponse {
  message: string;
}

export interface ReplaceOrderSuggestionRequest {
  orderSuggestionId: string;
  productPurchases: NakedProductPurchaseSuggestion[];
}

export interface ReplaceOrderSuggestionResponse {
  orderSuggestion: PopulatedOrderSuggestion | undefined;
}

export interface FinalizeOrderSuggestionRequest {
  orderSuggestionId: string;
}

export interface FinalizeOrderSuggestionResponse {
  orderSuggestion: PopulatedOrderSuggestion | undefined;
}

export interface DeleteShipmentRequest {
  shipmentId: string;
}

export interface SubmitProductPurchaseFeedbackRequest {
  productPurchaseId: string;
  categories: ProductPurchaseFeedbackCategory[];
  feedback?: string | undefined;
  isRefundRequested?: boolean | undefined;
}

export interface SubmitProductPurchaseSuggestionFeedbackRequest {
  productPurchaseId: string;
  note?: string | undefined;
}

export interface SubmitProductPurchaseSuggestionFeedbackResponse {
  productPurchaseSuggestion: ProductPurchaseSuggestion | undefined;
}

export interface UpdateShippingInformationRequest {
  shipmentId: string;
  brandOrderNumber?: string | undefined;
  trackingNumber?: string | undefined;
  trackingUrl?: string | undefined;
  expectedDeliveryDateStart?: number | undefined;
  expectedDeliveryDateEnd?: number | undefined;
  status: ShipmentStatus;
  email?: string | undefined;
}

export interface NakedProductPurchase {
  productId: string;
  size: string;
  price: number;
  originalPrice?: number | undefined;
  isRefundable?: boolean | undefined;
  color: string;
}

export interface AddShipmentToOrderSuggestionRequest {
  orderSuggestionId: string;
  brandId: string;
  productPurchases: NakedProductPurchase[];
  /** Order Info */
  brandOrderNumber?:
    | string
    | undefined;
  /** Tracking Info */
  trackingNumber?: string | undefined;
  trackingUrl?: string | undefined;
  expectedDeliveryDateStart?: number | undefined;
  expectedDeliveryDateEnd?: number | undefined;
  shipmentId?: string | undefined;
  creditCardCardIdToLock?: string | undefined;
  email?: string | undefined;
  totalPrice: number;
  shippingCost?: number | undefined;
}

export interface AddShipmentToOrderSuggestionResponse {
  shipmentId: string;
}

export interface SubmitOrderSuggestionUserResponseRequest {
  orderSuggestionId: string;
  acceptedProductPurchaseIds: string[];
}

export interface NakedProductPurchaseSuggestion {
  productId: string;
  size: string;
  price: number;
  originalPrice?: number | undefined;
  isRefundable?: boolean | undefined;
  color: string;
}

export interface CreateOrderSuggestionRequest {
  orderId: string;
  productPurchases: NakedProductPurchaseSuggestion[];
  isAutoAccepted: boolean;
  stylistNote?: string | undefined;
  isDraft: boolean;
}

export interface CreateOrderSuggestionResponse {
  order: OrderSummary | undefined;
}

export interface SubmitProductPurchaseRequest {
  orderId: string;
}

export interface SubmitProductPurchaseResponse {
  success: boolean;
}

export interface SendShippingEmailRequest {
  orderId: string;
  trackingNumber: string;
  trackingUrl: string;
}

export interface SendShippingEmailResponse {
  success: boolean;
}

function createBaseEnrichedOrderDetail(): EnrichedOrderDetail {
  return { order: undefined, requestChat: undefined };
}

export const EnrichedOrderDetail: MessageFns<EnrichedOrderDetail> = {
  encode(message: EnrichedOrderDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      OrderSummary.encode(message.order, writer.uint32(10).fork()).join();
    }
    if (message.requestChat !== undefined) {
      ExploreRequest.encode(message.requestChat, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnrichedOrderDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnrichedOrderDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = OrderSummary.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestChat = ExploreRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnrichedOrderDetail {
    return {
      order: isSet(object.order) ? OrderSummary.fromJSON(object.order) : undefined,
      requestChat: isSet(object.requestChat) ? ExploreRequest.fromJSON(object.requestChat) : undefined,
    };
  },

  toJSON(message: EnrichedOrderDetail): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = OrderSummary.toJSON(message.order);
    }
    if (message.requestChat !== undefined) {
      obj.requestChat = ExploreRequest.toJSON(message.requestChat);
    }
    return obj;
  },
};

function createBaseCreateOrderRequest(): CreateOrderRequest {
  return {
    customerId: undefined,
    stylistId: undefined,
    chatId: "",
    productRecommendations: [],
    note: undefined,
    type: undefined,
  };
}

export const CreateOrderRequest: MessageFns<CreateOrderRequest> = {
  encode(message: CreateOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== undefined) {
      writer.uint32(10).string(message.customerId);
    }
    if (message.stylistId !== undefined) {
      writer.uint32(18).string(message.stylistId);
    }
    if (message.chatId !== "") {
      writer.uint32(26).string(message.chatId);
    }
    for (const v of message.productRecommendations) {
      ProductRecommendation.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.note !== undefined) {
      writer.uint32(42).string(message.note);
    }
    if (message.type !== undefined) {
      writer.uint32(48).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stylistId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.productRecommendations.push(ProductRecommendation.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.note = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : undefined,
      stylistId: isSet(object.stylistId) ? globalThis.String(object.stylistId) : undefined,
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      productRecommendations: globalThis.Array.isArray(object?.productRecommendations)
        ? object.productRecommendations.map((e: any) => ProductRecommendation.fromJSON(e))
        : [],
      note: isSet(object.note) ? globalThis.String(object.note) : undefined,
      type: isSet(object.type) ? orderTypeFromJSON(object.type) : undefined,
    };
  },

  toJSON(message: CreateOrderRequest): unknown {
    const obj: any = {};
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.stylistId !== undefined) {
      obj.stylistId = message.stylistId;
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.productRecommendations?.length) {
      obj.productRecommendations = message.productRecommendations.map((e) => ProductRecommendation.toJSON(e));
    }
    if (message.note !== undefined) {
      obj.note = message.note;
    }
    if (message.type !== undefined) {
      obj.type = orderTypeToJSON(message.type);
    }
    return obj;
  },
};

function createBaseCreateOrderResponse(): CreateOrderResponse {
  return { order: undefined };
}

export const CreateOrderResponse: MessageFns<CreateOrderResponse> = {
  encode(message: CreateOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      OrderSummary.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = OrderSummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderResponse {
    return { order: isSet(object.order) ? OrderSummary.fromJSON(object.order) : undefined };
  },

  toJSON(message: CreateOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = OrderSummary.toJSON(message.order);
    }
    return obj;
  },
};

function createBaseGetOrderRequest(): GetOrderRequest {
  return { orderId: "" };
}

export const GetOrderRequest: MessageFns<GetOrderRequest> = {
  encode(message: GetOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: GetOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },
};

function createBaseGetOrderResponse(): GetOrderResponse {
  return { order: undefined };
}

export const GetOrderResponse: MessageFns<GetOrderResponse> = {
  encode(message: GetOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      OrderSummary.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = OrderSummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderResponse {
    return { order: isSet(object.order) ? OrderSummary.fromJSON(object.order) : undefined };
  },

  toJSON(message: GetOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = OrderSummary.toJSON(message.order);
    }
    return obj;
  },
};

function createBaseListOrdersRequest(): ListOrdersRequest {
  return {
    customerId: undefined,
    stylistId: undefined,
    status: undefined,
    shouldIncludeArchivedSuggestions: undefined,
  };
}

export const ListOrdersRequest: MessageFns<ListOrdersRequest> = {
  encode(message: ListOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== undefined) {
      writer.uint32(10).string(message.customerId);
    }
    if (message.stylistId !== undefined) {
      writer.uint32(18).string(message.stylistId);
    }
    if (message.status !== undefined) {
      writer.uint32(24).int32(message.status);
    }
    if (message.shouldIncludeArchivedSuggestions !== undefined) {
      writer.uint32(32).bool(message.shouldIncludeArchivedSuggestions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stylistId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.shouldIncludeArchivedSuggestions = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrdersRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : undefined,
      stylistId: isSet(object.stylistId) ? globalThis.String(object.stylistId) : undefined,
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : undefined,
      shouldIncludeArchivedSuggestions: isSet(object.shouldIncludeArchivedSuggestions)
        ? globalThis.Boolean(object.shouldIncludeArchivedSuggestions)
        : undefined,
    };
  },

  toJSON(message: ListOrdersRequest): unknown {
    const obj: any = {};
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.stylistId !== undefined) {
      obj.stylistId = message.stylistId;
    }
    if (message.status !== undefined) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.shouldIncludeArchivedSuggestions !== undefined) {
      obj.shouldIncludeArchivedSuggestions = message.shouldIncludeArchivedSuggestions;
    }
    return obj;
  },
};

function createBaseListOrdersResponse(): ListOrdersResponse {
  return { orders: [] };
}

export const ListOrdersResponse: MessageFns<ListOrdersResponse> = {
  encode(message: ListOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      OrderSummary.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(OrderSummary.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrdersResponse {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => OrderSummary.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => OrderSummary.toJSON(e));
    }
    return obj;
  },
};

function createBaseUpdateOrderRequest(): UpdateOrderRequest {
  return { orderId: "", stylistId: undefined, status: undefined, isStarred: undefined };
}

export const UpdateOrderRequest: MessageFns<UpdateOrderRequest> = {
  encode(message: UpdateOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.stylistId !== undefined) {
      writer.uint32(18).string(message.stylistId);
    }
    if (message.status !== undefined) {
      writer.uint32(24).int32(message.status);
    }
    if (message.isStarred !== undefined) {
      writer.uint32(32).bool(message.isStarred);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stylistId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isStarred = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOrderRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      stylistId: isSet(object.stylistId) ? globalThis.String(object.stylistId) : undefined,
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : undefined,
      isStarred: isSet(object.isStarred) ? globalThis.Boolean(object.isStarred) : undefined,
    };
  },

  toJSON(message: UpdateOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.stylistId !== undefined) {
      obj.stylistId = message.stylistId;
    }
    if (message.status !== undefined) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.isStarred !== undefined) {
      obj.isStarred = message.isStarred;
    }
    return obj;
  },
};

function createBaseUpdateOrderResponse(): UpdateOrderResponse {
  return { order: undefined };
}

export const UpdateOrderResponse: MessageFns<UpdateOrderResponse> = {
  encode(message: UpdateOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      OrderSummary.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = OrderSummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOrderResponse {
    return { order: isSet(object.order) ? OrderSummary.fromJSON(object.order) : undefined };
  },

  toJSON(message: UpdateOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = OrderSummary.toJSON(message.order);
    }
    return obj;
  },
};

function createBaseDeleteOrderRequest(): DeleteOrderRequest {
  return { orderId: "" };
}

export const DeleteOrderRequest: MessageFns<DeleteOrderRequest> = {
  encode(message: DeleteOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteOrderRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: DeleteOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },
};

function createBaseDeleteOrderResponse(): DeleteOrderResponse {
  return { success: false };
}

export const DeleteOrderResponse: MessageFns<DeleteOrderResponse> = {
  encode(message: DeleteOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteOrderResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteOrderResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },
};

function createBaseGetEnrichedOrderResponse(): GetEnrichedOrderResponse {
  return { enrichedOrder: undefined };
}

export const GetEnrichedOrderResponse: MessageFns<GetEnrichedOrderResponse> = {
  encode(message: GetEnrichedOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enrichedOrder !== undefined) {
      EnrichedOrderDetail.encode(message.enrichedOrder, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEnrichedOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEnrichedOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.enrichedOrder = EnrichedOrderDetail.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEnrichedOrderResponse {
    return {
      enrichedOrder: isSet(object.enrichedOrder) ? EnrichedOrderDetail.fromJSON(object.enrichedOrder) : undefined,
    };
  },

  toJSON(message: GetEnrichedOrderResponse): unknown {
    const obj: any = {};
    if (message.enrichedOrder !== undefined) {
      obj.enrichedOrder = EnrichedOrderDetail.toJSON(message.enrichedOrder);
    }
    return obj;
  },
};

function createBaseEditProductPurchaseSuggestionRequest(): EditProductPurchaseSuggestionRequest {
  return {
    productPurchaseSuggestionId: "",
    productPurchaseId: undefined,
    size: "",
    color: "",
    price: 0,
    originalPrice: undefined,
    isRefundable: undefined,
    status: undefined,
  };
}

export const EditProductPurchaseSuggestionRequest: MessageFns<EditProductPurchaseSuggestionRequest> = {
  encode(message: EditProductPurchaseSuggestionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productPurchaseSuggestionId !== "") {
      writer.uint32(10).string(message.productPurchaseSuggestionId);
    }
    if (message.productPurchaseId !== undefined) {
      writer.uint32(18).string(message.productPurchaseId);
    }
    if (message.size !== "") {
      writer.uint32(26).string(message.size);
    }
    if (message.color !== "") {
      writer.uint32(34).string(message.color);
    }
    if (message.price !== 0) {
      writer.uint32(45).float(message.price);
    }
    if (message.originalPrice !== undefined) {
      writer.uint32(53).float(message.originalPrice);
    }
    if (message.isRefundable !== undefined) {
      writer.uint32(56).bool(message.isRefundable);
    }
    if (message.status !== undefined) {
      writer.uint32(64).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditProductPurchaseSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditProductPurchaseSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productPurchaseSuggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productPurchaseId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.size = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isRefundable = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditProductPurchaseSuggestionRequest {
    return {
      productPurchaseSuggestionId: isSet(object.productPurchaseSuggestionId)
        ? globalThis.String(object.productPurchaseSuggestionId)
        : "",
      productPurchaseId: isSet(object.productPurchaseId) ? globalThis.String(object.productPurchaseId) : undefined,
      size: isSet(object.size) ? globalThis.String(object.size) : "",
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : undefined,
      isRefundable: isSet(object.isRefundable) ? globalThis.Boolean(object.isRefundable) : undefined,
      status: isSet(object.status) ? productPurchaseSuggestionStatusFromJSON(object.status) : undefined,
    };
  },

  toJSON(message: EditProductPurchaseSuggestionRequest): unknown {
    const obj: any = {};
    if (message.productPurchaseSuggestionId !== "") {
      obj.productPurchaseSuggestionId = message.productPurchaseSuggestionId;
    }
    if (message.productPurchaseId !== undefined) {
      obj.productPurchaseId = message.productPurchaseId;
    }
    if (message.size !== "") {
      obj.size = message.size;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = message.originalPrice;
    }
    if (message.isRefundable !== undefined) {
      obj.isRefundable = message.isRefundable;
    }
    if (message.status !== undefined) {
      obj.status = productPurchaseSuggestionStatusToJSON(message.status);
    }
    return obj;
  },
};

function createBaseEditProductPurchaseSuggestionResponse(): EditProductPurchaseSuggestionResponse {
  return {};
}

export const EditProductPurchaseSuggestionResponse: MessageFns<EditProductPurchaseSuggestionResponse> = {
  encode(_: EditProductPurchaseSuggestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditProductPurchaseSuggestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditProductPurchaseSuggestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EditProductPurchaseSuggestionResponse {
    return {};
  },

  toJSON(_: EditProductPurchaseSuggestionResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseToggleProductPurchaseSuggestionArchivedRequest(): ToggleProductPurchaseSuggestionArchivedRequest {
  return { productPurchaseSuggestionId: "", productPurchaseId: undefined, isArchived: false, archiveReason: "" };
}

export const ToggleProductPurchaseSuggestionArchivedRequest: MessageFns<
  ToggleProductPurchaseSuggestionArchivedRequest
> = {
  encode(
    message: ToggleProductPurchaseSuggestionArchivedRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.productPurchaseSuggestionId !== "") {
      writer.uint32(10).string(message.productPurchaseSuggestionId);
    }
    if (message.productPurchaseId !== undefined) {
      writer.uint32(18).string(message.productPurchaseId);
    }
    if (message.isArchived !== false) {
      writer.uint32(24).bool(message.isArchived);
    }
    if (message.archiveReason !== "") {
      writer.uint32(34).string(message.archiveReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToggleProductPurchaseSuggestionArchivedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToggleProductPurchaseSuggestionArchivedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productPurchaseSuggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productPurchaseId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isArchived = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.archiveReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToggleProductPurchaseSuggestionArchivedRequest {
    return {
      productPurchaseSuggestionId: isSet(object.productPurchaseSuggestionId)
        ? globalThis.String(object.productPurchaseSuggestionId)
        : "",
      productPurchaseId: isSet(object.productPurchaseId) ? globalThis.String(object.productPurchaseId) : undefined,
      isArchived: isSet(object.isArchived) ? globalThis.Boolean(object.isArchived) : false,
      archiveReason: isSet(object.archiveReason) ? globalThis.String(object.archiveReason) : "",
    };
  },

  toJSON(message: ToggleProductPurchaseSuggestionArchivedRequest): unknown {
    const obj: any = {};
    if (message.productPurchaseSuggestionId !== "") {
      obj.productPurchaseSuggestionId = message.productPurchaseSuggestionId;
    }
    if (message.productPurchaseId !== undefined) {
      obj.productPurchaseId = message.productPurchaseId;
    }
    if (message.isArchived !== false) {
      obj.isArchived = message.isArchived;
    }
    if (message.archiveReason !== "") {
      obj.archiveReason = message.archiveReason;
    }
    return obj;
  },
};

function createBaseToggleProductPurchaseSuggestionArchivedResponse(): ToggleProductPurchaseSuggestionArchivedResponse {
  return {};
}

export const ToggleProductPurchaseSuggestionArchivedResponse: MessageFns<
  ToggleProductPurchaseSuggestionArchivedResponse
> = {
  encode(_: ToggleProductPurchaseSuggestionArchivedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToggleProductPurchaseSuggestionArchivedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToggleProductPurchaseSuggestionArchivedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ToggleProductPurchaseSuggestionArchivedResponse {
    return {};
  },

  toJSON(_: ToggleProductPurchaseSuggestionArchivedResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseDeleteOrderSuggestionsRequest(): DeleteOrderSuggestionsRequest {
  return { orderSuggestionIds: [] };
}

export const DeleteOrderSuggestionsRequest: MessageFns<DeleteOrderSuggestionsRequest> = {
  encode(message: DeleteOrderSuggestionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orderSuggestionIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteOrderSuggestionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrderSuggestionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestionIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteOrderSuggestionsRequest {
    return {
      orderSuggestionIds: globalThis.Array.isArray(object?.orderSuggestionIds)
        ? object.orderSuggestionIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeleteOrderSuggestionsRequest): unknown {
    const obj: any = {};
    if (message.orderSuggestionIds?.length) {
      obj.orderSuggestionIds = message.orderSuggestionIds;
    }
    return obj;
  },
};

function createBaseDeleteOrderSuggestionsResponse(): DeleteOrderSuggestionsResponse {
  return {};
}

export const DeleteOrderSuggestionsResponse: MessageFns<DeleteOrderSuggestionsResponse> = {
  encode(_: DeleteOrderSuggestionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteOrderSuggestionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrderSuggestionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteOrderSuggestionsResponse {
    return {};
  },

  toJSON(_: DeleteOrderSuggestionsResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseRemoveProductSuggestionFromOrderSuggestionRequest(): RemoveProductSuggestionFromOrderSuggestionRequest {
  return { orderSuggestionId: "", productSuggestionId: undefined, productPurchaseId: undefined };
}

export const RemoveProductSuggestionFromOrderSuggestionRequest: MessageFns<
  RemoveProductSuggestionFromOrderSuggestionRequest
> = {
  encode(
    message: RemoveProductSuggestionFromOrderSuggestionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.orderSuggestionId !== "") {
      writer.uint32(10).string(message.orderSuggestionId);
    }
    if (message.productSuggestionId !== undefined) {
      writer.uint32(18).string(message.productSuggestionId);
    }
    if (message.productPurchaseId !== undefined) {
      writer.uint32(26).string(message.productPurchaseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveProductSuggestionFromOrderSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveProductSuggestionFromOrderSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productSuggestionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productPurchaseId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveProductSuggestionFromOrderSuggestionRequest {
    return {
      orderSuggestionId: isSet(object.orderSuggestionId) ? globalThis.String(object.orderSuggestionId) : "",
      productSuggestionId: isSet(object.productSuggestionId)
        ? globalThis.String(object.productSuggestionId)
        : undefined,
      productPurchaseId: isSet(object.productPurchaseId) ? globalThis.String(object.productPurchaseId) : undefined,
    };
  },

  toJSON(message: RemoveProductSuggestionFromOrderSuggestionRequest): unknown {
    const obj: any = {};
    if (message.orderSuggestionId !== "") {
      obj.orderSuggestionId = message.orderSuggestionId;
    }
    if (message.productSuggestionId !== undefined) {
      obj.productSuggestionId = message.productSuggestionId;
    }
    if (message.productPurchaseId !== undefined) {
      obj.productPurchaseId = message.productPurchaseId;
    }
    return obj;
  },
};

function createBaseRemoveProductSuggestionFromOrderSuggestionResponse(): RemoveProductSuggestionFromOrderSuggestionResponse {
  return {};
}

export const RemoveProductSuggestionFromOrderSuggestionResponse: MessageFns<
  RemoveProductSuggestionFromOrderSuggestionResponse
> = {
  encode(
    _: RemoveProductSuggestionFromOrderSuggestionResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveProductSuggestionFromOrderSuggestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveProductSuggestionFromOrderSuggestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveProductSuggestionFromOrderSuggestionResponse {
    return {};
  },

  toJSON(_: RemoveProductSuggestionFromOrderSuggestionResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseAddProductSuggestionToOrderSuggestionRequest(): AddProductSuggestionToOrderSuggestionRequest {
  return { orderSuggestionId: "", productId: "", size: "", color: "" };
}

export const AddProductSuggestionToOrderSuggestionRequest: MessageFns<AddProductSuggestionToOrderSuggestionRequest> = {
  encode(
    message: AddProductSuggestionToOrderSuggestionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.orderSuggestionId !== "") {
      writer.uint32(10).string(message.orderSuggestionId);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.size !== "") {
      writer.uint32(26).string(message.size);
    }
    if (message.color !== "") {
      writer.uint32(34).string(message.color);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddProductSuggestionToOrderSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddProductSuggestionToOrderSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.size = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.color = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddProductSuggestionToOrderSuggestionRequest {
    return {
      orderSuggestionId: isSet(object.orderSuggestionId) ? globalThis.String(object.orderSuggestionId) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      size: isSet(object.size) ? globalThis.String(object.size) : "",
      color: isSet(object.color) ? globalThis.String(object.color) : "",
    };
  },

  toJSON(message: AddProductSuggestionToOrderSuggestionRequest): unknown {
    const obj: any = {};
    if (message.orderSuggestionId !== "") {
      obj.orderSuggestionId = message.orderSuggestionId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.size !== "") {
      obj.size = message.size;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    return obj;
  },
};

function createBaseAddProductSuggestionToOrderSuggestionResponse(): AddProductSuggestionToOrderSuggestionResponse {
  return {};
}

export const AddProductSuggestionToOrderSuggestionResponse: MessageFns<AddProductSuggestionToOrderSuggestionResponse> =
  {
    encode(_: AddProductSuggestionToOrderSuggestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): AddProductSuggestionToOrderSuggestionResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAddProductSuggestionToOrderSuggestionResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): AddProductSuggestionToOrderSuggestionResponse {
      return {};
    },

    toJSON(_: AddProductSuggestionToOrderSuggestionResponse): unknown {
      const obj: any = {};
      return obj;
    },
  };

function createBasePublishDraftSuggestionRequest(): PublishDraftSuggestionRequest {
  return { orderSuggestionId: "" };
}

export const PublishDraftSuggestionRequest: MessageFns<PublishDraftSuggestionRequest> = {
  encode(message: PublishDraftSuggestionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderSuggestionId !== "") {
      writer.uint32(10).string(message.orderSuggestionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishDraftSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishDraftSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishDraftSuggestionRequest {
    return { orderSuggestionId: isSet(object.orderSuggestionId) ? globalThis.String(object.orderSuggestionId) : "" };
  },

  toJSON(message: PublishDraftSuggestionRequest): unknown {
    const obj: any = {};
    if (message.orderSuggestionId !== "") {
      obj.orderSuggestionId = message.orderSuggestionId;
    }
    return obj;
  },
};

function createBasePublishDraftSuggestionResponse(): PublishDraftSuggestionResponse {
  return {};
}

export const PublishDraftSuggestionResponse: MessageFns<PublishDraftSuggestionResponse> = {
  encode(_: PublishDraftSuggestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishDraftSuggestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishDraftSuggestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PublishDraftSuggestionResponse {
    return {};
  },

  toJSON(_: PublishDraftSuggestionResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseUpdateOrderSuggestionStylistNoteRequest(): UpdateOrderSuggestionStylistNoteRequest {
  return { orderSuggestionId: "", stylistNote: undefined };
}

export const UpdateOrderSuggestionStylistNoteRequest: MessageFns<UpdateOrderSuggestionStylistNoteRequest> = {
  encode(message: UpdateOrderSuggestionStylistNoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderSuggestionId !== "") {
      writer.uint32(10).string(message.orderSuggestionId);
    }
    if (message.stylistNote !== undefined) {
      writer.uint32(18).string(message.stylistNote);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderSuggestionStylistNoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderSuggestionStylistNoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stylistNote = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOrderSuggestionStylistNoteRequest {
    return {
      orderSuggestionId: isSet(object.orderSuggestionId) ? globalThis.String(object.orderSuggestionId) : "",
      stylistNote: isSet(object.stylistNote) ? globalThis.String(object.stylistNote) : undefined,
    };
  },

  toJSON(message: UpdateOrderSuggestionStylistNoteRequest): unknown {
    const obj: any = {};
    if (message.orderSuggestionId !== "") {
      obj.orderSuggestionId = message.orderSuggestionId;
    }
    if (message.stylistNote !== undefined) {
      obj.stylistNote = message.stylistNote;
    }
    return obj;
  },
};

function createBaseUpdateOrderSuggestionStylistNoteResponse(): UpdateOrderSuggestionStylistNoteResponse {
  return {};
}

export const UpdateOrderSuggestionStylistNoteResponse: MessageFns<UpdateOrderSuggestionStylistNoteResponse> = {
  encode(_: UpdateOrderSuggestionStylistNoteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderSuggestionStylistNoteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderSuggestionStylistNoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateOrderSuggestionStylistNoteResponse {
    return {};
  },

  toJSON(_: UpdateOrderSuggestionStylistNoteResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseUpdateProductPurchaseRequest(): UpdateProductPurchaseRequest {
  return { productPurchaseId: "", refundStatus: undefined, paymentStatus: undefined, stripePaymentId: undefined };
}

export const UpdateProductPurchaseRequest: MessageFns<UpdateProductPurchaseRequest> = {
  encode(message: UpdateProductPurchaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productPurchaseId !== "") {
      writer.uint32(10).string(message.productPurchaseId);
    }
    if (message.refundStatus !== undefined) {
      writer.uint32(16).int32(message.refundStatus);
    }
    if (message.paymentStatus !== undefined) {
      writer.uint32(24).int32(message.paymentStatus);
    }
    if (message.stripePaymentId !== undefined) {
      writer.uint32(34).string(message.stripePaymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductPurchaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductPurchaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productPurchaseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.refundStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.paymentStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stripePaymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductPurchaseRequest {
    return {
      productPurchaseId: isSet(object.productPurchaseId) ? globalThis.String(object.productPurchaseId) : "",
      refundStatus: isSet(object.refundStatus) ? refundStatusFromJSON(object.refundStatus) : undefined,
      paymentStatus: isSet(object.paymentStatus) ? paymentStatusFromJSON(object.paymentStatus) : undefined,
      stripePaymentId: isSet(object.stripePaymentId) ? globalThis.String(object.stripePaymentId) : undefined,
    };
  },

  toJSON(message: UpdateProductPurchaseRequest): unknown {
    const obj: any = {};
    if (message.productPurchaseId !== "") {
      obj.productPurchaseId = message.productPurchaseId;
    }
    if (message.refundStatus !== undefined) {
      obj.refundStatus = refundStatusToJSON(message.refundStatus);
    }
    if (message.paymentStatus !== undefined) {
      obj.paymentStatus = paymentStatusToJSON(message.paymentStatus);
    }
    if (message.stripePaymentId !== undefined) {
      obj.stripePaymentId = message.stripePaymentId;
    }
    return obj;
  },
};

function createBaseUpdateProductPurchaseResponse(): UpdateProductPurchaseResponse {
  return { productPurchase: undefined };
}

export const UpdateProductPurchaseResponse: MessageFns<UpdateProductPurchaseResponse> = {
  encode(message: UpdateProductPurchaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productPurchase !== undefined) {
      ProductPurchase.encode(message.productPurchase, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductPurchaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductPurchaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productPurchase = ProductPurchase.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductPurchaseResponse {
    return {
      productPurchase: isSet(object.productPurchase) ? ProductPurchase.fromJSON(object.productPurchase) : undefined,
    };
  },

  toJSON(message: UpdateProductPurchaseResponse): unknown {
    const obj: any = {};
    if (message.productPurchase !== undefined) {
      obj.productPurchase = ProductPurchase.toJSON(message.productPurchase);
    }
    return obj;
  },
};

function createBaseGetShipmentIntentInfoRequest(): GetShipmentIntentInfoRequest {
  return {};
}

export const GetShipmentIntentInfoRequest: MessageFns<GetShipmentIntentInfoRequest> = {
  encode(_: GetShipmentIntentInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetShipmentIntentInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetShipmentIntentInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetShipmentIntentInfoRequest {
    return {};
  },

  toJSON(_: GetShipmentIntentInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetShipmentIntentInfoResponse(): GetShipmentIntentInfoResponse {
  return { email: "", creditCard: undefined };
}

export const GetShipmentIntentInfoResponse: MessageFns<GetShipmentIntentInfoResponse> = {
  encode(message: GetShipmentIntentInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.creditCard !== undefined) {
      Card.encode(message.creditCard, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetShipmentIntentInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetShipmentIntentInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creditCard = Card.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetShipmentIntentInfoResponse {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      creditCard: isSet(object.creditCard) ? Card.fromJSON(object.creditCard) : undefined,
    };
  },

  toJSON(message: GetShipmentIntentInfoResponse): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.creditCard !== undefined) {
      obj.creditCard = Card.toJSON(message.creditCard);
    }
    return obj;
  },
};

function createBaseSetSuggestionArchivedRequest(): SetSuggestionArchivedRequest {
  return { orderSuggestionId: "", isArchived: false };
}

export const SetSuggestionArchivedRequest: MessageFns<SetSuggestionArchivedRequest> = {
  encode(message: SetSuggestionArchivedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderSuggestionId !== "") {
      writer.uint32(10).string(message.orderSuggestionId);
    }
    if (message.isArchived !== false) {
      writer.uint32(16).bool(message.isArchived);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetSuggestionArchivedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetSuggestionArchivedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isArchived = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetSuggestionArchivedRequest {
    return {
      orderSuggestionId: isSet(object.orderSuggestionId) ? globalThis.String(object.orderSuggestionId) : "",
      isArchived: isSet(object.isArchived) ? globalThis.Boolean(object.isArchived) : false,
    };
  },

  toJSON(message: SetSuggestionArchivedRequest): unknown {
    const obj: any = {};
    if (message.orderSuggestionId !== "") {
      obj.orderSuggestionId = message.orderSuggestionId;
    }
    if (message.isArchived !== false) {
      obj.isArchived = message.isArchived;
    }
    return obj;
  },
};

function createBaseSetSuggestionArchivedResponse(): SetSuggestionArchivedResponse {
  return { message: "" };
}

export const SetSuggestionArchivedResponse: MessageFns<SetSuggestionArchivedResponse> = {
  encode(message: SetSuggestionArchivedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetSuggestionArchivedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetSuggestionArchivedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetSuggestionArchivedResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: SetSuggestionArchivedResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseReplaceOrderSuggestionRequest(): ReplaceOrderSuggestionRequest {
  return { orderSuggestionId: "", productPurchases: [] };
}

export const ReplaceOrderSuggestionRequest: MessageFns<ReplaceOrderSuggestionRequest> = {
  encode(message: ReplaceOrderSuggestionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderSuggestionId !== "") {
      writer.uint32(10).string(message.orderSuggestionId);
    }
    for (const v of message.productPurchases) {
      NakedProductPurchaseSuggestion.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplaceOrderSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplaceOrderSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productPurchases.push(NakedProductPurchaseSuggestion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplaceOrderSuggestionRequest {
    return {
      orderSuggestionId: isSet(object.orderSuggestionId) ? globalThis.String(object.orderSuggestionId) : "",
      productPurchases: globalThis.Array.isArray(object?.productPurchases)
        ? object.productPurchases.map((e: any) => NakedProductPurchaseSuggestion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReplaceOrderSuggestionRequest): unknown {
    const obj: any = {};
    if (message.orderSuggestionId !== "") {
      obj.orderSuggestionId = message.orderSuggestionId;
    }
    if (message.productPurchases?.length) {
      obj.productPurchases = message.productPurchases.map((e) => NakedProductPurchaseSuggestion.toJSON(e));
    }
    return obj;
  },
};

function createBaseReplaceOrderSuggestionResponse(): ReplaceOrderSuggestionResponse {
  return { orderSuggestion: undefined };
}

export const ReplaceOrderSuggestionResponse: MessageFns<ReplaceOrderSuggestionResponse> = {
  encode(message: ReplaceOrderSuggestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderSuggestion !== undefined) {
      PopulatedOrderSuggestion.encode(message.orderSuggestion, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplaceOrderSuggestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplaceOrderSuggestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestion = PopulatedOrderSuggestion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplaceOrderSuggestionResponse {
    return {
      orderSuggestion: isSet(object.orderSuggestion)
        ? PopulatedOrderSuggestion.fromJSON(object.orderSuggestion)
        : undefined,
    };
  },

  toJSON(message: ReplaceOrderSuggestionResponse): unknown {
    const obj: any = {};
    if (message.orderSuggestion !== undefined) {
      obj.orderSuggestion = PopulatedOrderSuggestion.toJSON(message.orderSuggestion);
    }
    return obj;
  },
};

function createBaseFinalizeOrderSuggestionRequest(): FinalizeOrderSuggestionRequest {
  return { orderSuggestionId: "" };
}

export const FinalizeOrderSuggestionRequest: MessageFns<FinalizeOrderSuggestionRequest> = {
  encode(message: FinalizeOrderSuggestionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderSuggestionId !== "") {
      writer.uint32(10).string(message.orderSuggestionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeOrderSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeOrderSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeOrderSuggestionRequest {
    return { orderSuggestionId: isSet(object.orderSuggestionId) ? globalThis.String(object.orderSuggestionId) : "" };
  },

  toJSON(message: FinalizeOrderSuggestionRequest): unknown {
    const obj: any = {};
    if (message.orderSuggestionId !== "") {
      obj.orderSuggestionId = message.orderSuggestionId;
    }
    return obj;
  },
};

function createBaseFinalizeOrderSuggestionResponse(): FinalizeOrderSuggestionResponse {
  return { orderSuggestion: undefined };
}

export const FinalizeOrderSuggestionResponse: MessageFns<FinalizeOrderSuggestionResponse> = {
  encode(message: FinalizeOrderSuggestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderSuggestion !== undefined) {
      PopulatedOrderSuggestion.encode(message.orderSuggestion, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeOrderSuggestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeOrderSuggestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestion = PopulatedOrderSuggestion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeOrderSuggestionResponse {
    return {
      orderSuggestion: isSet(object.orderSuggestion)
        ? PopulatedOrderSuggestion.fromJSON(object.orderSuggestion)
        : undefined,
    };
  },

  toJSON(message: FinalizeOrderSuggestionResponse): unknown {
    const obj: any = {};
    if (message.orderSuggestion !== undefined) {
      obj.orderSuggestion = PopulatedOrderSuggestion.toJSON(message.orderSuggestion);
    }
    return obj;
  },
};

function createBaseDeleteShipmentRequest(): DeleteShipmentRequest {
  return { shipmentId: "" };
}

export const DeleteShipmentRequest: MessageFns<DeleteShipmentRequest> = {
  encode(message: DeleteShipmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shipmentId !== "") {
      writer.uint32(10).string(message.shipmentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteShipmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteShipmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shipmentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteShipmentRequest {
    return { shipmentId: isSet(object.shipmentId) ? globalThis.String(object.shipmentId) : "" };
  },

  toJSON(message: DeleteShipmentRequest): unknown {
    const obj: any = {};
    if (message.shipmentId !== "") {
      obj.shipmentId = message.shipmentId;
    }
    return obj;
  },
};

function createBaseSubmitProductPurchaseFeedbackRequest(): SubmitProductPurchaseFeedbackRequest {
  return { productPurchaseId: "", categories: [], feedback: undefined, isRefundRequested: undefined };
}

export const SubmitProductPurchaseFeedbackRequest: MessageFns<SubmitProductPurchaseFeedbackRequest> = {
  encode(message: SubmitProductPurchaseFeedbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productPurchaseId !== "") {
      writer.uint32(10).string(message.productPurchaseId);
    }
    writer.uint32(18).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.join();
    if (message.feedback !== undefined) {
      writer.uint32(26).string(message.feedback);
    }
    if (message.isRefundRequested !== undefined) {
      writer.uint32(32).bool(message.isRefundRequested);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitProductPurchaseFeedbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitProductPurchaseFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productPurchaseId = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.categories.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.feedback = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isRefundRequested = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitProductPurchaseFeedbackRequest {
    return {
      productPurchaseId: isSet(object.productPurchaseId) ? globalThis.String(object.productPurchaseId) : "",
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => productPurchaseFeedbackCategoryFromJSON(e))
        : [],
      feedback: isSet(object.feedback) ? globalThis.String(object.feedback) : undefined,
      isRefundRequested: isSet(object.isRefundRequested) ? globalThis.Boolean(object.isRefundRequested) : undefined,
    };
  },

  toJSON(message: SubmitProductPurchaseFeedbackRequest): unknown {
    const obj: any = {};
    if (message.productPurchaseId !== "") {
      obj.productPurchaseId = message.productPurchaseId;
    }
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => productPurchaseFeedbackCategoryToJSON(e));
    }
    if (message.feedback !== undefined) {
      obj.feedback = message.feedback;
    }
    if (message.isRefundRequested !== undefined) {
      obj.isRefundRequested = message.isRefundRequested;
    }
    return obj;
  },
};

function createBaseSubmitProductPurchaseSuggestionFeedbackRequest(): SubmitProductPurchaseSuggestionFeedbackRequest {
  return { productPurchaseId: "", note: undefined };
}

export const SubmitProductPurchaseSuggestionFeedbackRequest: MessageFns<
  SubmitProductPurchaseSuggestionFeedbackRequest
> = {
  encode(
    message: SubmitProductPurchaseSuggestionFeedbackRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.productPurchaseId !== "") {
      writer.uint32(10).string(message.productPurchaseId);
    }
    if (message.note !== undefined) {
      writer.uint32(18).string(message.note);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitProductPurchaseSuggestionFeedbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitProductPurchaseSuggestionFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productPurchaseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.note = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitProductPurchaseSuggestionFeedbackRequest {
    return {
      productPurchaseId: isSet(object.productPurchaseId) ? globalThis.String(object.productPurchaseId) : "",
      note: isSet(object.note) ? globalThis.String(object.note) : undefined,
    };
  },

  toJSON(message: SubmitProductPurchaseSuggestionFeedbackRequest): unknown {
    const obj: any = {};
    if (message.productPurchaseId !== "") {
      obj.productPurchaseId = message.productPurchaseId;
    }
    if (message.note !== undefined) {
      obj.note = message.note;
    }
    return obj;
  },
};

function createBaseSubmitProductPurchaseSuggestionFeedbackResponse(): SubmitProductPurchaseSuggestionFeedbackResponse {
  return { productPurchaseSuggestion: undefined };
}

export const SubmitProductPurchaseSuggestionFeedbackResponse: MessageFns<
  SubmitProductPurchaseSuggestionFeedbackResponse
> = {
  encode(
    message: SubmitProductPurchaseSuggestionFeedbackResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.productPurchaseSuggestion !== undefined) {
      ProductPurchaseSuggestion.encode(message.productPurchaseSuggestion, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitProductPurchaseSuggestionFeedbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitProductPurchaseSuggestionFeedbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productPurchaseSuggestion = ProductPurchaseSuggestion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitProductPurchaseSuggestionFeedbackResponse {
    return {
      productPurchaseSuggestion: isSet(object.productPurchaseSuggestion)
        ? ProductPurchaseSuggestion.fromJSON(object.productPurchaseSuggestion)
        : undefined,
    };
  },

  toJSON(message: SubmitProductPurchaseSuggestionFeedbackResponse): unknown {
    const obj: any = {};
    if (message.productPurchaseSuggestion !== undefined) {
      obj.productPurchaseSuggestion = ProductPurchaseSuggestion.toJSON(message.productPurchaseSuggestion);
    }
    return obj;
  },
};

function createBaseUpdateShippingInformationRequest(): UpdateShippingInformationRequest {
  return {
    shipmentId: "",
    brandOrderNumber: undefined,
    trackingNumber: undefined,
    trackingUrl: undefined,
    expectedDeliveryDateStart: undefined,
    expectedDeliveryDateEnd: undefined,
    status: 0,
    email: undefined,
  };
}

export const UpdateShippingInformationRequest: MessageFns<UpdateShippingInformationRequest> = {
  encode(message: UpdateShippingInformationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shipmentId !== "") {
      writer.uint32(10).string(message.shipmentId);
    }
    if (message.brandOrderNumber !== undefined) {
      writer.uint32(18).string(message.brandOrderNumber);
    }
    if (message.trackingNumber !== undefined) {
      writer.uint32(26).string(message.trackingNumber);
    }
    if (message.trackingUrl !== undefined) {
      writer.uint32(34).string(message.trackingUrl);
    }
    if (message.expectedDeliveryDateStart !== undefined) {
      writer.uint32(40).int64(message.expectedDeliveryDateStart);
    }
    if (message.expectedDeliveryDateEnd !== undefined) {
      writer.uint32(48).int64(message.expectedDeliveryDateEnd);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.email !== undefined) {
      writer.uint32(66).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateShippingInformationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateShippingInformationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shipmentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.brandOrderNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trackingNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.trackingUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expectedDeliveryDateStart = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expectedDeliveryDateEnd = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateShippingInformationRequest {
    return {
      shipmentId: isSet(object.shipmentId) ? globalThis.String(object.shipmentId) : "",
      brandOrderNumber: isSet(object.brandOrderNumber) ? globalThis.String(object.brandOrderNumber) : undefined,
      trackingNumber: isSet(object.trackingNumber) ? globalThis.String(object.trackingNumber) : undefined,
      trackingUrl: isSet(object.trackingUrl) ? globalThis.String(object.trackingUrl) : undefined,
      expectedDeliveryDateStart: isSet(object.expectedDeliveryDateStart)
        ? globalThis.Number(object.expectedDeliveryDateStart)
        : undefined,
      expectedDeliveryDateEnd: isSet(object.expectedDeliveryDateEnd)
        ? globalThis.Number(object.expectedDeliveryDateEnd)
        : undefined,
      status: isSet(object.status) ? shipmentStatusFromJSON(object.status) : 0,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
    };
  },

  toJSON(message: UpdateShippingInformationRequest): unknown {
    const obj: any = {};
    if (message.shipmentId !== "") {
      obj.shipmentId = message.shipmentId;
    }
    if (message.brandOrderNumber !== undefined) {
      obj.brandOrderNumber = message.brandOrderNumber;
    }
    if (message.trackingNumber !== undefined) {
      obj.trackingNumber = message.trackingNumber;
    }
    if (message.trackingUrl !== undefined) {
      obj.trackingUrl = message.trackingUrl;
    }
    if (message.expectedDeliveryDateStart !== undefined) {
      obj.expectedDeliveryDateStart = Math.round(message.expectedDeliveryDateStart);
    }
    if (message.expectedDeliveryDateEnd !== undefined) {
      obj.expectedDeliveryDateEnd = Math.round(message.expectedDeliveryDateEnd);
    }
    if (message.status !== 0) {
      obj.status = shipmentStatusToJSON(message.status);
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    return obj;
  },
};

function createBaseNakedProductPurchase(): NakedProductPurchase {
  return { productId: "", size: "", price: 0, originalPrice: undefined, isRefundable: undefined, color: "" };
}

export const NakedProductPurchase: MessageFns<NakedProductPurchase> = {
  encode(message: NakedProductPurchase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.size !== "") {
      writer.uint32(18).string(message.size);
    }
    if (message.price !== 0) {
      writer.uint32(29).float(message.price);
    }
    if (message.originalPrice !== undefined) {
      writer.uint32(37).float(message.originalPrice);
    }
    if (message.isRefundable !== undefined) {
      writer.uint32(40).bool(message.isRefundable);
    }
    if (message.color !== "") {
      writer.uint32(50).string(message.color);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NakedProductPurchase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNakedProductPurchase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.size = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isRefundable = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.color = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NakedProductPurchase {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      size: isSet(object.size) ? globalThis.String(object.size) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : undefined,
      isRefundable: isSet(object.isRefundable) ? globalThis.Boolean(object.isRefundable) : undefined,
      color: isSet(object.color) ? globalThis.String(object.color) : "",
    };
  },

  toJSON(message: NakedProductPurchase): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.size !== "") {
      obj.size = message.size;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = message.originalPrice;
    }
    if (message.isRefundable !== undefined) {
      obj.isRefundable = message.isRefundable;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    return obj;
  },
};

function createBaseAddShipmentToOrderSuggestionRequest(): AddShipmentToOrderSuggestionRequest {
  return {
    orderSuggestionId: "",
    brandId: "",
    productPurchases: [],
    brandOrderNumber: undefined,
    trackingNumber: undefined,
    trackingUrl: undefined,
    expectedDeliveryDateStart: undefined,
    expectedDeliveryDateEnd: undefined,
    shipmentId: undefined,
    creditCardCardIdToLock: undefined,
    email: undefined,
    totalPrice: 0,
    shippingCost: undefined,
  };
}

export const AddShipmentToOrderSuggestionRequest: MessageFns<AddShipmentToOrderSuggestionRequest> = {
  encode(message: AddShipmentToOrderSuggestionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderSuggestionId !== "") {
      writer.uint32(10).string(message.orderSuggestionId);
    }
    if (message.brandId !== "") {
      writer.uint32(18).string(message.brandId);
    }
    for (const v of message.productPurchases) {
      NakedProductPurchase.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.brandOrderNumber !== undefined) {
      writer.uint32(34).string(message.brandOrderNumber);
    }
    if (message.trackingNumber !== undefined) {
      writer.uint32(42).string(message.trackingNumber);
    }
    if (message.trackingUrl !== undefined) {
      writer.uint32(50).string(message.trackingUrl);
    }
    if (message.expectedDeliveryDateStart !== undefined) {
      writer.uint32(56).int64(message.expectedDeliveryDateStart);
    }
    if (message.expectedDeliveryDateEnd !== undefined) {
      writer.uint32(64).int64(message.expectedDeliveryDateEnd);
    }
    if (message.shipmentId !== undefined) {
      writer.uint32(74).string(message.shipmentId);
    }
    if (message.creditCardCardIdToLock !== undefined) {
      writer.uint32(82).string(message.creditCardCardIdToLock);
    }
    if (message.email !== undefined) {
      writer.uint32(90).string(message.email);
    }
    if (message.totalPrice !== 0) {
      writer.uint32(101).float(message.totalPrice);
    }
    if (message.shippingCost !== undefined) {
      writer.uint32(109).float(message.shippingCost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddShipmentToOrderSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddShipmentToOrderSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.brandId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productPurchases.push(NakedProductPurchase.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.brandOrderNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.trackingNumber = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trackingUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expectedDeliveryDateStart = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.expectedDeliveryDateEnd = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.shipmentId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.creditCardCardIdToLock = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.totalPrice = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.shippingCost = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddShipmentToOrderSuggestionRequest {
    return {
      orderSuggestionId: isSet(object.orderSuggestionId) ? globalThis.String(object.orderSuggestionId) : "",
      brandId: isSet(object.brandId) ? globalThis.String(object.brandId) : "",
      productPurchases: globalThis.Array.isArray(object?.productPurchases)
        ? object.productPurchases.map((e: any) => NakedProductPurchase.fromJSON(e))
        : [],
      brandOrderNumber: isSet(object.brandOrderNumber) ? globalThis.String(object.brandOrderNumber) : undefined,
      trackingNumber: isSet(object.trackingNumber) ? globalThis.String(object.trackingNumber) : undefined,
      trackingUrl: isSet(object.trackingUrl) ? globalThis.String(object.trackingUrl) : undefined,
      expectedDeliveryDateStart: isSet(object.expectedDeliveryDateStart)
        ? globalThis.Number(object.expectedDeliveryDateStart)
        : undefined,
      expectedDeliveryDateEnd: isSet(object.expectedDeliveryDateEnd)
        ? globalThis.Number(object.expectedDeliveryDateEnd)
        : undefined,
      shipmentId: isSet(object.shipmentId) ? globalThis.String(object.shipmentId) : undefined,
      creditCardCardIdToLock: isSet(object.creditCardCardIdToLock)
        ? globalThis.String(object.creditCardCardIdToLock)
        : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      totalPrice: isSet(object.totalPrice) ? globalThis.Number(object.totalPrice) : 0,
      shippingCost: isSet(object.shippingCost) ? globalThis.Number(object.shippingCost) : undefined,
    };
  },

  toJSON(message: AddShipmentToOrderSuggestionRequest): unknown {
    const obj: any = {};
    if (message.orderSuggestionId !== "") {
      obj.orderSuggestionId = message.orderSuggestionId;
    }
    if (message.brandId !== "") {
      obj.brandId = message.brandId;
    }
    if (message.productPurchases?.length) {
      obj.productPurchases = message.productPurchases.map((e) => NakedProductPurchase.toJSON(e));
    }
    if (message.brandOrderNumber !== undefined) {
      obj.brandOrderNumber = message.brandOrderNumber;
    }
    if (message.trackingNumber !== undefined) {
      obj.trackingNumber = message.trackingNumber;
    }
    if (message.trackingUrl !== undefined) {
      obj.trackingUrl = message.trackingUrl;
    }
    if (message.expectedDeliveryDateStart !== undefined) {
      obj.expectedDeliveryDateStart = Math.round(message.expectedDeliveryDateStart);
    }
    if (message.expectedDeliveryDateEnd !== undefined) {
      obj.expectedDeliveryDateEnd = Math.round(message.expectedDeliveryDateEnd);
    }
    if (message.shipmentId !== undefined) {
      obj.shipmentId = message.shipmentId;
    }
    if (message.creditCardCardIdToLock !== undefined) {
      obj.creditCardCardIdToLock = message.creditCardCardIdToLock;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.totalPrice !== 0) {
      obj.totalPrice = message.totalPrice;
    }
    if (message.shippingCost !== undefined) {
      obj.shippingCost = message.shippingCost;
    }
    return obj;
  },
};

function createBaseAddShipmentToOrderSuggestionResponse(): AddShipmentToOrderSuggestionResponse {
  return { shipmentId: "" };
}

export const AddShipmentToOrderSuggestionResponse: MessageFns<AddShipmentToOrderSuggestionResponse> = {
  encode(message: AddShipmentToOrderSuggestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shipmentId !== "") {
      writer.uint32(10).string(message.shipmentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddShipmentToOrderSuggestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddShipmentToOrderSuggestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shipmentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddShipmentToOrderSuggestionResponse {
    return { shipmentId: isSet(object.shipmentId) ? globalThis.String(object.shipmentId) : "" };
  },

  toJSON(message: AddShipmentToOrderSuggestionResponse): unknown {
    const obj: any = {};
    if (message.shipmentId !== "") {
      obj.shipmentId = message.shipmentId;
    }
    return obj;
  },
};

function createBaseSubmitOrderSuggestionUserResponseRequest(): SubmitOrderSuggestionUserResponseRequest {
  return { orderSuggestionId: "", acceptedProductPurchaseIds: [] };
}

export const SubmitOrderSuggestionUserResponseRequest: MessageFns<SubmitOrderSuggestionUserResponseRequest> = {
  encode(message: SubmitOrderSuggestionUserResponseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderSuggestionId !== "") {
      writer.uint32(10).string(message.orderSuggestionId);
    }
    for (const v of message.acceptedProductPurchaseIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitOrderSuggestionUserResponseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitOrderSuggestionUserResponseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderSuggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.acceptedProductPurchaseIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitOrderSuggestionUserResponseRequest {
    return {
      orderSuggestionId: isSet(object.orderSuggestionId) ? globalThis.String(object.orderSuggestionId) : "",
      acceptedProductPurchaseIds: globalThis.Array.isArray(object?.acceptedProductPurchaseIds)
        ? object.acceptedProductPurchaseIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SubmitOrderSuggestionUserResponseRequest): unknown {
    const obj: any = {};
    if (message.orderSuggestionId !== "") {
      obj.orderSuggestionId = message.orderSuggestionId;
    }
    if (message.acceptedProductPurchaseIds?.length) {
      obj.acceptedProductPurchaseIds = message.acceptedProductPurchaseIds;
    }
    return obj;
  },
};

function createBaseNakedProductPurchaseSuggestion(): NakedProductPurchaseSuggestion {
  return { productId: "", size: "", price: 0, originalPrice: undefined, isRefundable: undefined, color: "" };
}

export const NakedProductPurchaseSuggestion: MessageFns<NakedProductPurchaseSuggestion> = {
  encode(message: NakedProductPurchaseSuggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.size !== "") {
      writer.uint32(18).string(message.size);
    }
    if (message.price !== 0) {
      writer.uint32(29).float(message.price);
    }
    if (message.originalPrice !== undefined) {
      writer.uint32(37).float(message.originalPrice);
    }
    if (message.isRefundable !== undefined) {
      writer.uint32(40).bool(message.isRefundable);
    }
    if (message.color !== "") {
      writer.uint32(50).string(message.color);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NakedProductPurchaseSuggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNakedProductPurchaseSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.size = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isRefundable = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.color = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NakedProductPurchaseSuggestion {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      size: isSet(object.size) ? globalThis.String(object.size) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : undefined,
      isRefundable: isSet(object.isRefundable) ? globalThis.Boolean(object.isRefundable) : undefined,
      color: isSet(object.color) ? globalThis.String(object.color) : "",
    };
  },

  toJSON(message: NakedProductPurchaseSuggestion): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.size !== "") {
      obj.size = message.size;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = message.originalPrice;
    }
    if (message.isRefundable !== undefined) {
      obj.isRefundable = message.isRefundable;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    return obj;
  },
};

function createBaseCreateOrderSuggestionRequest(): CreateOrderSuggestionRequest {
  return { orderId: "", productPurchases: [], isAutoAccepted: false, stylistNote: undefined, isDraft: false };
}

export const CreateOrderSuggestionRequest: MessageFns<CreateOrderSuggestionRequest> = {
  encode(message: CreateOrderSuggestionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    for (const v of message.productPurchases) {
      NakedProductPurchaseSuggestion.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.isAutoAccepted !== false) {
      writer.uint32(24).bool(message.isAutoAccepted);
    }
    if (message.stylistNote !== undefined) {
      writer.uint32(34).string(message.stylistNote);
    }
    if (message.isDraft !== false) {
      writer.uint32(40).bool(message.isDraft);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productPurchases.push(NakedProductPurchaseSuggestion.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isAutoAccepted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stylistNote = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isDraft = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderSuggestionRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      productPurchases: globalThis.Array.isArray(object?.productPurchases)
        ? object.productPurchases.map((e: any) => NakedProductPurchaseSuggestion.fromJSON(e))
        : [],
      isAutoAccepted: isSet(object.isAutoAccepted) ? globalThis.Boolean(object.isAutoAccepted) : false,
      stylistNote: isSet(object.stylistNote) ? globalThis.String(object.stylistNote) : undefined,
      isDraft: isSet(object.isDraft) ? globalThis.Boolean(object.isDraft) : false,
    };
  },

  toJSON(message: CreateOrderSuggestionRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.productPurchases?.length) {
      obj.productPurchases = message.productPurchases.map((e) => NakedProductPurchaseSuggestion.toJSON(e));
    }
    if (message.isAutoAccepted !== false) {
      obj.isAutoAccepted = message.isAutoAccepted;
    }
    if (message.stylistNote !== undefined) {
      obj.stylistNote = message.stylistNote;
    }
    if (message.isDraft !== false) {
      obj.isDraft = message.isDraft;
    }
    return obj;
  },
};

function createBaseCreateOrderSuggestionResponse(): CreateOrderSuggestionResponse {
  return { order: undefined };
}

export const CreateOrderSuggestionResponse: MessageFns<CreateOrderSuggestionResponse> = {
  encode(message: CreateOrderSuggestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      OrderSummary.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderSuggestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderSuggestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = OrderSummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderSuggestionResponse {
    return { order: isSet(object.order) ? OrderSummary.fromJSON(object.order) : undefined };
  },

  toJSON(message: CreateOrderSuggestionResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = OrderSummary.toJSON(message.order);
    }
    return obj;
  },
};

function createBaseSubmitProductPurchaseRequest(): SubmitProductPurchaseRequest {
  return { orderId: "" };
}

export const SubmitProductPurchaseRequest: MessageFns<SubmitProductPurchaseRequest> = {
  encode(message: SubmitProductPurchaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitProductPurchaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitProductPurchaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitProductPurchaseRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: SubmitProductPurchaseRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },
};

function createBaseSubmitProductPurchaseResponse(): SubmitProductPurchaseResponse {
  return { success: false };
}

export const SubmitProductPurchaseResponse: MessageFns<SubmitProductPurchaseResponse> = {
  encode(message: SubmitProductPurchaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitProductPurchaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitProductPurchaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitProductPurchaseResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: SubmitProductPurchaseResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },
};

function createBaseSendShippingEmailRequest(): SendShippingEmailRequest {
  return { orderId: "", trackingNumber: "", trackingUrl: "" };
}

export const SendShippingEmailRequest: MessageFns<SendShippingEmailRequest> = {
  encode(message: SendShippingEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.trackingNumber !== "") {
      writer.uint32(18).string(message.trackingNumber);
    }
    if (message.trackingUrl !== "") {
      writer.uint32(26).string(message.trackingUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendShippingEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendShippingEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trackingNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trackingUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendShippingEmailRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      trackingNumber: isSet(object.trackingNumber) ? globalThis.String(object.trackingNumber) : "",
      trackingUrl: isSet(object.trackingUrl) ? globalThis.String(object.trackingUrl) : "",
    };
  },

  toJSON(message: SendShippingEmailRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.trackingNumber !== "") {
      obj.trackingNumber = message.trackingNumber;
    }
    if (message.trackingUrl !== "") {
      obj.trackingUrl = message.trackingUrl;
    }
    return obj;
  },
};

function createBaseSendShippingEmailResponse(): SendShippingEmailResponse {
  return { success: false };
}

export const SendShippingEmailResponse: MessageFns<SendShippingEmailResponse> = {
  encode(message: SendShippingEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendShippingEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendShippingEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendShippingEmailResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: SendShippingEmailResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },
};

export type OrderManagementServiceDefinition = typeof OrderManagementServiceDefinition;
export const OrderManagementServiceDefinition = {
  name: "OrderManagementService",
  fullName: "orderManagement.OrderManagementService",
  methods: {
    /** Old Flow */
    createOrder: {
      name: "CreateOrder",
      requestType: CreateOrderRequest,
      requestStream: false,
      responseType: CreateOrderResponse,
      responseStream: false,
      options: {},
    },
    getOrder: {
      name: "GetOrder",
      requestType: GetOrderRequest,
      requestStream: false,
      responseType: GetOrderResponse,
      responseStream: false,
      options: {},
    },
    getEnrichedOrder: {
      name: "GetEnrichedOrder",
      requestType: GetOrderRequest,
      requestStream: false,
      responseType: GetEnrichedOrderResponse,
      responseStream: false,
      options: {},
    },
    listOrders: {
      name: "ListOrders",
      requestType: ListOrdersRequest,
      requestStream: false,
      responseType: ListOrdersResponse,
      responseStream: false,
      options: {},
    },
    updateOrder: {
      name: "UpdateOrder",
      requestType: UpdateOrderRequest,
      requestStream: false,
      responseType: UpdateOrderResponse,
      responseStream: false,
      options: {},
    },
    deleteOrder: {
      name: "DeleteOrder",
      requestType: DeleteOrderRequest,
      requestStream: false,
      responseType: DeleteOrderResponse,
      responseStream: false,
      options: {},
    },
    /** New Flow */
    createOrderSuggestion: {
      name: "CreateOrderSuggestion",
      requestType: CreateOrderSuggestionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    submitOrderSuggestionUserResponse: {
      name: "SubmitOrderSuggestionUserResponse",
      requestType: SubmitOrderSuggestionUserResponseRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    addShipmentToOrderSuggestion: {
      name: "AddShipmentToOrderSuggestion",
      requestType: AddShipmentToOrderSuggestionRequest,
      requestStream: false,
      responseType: AddShipmentToOrderSuggestionResponse,
      responseStream: false,
      options: {},
    },
    updateShippingInformation: {
      name: "UpdateShippingInformation",
      requestType: UpdateShippingInformationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    deleteShipment: {
      name: "DeleteShipment",
      requestType: DeleteShipmentRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    submitProductPurchaseFeedback: {
      name: "SubmitProductPurchaseFeedback",
      requestType: SubmitProductPurchaseFeedbackRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    submitProductPurchaseSuggestionFeedback: {
      name: "SubmitProductPurchaseSuggestionFeedback",
      requestType: SubmitProductPurchaseSuggestionFeedbackRequest,
      requestStream: false,
      responseType: SubmitProductPurchaseSuggestionFeedbackResponse,
      responseStream: false,
      options: {},
    },
    finalizeOrderSuggestion: {
      name: "FinalizeOrderSuggestion",
      requestType: FinalizeOrderSuggestionRequest,
      requestStream: false,
      responseType: FinalizeOrderSuggestionResponse,
      responseStream: false,
      options: {},
    },
    replaceOrderSuggestion: {
      name: "ReplaceOrderSuggestion",
      requestType: ReplaceOrderSuggestionRequest,
      requestStream: false,
      responseType: ReplaceOrderSuggestionResponse,
      responseStream: false,
      options: {},
    },
    setSuggestionArchived: {
      name: "SetSuggestionArchived",
      requestType: SetSuggestionArchivedRequest,
      requestStream: false,
      responseType: SetSuggestionArchivedResponse,
      responseStream: false,
      options: {},
    },
    publishDraftSuggestion: {
      name: "PublishDraftSuggestion",
      requestType: PublishDraftSuggestionRequest,
      requestStream: false,
      responseType: PublishDraftSuggestionResponse,
      responseStream: false,
      options: {},
    },
    getShipmentIntentInfo: {
      name: "GetShipmentIntentInfo",
      requestType: GetShipmentIntentInfoRequest,
      requestStream: false,
      responseType: GetShipmentIntentInfoResponse,
      responseStream: false,
      options: {},
    },
    updateProductPurchase: {
      name: "UpdateProductPurchase",
      requestType: UpdateProductPurchaseRequest,
      requestStream: false,
      responseType: UpdateProductPurchaseResponse,
      responseStream: false,
      options: {},
    },
    updateOrderSuggestionStylistNote: {
      name: "UpdateOrderSuggestionStylistNote",
      requestType: UpdateOrderSuggestionStylistNoteRequest,
      requestStream: false,
      responseType: UpdateOrderSuggestionStylistNoteResponse,
      responseStream: false,
      options: {},
    },
    removeProductSuggestionFromOrderSuggestion: {
      name: "RemoveProductSuggestionFromOrderSuggestion",
      requestType: RemoveProductSuggestionFromOrderSuggestionRequest,
      requestStream: false,
      responseType: RemoveProductSuggestionFromOrderSuggestionResponse,
      responseStream: false,
      options: {},
    },
    addProductSuggestionToOrderSuggestion: {
      name: "AddProductSuggestionToOrderSuggestion",
      requestType: AddProductSuggestionToOrderSuggestionRequest,
      requestStream: false,
      responseType: AddProductSuggestionToOrderSuggestionResponse,
      responseStream: false,
      options: {},
    },
    deleteOrderSuggestions: {
      name: "DeleteOrderSuggestions",
      requestType: DeleteOrderSuggestionsRequest,
      requestStream: false,
      responseType: DeleteOrderSuggestionsResponse,
      responseStream: false,
      options: {},
    },
    toggleProductPurchaseSuggestionArchived: {
      name: "ToggleProductPurchaseSuggestionArchived",
      requestType: ToggleProductPurchaseSuggestionArchivedRequest,
      requestStream: false,
      responseType: ToggleProductPurchaseSuggestionArchivedResponse,
      responseStream: false,
      options: {},
    },
    editProductPurchaseSuggestion: {
      name: "EditProductPurchaseSuggestion",
      requestType: EditProductPurchaseSuggestionRequest,
      requestStream: false,
      responseType: EditProductPurchaseSuggestionResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface OrderManagementServiceImplementation<CallContextExt = {}> {
  /** Old Flow */
  createOrder(request: CreateOrderRequest, context: CallContext & CallContextExt): Promise<CreateOrderResponse>;
  getOrder(request: GetOrderRequest, context: CallContext & CallContextExt): Promise<GetOrderResponse>;
  getEnrichedOrder(request: GetOrderRequest, context: CallContext & CallContextExt): Promise<GetEnrichedOrderResponse>;
  listOrders(request: ListOrdersRequest, context: CallContext & CallContextExt): Promise<ListOrdersResponse>;
  updateOrder(request: UpdateOrderRequest, context: CallContext & CallContextExt): Promise<UpdateOrderResponse>;
  deleteOrder(request: DeleteOrderRequest, context: CallContext & CallContextExt): Promise<DeleteOrderResponse>;
  /** New Flow */
  createOrderSuggestion(request: CreateOrderSuggestionRequest, context: CallContext & CallContextExt): Promise<Empty>;
  submitOrderSuggestionUserResponse(
    request: SubmitOrderSuggestionUserResponseRequest,
    context: CallContext & CallContextExt,
  ): Promise<Empty>;
  addShipmentToOrderSuggestion(
    request: AddShipmentToOrderSuggestionRequest,
    context: CallContext & CallContextExt,
  ): Promise<AddShipmentToOrderSuggestionResponse>;
  updateShippingInformation(
    request: UpdateShippingInformationRequest,
    context: CallContext & CallContextExt,
  ): Promise<Empty>;
  deleteShipment(request: DeleteShipmentRequest, context: CallContext & CallContextExt): Promise<Empty>;
  submitProductPurchaseFeedback(
    request: SubmitProductPurchaseFeedbackRequest,
    context: CallContext & CallContextExt,
  ): Promise<Empty>;
  submitProductPurchaseSuggestionFeedback(
    request: SubmitProductPurchaseSuggestionFeedbackRequest,
    context: CallContext & CallContextExt,
  ): Promise<SubmitProductPurchaseSuggestionFeedbackResponse>;
  finalizeOrderSuggestion(
    request: FinalizeOrderSuggestionRequest,
    context: CallContext & CallContextExt,
  ): Promise<FinalizeOrderSuggestionResponse>;
  replaceOrderSuggestion(
    request: ReplaceOrderSuggestionRequest,
    context: CallContext & CallContextExt,
  ): Promise<ReplaceOrderSuggestionResponse>;
  setSuggestionArchived(
    request: SetSuggestionArchivedRequest,
    context: CallContext & CallContextExt,
  ): Promise<SetSuggestionArchivedResponse>;
  publishDraftSuggestion(
    request: PublishDraftSuggestionRequest,
    context: CallContext & CallContextExt,
  ): Promise<PublishDraftSuggestionResponse>;
  getShipmentIntentInfo(
    request: GetShipmentIntentInfoRequest,
    context: CallContext & CallContextExt,
  ): Promise<GetShipmentIntentInfoResponse>;
  updateProductPurchase(
    request: UpdateProductPurchaseRequest,
    context: CallContext & CallContextExt,
  ): Promise<UpdateProductPurchaseResponse>;
  updateOrderSuggestionStylistNote(
    request: UpdateOrderSuggestionStylistNoteRequest,
    context: CallContext & CallContextExt,
  ): Promise<UpdateOrderSuggestionStylistNoteResponse>;
  removeProductSuggestionFromOrderSuggestion(
    request: RemoveProductSuggestionFromOrderSuggestionRequest,
    context: CallContext & CallContextExt,
  ): Promise<RemoveProductSuggestionFromOrderSuggestionResponse>;
  addProductSuggestionToOrderSuggestion(
    request: AddProductSuggestionToOrderSuggestionRequest,
    context: CallContext & CallContextExt,
  ): Promise<AddProductSuggestionToOrderSuggestionResponse>;
  deleteOrderSuggestions(
    request: DeleteOrderSuggestionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeleteOrderSuggestionsResponse>;
  toggleProductPurchaseSuggestionArchived(
    request: ToggleProductPurchaseSuggestionArchivedRequest,
    context: CallContext & CallContextExt,
  ): Promise<ToggleProductPurchaseSuggestionArchivedResponse>;
  editProductPurchaseSuggestion(
    request: EditProductPurchaseSuggestionRequest,
    context: CallContext & CallContextExt,
  ): Promise<EditProductPurchaseSuggestionResponse>;
}

export interface OrderManagementServiceClient<CallOptionsExt = {}> {
  /** Old Flow */
  createOrder(request: CreateOrderRequest, options?: CallOptions & CallOptionsExt): Promise<CreateOrderResponse>;
  getOrder(request: GetOrderRequest, options?: CallOptions & CallOptionsExt): Promise<GetOrderResponse>;
  getEnrichedOrder(request: GetOrderRequest, options?: CallOptions & CallOptionsExt): Promise<GetEnrichedOrderResponse>;
  listOrders(request: ListOrdersRequest, options?: CallOptions & CallOptionsExt): Promise<ListOrdersResponse>;
  updateOrder(request: UpdateOrderRequest, options?: CallOptions & CallOptionsExt): Promise<UpdateOrderResponse>;
  deleteOrder(request: DeleteOrderRequest, options?: CallOptions & CallOptionsExt): Promise<DeleteOrderResponse>;
  /** New Flow */
  createOrderSuggestion(request: CreateOrderSuggestionRequest, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  submitOrderSuggestionUserResponse(
    request: SubmitOrderSuggestionUserResponseRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  addShipmentToOrderSuggestion(
    request: AddShipmentToOrderSuggestionRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AddShipmentToOrderSuggestionResponse>;
  updateShippingInformation(
    request: UpdateShippingInformationRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  deleteShipment(request: DeleteShipmentRequest, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  submitProductPurchaseFeedback(
    request: SubmitProductPurchaseFeedbackRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  submitProductPurchaseSuggestionFeedback(
    request: SubmitProductPurchaseSuggestionFeedbackRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SubmitProductPurchaseSuggestionFeedbackResponse>;
  finalizeOrderSuggestion(
    request: FinalizeOrderSuggestionRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeOrderSuggestionResponse>;
  replaceOrderSuggestion(
    request: ReplaceOrderSuggestionRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReplaceOrderSuggestionResponse>;
  setSuggestionArchived(
    request: SetSuggestionArchivedRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SetSuggestionArchivedResponse>;
  publishDraftSuggestion(
    request: PublishDraftSuggestionRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PublishDraftSuggestionResponse>;
  getShipmentIntentInfo(
    request: GetShipmentIntentInfoRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetShipmentIntentInfoResponse>;
  updateProductPurchase(
    request: UpdateProductPurchaseRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UpdateProductPurchaseResponse>;
  updateOrderSuggestionStylistNote(
    request: UpdateOrderSuggestionStylistNoteRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UpdateOrderSuggestionStylistNoteResponse>;
  removeProductSuggestionFromOrderSuggestion(
    request: RemoveProductSuggestionFromOrderSuggestionRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RemoveProductSuggestionFromOrderSuggestionResponse>;
  addProductSuggestionToOrderSuggestion(
    request: AddProductSuggestionToOrderSuggestionRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AddProductSuggestionToOrderSuggestionResponse>;
  deleteOrderSuggestions(
    request: DeleteOrderSuggestionsRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeleteOrderSuggestionsResponse>;
  toggleProductPurchaseSuggestionArchived(
    request: ToggleProductPurchaseSuggestionArchivedRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ToggleProductPurchaseSuggestionArchivedResponse>;
  editProductPurchaseSuggestion(
    request: EditProductPurchaseSuggestionRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EditProductPurchaseSuggestionResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
