// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v5.29.3
// source: automation/automation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { ThreadType, threadTypeFromJSON, threadTypeToJSON } from "../base/comments";

export const protobufPackage = "automation";

export interface ResolveThreadRequest {
  threadId: number;
}

export interface ResolveThreadResponse {
}

export interface RespondToThreadRequest {
  threadId: number;
  content: string;
}

export interface RespondToThreadResponse {
}

export interface CreateThreadOnProductPurchaseSuggestionRequest {
  productPurchaseSuggestionId: string;
  threadType: ThreadType;
  content: string;
}

export interface CreateThreadOnProductPurchaseSuggestionResponse {
}

export interface RateProductForPurchaseRequest {
  productId: string;
  orderId?: string | undefined;
  chatId: string;
}

export interface RateProductForPurchaseResponse {
  response: string;
}

function createBaseResolveThreadRequest(): ResolveThreadRequest {
  return { threadId: 0 };
}

export const ResolveThreadRequest: MessageFns<ResolveThreadRequest> = {
  encode(message: ResolveThreadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threadId !== 0) {
      writer.uint32(8).int32(message.threadId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolveThreadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.threadId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResolveThreadRequest {
    return { threadId: isSet(object.threadId) ? globalThis.Number(object.threadId) : 0 };
  },

  toJSON(message: ResolveThreadRequest): unknown {
    const obj: any = {};
    if (message.threadId !== 0) {
      obj.threadId = Math.round(message.threadId);
    }
    return obj;
  },
};

function createBaseResolveThreadResponse(): ResolveThreadResponse {
  return {};
}

export const ResolveThreadResponse: MessageFns<ResolveThreadResponse> = {
  encode(_: ResolveThreadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolveThreadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveThreadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResolveThreadResponse {
    return {};
  },

  toJSON(_: ResolveThreadResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseRespondToThreadRequest(): RespondToThreadRequest {
  return { threadId: 0, content: "" };
}

export const RespondToThreadRequest: MessageFns<RespondToThreadRequest> = {
  encode(message: RespondToThreadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threadId !== 0) {
      writer.uint32(8).int32(message.threadId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RespondToThreadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRespondToThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.threadId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RespondToThreadRequest {
    return {
      threadId: isSet(object.threadId) ? globalThis.Number(object.threadId) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: RespondToThreadRequest): unknown {
    const obj: any = {};
    if (message.threadId !== 0) {
      obj.threadId = Math.round(message.threadId);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },
};

function createBaseRespondToThreadResponse(): RespondToThreadResponse {
  return {};
}

export const RespondToThreadResponse: MessageFns<RespondToThreadResponse> = {
  encode(_: RespondToThreadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RespondToThreadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRespondToThreadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RespondToThreadResponse {
    return {};
  },

  toJSON(_: RespondToThreadResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseCreateThreadOnProductPurchaseSuggestionRequest(): CreateThreadOnProductPurchaseSuggestionRequest {
  return { productPurchaseSuggestionId: "", threadType: 0, content: "" };
}

export const CreateThreadOnProductPurchaseSuggestionRequest: MessageFns<
  CreateThreadOnProductPurchaseSuggestionRequest
> = {
  encode(
    message: CreateThreadOnProductPurchaseSuggestionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.productPurchaseSuggestionId !== "") {
      writer.uint32(10).string(message.productPurchaseSuggestionId);
    }
    if (message.threadType !== 0) {
      writer.uint32(32).int32(message.threadType);
    }
    if (message.content !== "") {
      writer.uint32(42).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateThreadOnProductPurchaseSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateThreadOnProductPurchaseSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productPurchaseSuggestionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.threadType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateThreadOnProductPurchaseSuggestionRequest {
    return {
      productPurchaseSuggestionId: isSet(object.productPurchaseSuggestionId)
        ? globalThis.String(object.productPurchaseSuggestionId)
        : "",
      threadType: isSet(object.threadType) ? threadTypeFromJSON(object.threadType) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: CreateThreadOnProductPurchaseSuggestionRequest): unknown {
    const obj: any = {};
    if (message.productPurchaseSuggestionId !== "") {
      obj.productPurchaseSuggestionId = message.productPurchaseSuggestionId;
    }
    if (message.threadType !== 0) {
      obj.threadType = threadTypeToJSON(message.threadType);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },
};

function createBaseCreateThreadOnProductPurchaseSuggestionResponse(): CreateThreadOnProductPurchaseSuggestionResponse {
  return {};
}

export const CreateThreadOnProductPurchaseSuggestionResponse: MessageFns<
  CreateThreadOnProductPurchaseSuggestionResponse
> = {
  encode(_: CreateThreadOnProductPurchaseSuggestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateThreadOnProductPurchaseSuggestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateThreadOnProductPurchaseSuggestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateThreadOnProductPurchaseSuggestionResponse {
    return {};
  },

  toJSON(_: CreateThreadOnProductPurchaseSuggestionResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseRateProductForPurchaseRequest(): RateProductForPurchaseRequest {
  return { productId: "", orderId: undefined, chatId: "" };
}

export const RateProductForPurchaseRequest: MessageFns<RateProductForPurchaseRequest> = {
  encode(message: RateProductForPurchaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.orderId !== undefined) {
      writer.uint32(18).string(message.orderId);
    }
    if (message.chatId !== "") {
      writer.uint32(26).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateProductForPurchaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateProductForPurchaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateProductForPurchaseRequest {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : undefined,
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
    };
  },

  toJSON(message: RateProductForPurchaseRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.orderId !== undefined) {
      obj.orderId = message.orderId;
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    return obj;
  },
};

function createBaseRateProductForPurchaseResponse(): RateProductForPurchaseResponse {
  return { response: "" };
}

export const RateProductForPurchaseResponse: MessageFns<RateProductForPurchaseResponse> = {
  encode(message: RateProductForPurchaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== "") {
      writer.uint32(10).string(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateProductForPurchaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateProductForPurchaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateProductForPurchaseResponse {
    return { response: isSet(object.response) ? globalThis.String(object.response) : "" };
  },

  toJSON(message: RateProductForPurchaseResponse): unknown {
    const obj: any = {};
    if (message.response !== "") {
      obj.response = message.response;
    }
    return obj;
  },
};

export type AutomationServiceDefinition = typeof AutomationServiceDefinition;
export const AutomationServiceDefinition = {
  name: "AutomationService",
  fullName: "automation.AutomationService",
  methods: {
    rateProductForPurchase: {
      name: "RateProductForPurchase",
      requestType: RateProductForPurchaseRequest,
      requestStream: false,
      responseType: RateProductForPurchaseResponse,
      responseStream: false,
      options: {},
    },
    createThreadOnProductPurchaseSuggestion: {
      name: "CreateThreadOnProductPurchaseSuggestion",
      requestType: CreateThreadOnProductPurchaseSuggestionRequest,
      requestStream: false,
      responseType: CreateThreadOnProductPurchaseSuggestionResponse,
      responseStream: false,
      options: {},
    },
    resolveThread: {
      name: "ResolveThread",
      requestType: ResolveThreadRequest,
      requestStream: false,
      responseType: ResolveThreadResponse,
      responseStream: false,
      options: {},
    },
    respondToThread: {
      name: "RespondToThread",
      requestType: RespondToThreadRequest,
      requestStream: false,
      responseType: RespondToThreadResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface AutomationServiceImplementation<CallContextExt = {}> {
  rateProductForPurchase(
    request: RateProductForPurchaseRequest,
    context: CallContext & CallContextExt,
  ): Promise<RateProductForPurchaseResponse>;
  createThreadOnProductPurchaseSuggestion(
    request: CreateThreadOnProductPurchaseSuggestionRequest,
    context: CallContext & CallContextExt,
  ): Promise<CreateThreadOnProductPurchaseSuggestionResponse>;
  resolveThread(request: ResolveThreadRequest, context: CallContext & CallContextExt): Promise<ResolveThreadResponse>;
  respondToThread(
    request: RespondToThreadRequest,
    context: CallContext & CallContextExt,
  ): Promise<RespondToThreadResponse>;
}

export interface AutomationServiceClient<CallOptionsExt = {}> {
  rateProductForPurchase(
    request: RateProductForPurchaseRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RateProductForPurchaseResponse>;
  createThreadOnProductPurchaseSuggestion(
    request: CreateThreadOnProductPurchaseSuggestionRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CreateThreadOnProductPurchaseSuggestionResponse>;
  resolveThread(request: ResolveThreadRequest, options?: CallOptions & CallOptionsExt): Promise<ResolveThreadResponse>;
  respondToThread(
    request: RespondToThreadRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RespondToThreadResponse>;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
