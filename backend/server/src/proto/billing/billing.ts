// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v5.29.3
// source: billing/billing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  PaymentMethodStatus,
  paymentMethodStatusFromJSON,
  paymentMethodStatusToJSON,
} from "../base/user_billing";

export const protobufPackage = "billing";

export enum CheckoutMode {
  CHECKOUT_MODE_UNSPECIFIED = 0,
  CHECKOUT_MODE_REDIRECT = 1,
  CHECKOUT_MODE_EMBEDDED = 2,
  UNRECOGNIZED = -1,
}

export function checkoutModeFromJSON(object: any): CheckoutMode {
  switch (object) {
    case 0:
    case "CHECKOUT_MODE_UNSPECIFIED":
      return CheckoutMode.CHECKOUT_MODE_UNSPECIFIED;
    case 1:
    case "CHECKOUT_MODE_REDIRECT":
      return CheckoutMode.CHECKOUT_MODE_REDIRECT;
    case 2:
    case "CHECKOUT_MODE_EMBEDDED":
      return CheckoutMode.CHECKOUT_MODE_EMBEDDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CheckoutMode.UNRECOGNIZED;
  }
}

export function checkoutModeToJSON(object: CheckoutMode): string {
  switch (object) {
    case CheckoutMode.CHECKOUT_MODE_UNSPECIFIED:
      return "CHECKOUT_MODE_UNSPECIFIED";
    case CheckoutMode.CHECKOUT_MODE_REDIRECT:
      return "CHECKOUT_MODE_REDIRECT";
    case CheckoutMode.CHECKOUT_MODE_EMBEDDED:
      return "CHECKOUT_MODE_EMBEDDED";
    case CheckoutMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PaymentType {
  PAYMENT_TYPE_UNSPECIFIED = 0,
  PAYMENT_TYPE_SUBSCRIPTION = 1,
  PAYMENT_TYPE_ONE_TIME = 2,
  UNRECOGNIZED = -1,
}

export function paymentTypeFromJSON(object: any): PaymentType {
  switch (object) {
    case 0:
    case "PAYMENT_TYPE_UNSPECIFIED":
      return PaymentType.PAYMENT_TYPE_UNSPECIFIED;
    case 1:
    case "PAYMENT_TYPE_SUBSCRIPTION":
      return PaymentType.PAYMENT_TYPE_SUBSCRIPTION;
    case 2:
    case "PAYMENT_TYPE_ONE_TIME":
      return PaymentType.PAYMENT_TYPE_ONE_TIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentType.UNRECOGNIZED;
  }
}

export function paymentTypeToJSON(object: PaymentType): string {
  switch (object) {
    case PaymentType.PAYMENT_TYPE_UNSPECIFIED:
      return "PAYMENT_TYPE_UNSPECIFIED";
    case PaymentType.PAYMENT_TYPE_SUBSCRIPTION:
      return "PAYMENT_TYPE_SUBSCRIPTION";
    case PaymentType.PAYMENT_TYPE_ONE_TIME:
      return "PAYMENT_TYPE_ONE_TIME";
    case PaymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateCheckoutSessionRequest {
  userId: string;
  amountInCents: number;
  paymentType: PaymentType;
  successUrl: string;
  cancelUrl: string;
  mode: CheckoutMode;
}

export interface CreateCheckoutSessionResponse {
  checkoutUrl: string;
  clientSecret?: string | undefined;
}

export interface CancelSubscriptionRequest {}

export interface CancelSubscriptionResponse {
  success: boolean;
}

export interface SyncStripeDataRequest {
  customerId: string;
}

export interface SyncStripeDataResponse {
  subscriptionData: SubscriptionData | undefined;
}

export interface SubscriptionData {
  status: string;
  currentPeriodStart?: number | undefined;
  currentPeriodEnd?: number | undefined;
  subscriptionId?: string | undefined;
  priceId?: string | undefined;
  cancelAtPeriodEnd?: boolean | undefined;
  paymentMethod?: PaymentMethodData | undefined;
}

export interface PaymentMethodData {
  brand: string;
  last4: string;
}

export interface GetOrCreateCustomerRequest {
  userId: string;
}

export interface GetOrCreateCustomerResponse {
  customerId: string;
}

export interface CreatePaymentIntentRequest {
  userId: string;
  amountInCents: number;
  paymentType: PaymentType;
}

export interface CreatePaymentIntentResponse {
  clientSecret: string;
  ephemeralKey: string;
  customerId: string;
}

export interface CreateSubscriptionRequest {
  userId: string;
  priceId: string;
}

export interface CreateSubscriptionResponse {
  subscriptionId: string;
  clientSecret: string;
  customerId: string;
}

export interface CreateStripeSetupIntentRequest {
  userId: string;
}

export interface CreateStripeSetupIntentResponse {
  clientSecret: string;
  customerId: string;
}

export interface PaymentMethodDetails {
  brand: string;
  last4: string;
  expiryMonth: number;
  expiryYear: number;
}

export interface RefreshCustomerPaymentStatusRequest {
  userId: string;
}

export interface RefreshCustomerPaymentStatusResponse {
  status: PaymentMethodStatus;
  paymentMethods: PaymentMethodDetails[];
}

export interface GetStripeConfigRequest {}

export interface GetStripeConfigResponse {
  publishableKey: string;
  merchantId: string;
  subscriptionPriceId: string;
}

function createBaseCreateCheckoutSessionRequest(): CreateCheckoutSessionRequest {
  return {
    userId: "",
    amountInCents: 0,
    paymentType: 0,
    successUrl: "",
    cancelUrl: "",
    mode: 0,
  };
}

export const CreateCheckoutSessionRequest: MessageFns<CreateCheckoutSessionRequest> =
  {
    encode(
      message: CreateCheckoutSessionRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.userId !== "") {
        writer.uint32(10).string(message.userId);
      }
      if (message.amountInCents !== 0) {
        writer.uint32(16).int32(message.amountInCents);
      }
      if (message.paymentType !== 0) {
        writer.uint32(24).int32(message.paymentType);
      }
      if (message.successUrl !== "") {
        writer.uint32(34).string(message.successUrl);
      }
      if (message.cancelUrl !== "") {
        writer.uint32(42).string(message.cancelUrl);
      }
      if (message.mode !== 0) {
        writer.uint32(48).int32(message.mode);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CreateCheckoutSessionRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateCheckoutSessionRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.amountInCents = reader.int32();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.paymentType = reader.int32() as any;
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.successUrl = reader.string();
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.cancelUrl = reader.string();
            continue;
          }
          case 6: {
            if (tag !== 48) {
              break;
            }

            message.mode = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreateCheckoutSessionRequest {
      return {
        userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
        amountInCents: isSet(object.amountInCents)
          ? globalThis.Number(object.amountInCents)
          : 0,
        paymentType: isSet(object.paymentType)
          ? paymentTypeFromJSON(object.paymentType)
          : 0,
        successUrl: isSet(object.successUrl)
          ? globalThis.String(object.successUrl)
          : "",
        cancelUrl: isSet(object.cancelUrl)
          ? globalThis.String(object.cancelUrl)
          : "",
        mode: isSet(object.mode) ? checkoutModeFromJSON(object.mode) : 0,
      };
    },

    toJSON(message: CreateCheckoutSessionRequest): unknown {
      const obj: any = {};
      if (message.userId !== "") {
        obj.userId = message.userId;
      }
      if (message.amountInCents !== 0) {
        obj.amountInCents = Math.round(message.amountInCents);
      }
      if (message.paymentType !== 0) {
        obj.paymentType = paymentTypeToJSON(message.paymentType);
      }
      if (message.successUrl !== "") {
        obj.successUrl = message.successUrl;
      }
      if (message.cancelUrl !== "") {
        obj.cancelUrl = message.cancelUrl;
      }
      if (message.mode !== 0) {
        obj.mode = checkoutModeToJSON(message.mode);
      }
      return obj;
    },
  };

function createBaseCreateCheckoutSessionResponse(): CreateCheckoutSessionResponse {
  return { checkoutUrl: "", clientSecret: undefined };
}

export const CreateCheckoutSessionResponse: MessageFns<CreateCheckoutSessionResponse> =
  {
    encode(
      message: CreateCheckoutSessionResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.checkoutUrl !== "") {
        writer.uint32(10).string(message.checkoutUrl);
      }
      if (message.clientSecret !== undefined) {
        writer.uint32(18).string(message.clientSecret);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CreateCheckoutSessionResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateCheckoutSessionResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.checkoutUrl = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.clientSecret = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreateCheckoutSessionResponse {
      return {
        checkoutUrl: isSet(object.checkoutUrl)
          ? globalThis.String(object.checkoutUrl)
          : "",
        clientSecret: isSet(object.clientSecret)
          ? globalThis.String(object.clientSecret)
          : undefined,
      };
    },

    toJSON(message: CreateCheckoutSessionResponse): unknown {
      const obj: any = {};
      if (message.checkoutUrl !== "") {
        obj.checkoutUrl = message.checkoutUrl;
      }
      if (message.clientSecret !== undefined) {
        obj.clientSecret = message.clientSecret;
      }
      return obj;
    },
  };

function createBaseCancelSubscriptionRequest(): CancelSubscriptionRequest {
  return {};
}

export const CancelSubscriptionRequest: MessageFns<CancelSubscriptionRequest> =
  {
    encode(
      _: CancelSubscriptionRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CancelSubscriptionRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCancelSubscriptionRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): CancelSubscriptionRequest {
      return {};
    },

    toJSON(_: CancelSubscriptionRequest): unknown {
      const obj: any = {};
      return obj;
    },
  };

function createBaseCancelSubscriptionResponse(): CancelSubscriptionResponse {
  return { success: false };
}

export const CancelSubscriptionResponse: MessageFns<CancelSubscriptionResponse> =
  {
    encode(
      message: CancelSubscriptionResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.success !== false) {
        writer.uint32(8).bool(message.success);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CancelSubscriptionResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCancelSubscriptionResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.success = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CancelSubscriptionResponse {
      return {
        success: isSet(object.success)
          ? globalThis.Boolean(object.success)
          : false,
      };
    },

    toJSON(message: CancelSubscriptionResponse): unknown {
      const obj: any = {};
      if (message.success !== false) {
        obj.success = message.success;
      }
      return obj;
    },
  };

function createBaseSyncStripeDataRequest(): SyncStripeDataRequest {
  return { customerId: "" };
}

export const SyncStripeDataRequest: MessageFns<SyncStripeDataRequest> = {
  encode(
    message: SyncStripeDataRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): SyncStripeDataRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncStripeDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncStripeDataRequest {
    return {
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : "",
    };
  },

  toJSON(message: SyncStripeDataRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    return obj;
  },
};

function createBaseSyncStripeDataResponse(): SyncStripeDataResponse {
  return { subscriptionData: undefined };
}

export const SyncStripeDataResponse: MessageFns<SyncStripeDataResponse> = {
  encode(
    message: SyncStripeDataResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.subscriptionData !== undefined) {
      SubscriptionData.encode(
        message.subscriptionData,
        writer.uint32(10).fork()
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): SyncStripeDataResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncStripeDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptionData = SubscriptionData.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncStripeDataResponse {
    return {
      subscriptionData: isSet(object.subscriptionData)
        ? SubscriptionData.fromJSON(object.subscriptionData)
        : undefined,
    };
  },

  toJSON(message: SyncStripeDataResponse): unknown {
    const obj: any = {};
    if (message.subscriptionData !== undefined) {
      obj.subscriptionData = SubscriptionData.toJSON(message.subscriptionData);
    }
    return obj;
  },
};

function createBaseSubscriptionData(): SubscriptionData {
  return {
    status: "",
    currentPeriodStart: undefined,
    currentPeriodEnd: undefined,
    subscriptionId: undefined,
    priceId: undefined,
    cancelAtPeriodEnd: undefined,
    paymentMethod: undefined,
  };
}

export const SubscriptionData: MessageFns<SubscriptionData> = {
  encode(
    message: SubscriptionData,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.currentPeriodStart !== undefined) {
      writer.uint32(16).int64(message.currentPeriodStart);
    }
    if (message.currentPeriodEnd !== undefined) {
      writer.uint32(24).int64(message.currentPeriodEnd);
    }
    if (message.subscriptionId !== undefined) {
      writer.uint32(34).string(message.subscriptionId);
    }
    if (message.priceId !== undefined) {
      writer.uint32(42).string(message.priceId);
    }
    if (message.cancelAtPeriodEnd !== undefined) {
      writer.uint32(48).bool(message.cancelAtPeriodEnd);
    }
    if (message.paymentMethod !== undefined) {
      PaymentMethodData.encode(
        message.paymentMethod,
        writer.uint32(58).fork()
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currentPeriodStart = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentPeriodEnd = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.priceId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cancelAtPeriodEnd = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.paymentMethod = PaymentMethodData.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionData {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      currentPeriodStart: isSet(object.currentPeriodStart)
        ? globalThis.Number(object.currentPeriodStart)
        : undefined,
      currentPeriodEnd: isSet(object.currentPeriodEnd)
        ? globalThis.Number(object.currentPeriodEnd)
        : undefined,
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : undefined,
      priceId: isSet(object.priceId)
        ? globalThis.String(object.priceId)
        : undefined,
      cancelAtPeriodEnd: isSet(object.cancelAtPeriodEnd)
        ? globalThis.Boolean(object.cancelAtPeriodEnd)
        : undefined,
      paymentMethod: isSet(object.paymentMethod)
        ? PaymentMethodData.fromJSON(object.paymentMethod)
        : undefined,
    };
  },

  toJSON(message: SubscriptionData): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.currentPeriodStart !== undefined) {
      obj.currentPeriodStart = Math.round(message.currentPeriodStart);
    }
    if (message.currentPeriodEnd !== undefined) {
      obj.currentPeriodEnd = Math.round(message.currentPeriodEnd);
    }
    if (message.subscriptionId !== undefined) {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.priceId !== undefined) {
      obj.priceId = message.priceId;
    }
    if (message.cancelAtPeriodEnd !== undefined) {
      obj.cancelAtPeriodEnd = message.cancelAtPeriodEnd;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = PaymentMethodData.toJSON(message.paymentMethod);
    }
    return obj;
  },
};

function createBasePaymentMethodData(): PaymentMethodData {
  return { brand: "", last4: "" };
}

export const PaymentMethodData: MessageFns<PaymentMethodData> = {
  encode(
    message: PaymentMethodData,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.brand !== "") {
      writer.uint32(10).string(message.brand);
    }
    if (message.last4 !== "") {
      writer.uint32(18).string(message.last4);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentMethodData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentMethodData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brand = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last4 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentMethodData {
    return {
      brand: isSet(object.brand) ? globalThis.String(object.brand) : "",
      last4: isSet(object.last4) ? globalThis.String(object.last4) : "",
    };
  },

  toJSON(message: PaymentMethodData): unknown {
    const obj: any = {};
    if (message.brand !== "") {
      obj.brand = message.brand;
    }
    if (message.last4 !== "") {
      obj.last4 = message.last4;
    }
    return obj;
  },
};

function createBaseGetOrCreateCustomerRequest(): GetOrCreateCustomerRequest {
  return { userId: "" };
}

export const GetOrCreateCustomerRequest: MessageFns<GetOrCreateCustomerRequest> =
  {
    encode(
      message: GetOrCreateCustomerRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.userId !== "") {
        writer.uint32(10).string(message.userId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): GetOrCreateCustomerRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetOrCreateCustomerRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetOrCreateCustomerRequest {
      return {
        userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      };
    },

    toJSON(message: GetOrCreateCustomerRequest): unknown {
      const obj: any = {};
      if (message.userId !== "") {
        obj.userId = message.userId;
      }
      return obj;
    },
  };

function createBaseGetOrCreateCustomerResponse(): GetOrCreateCustomerResponse {
  return { customerId: "" };
}

export const GetOrCreateCustomerResponse: MessageFns<GetOrCreateCustomerResponse> =
  {
    encode(
      message: GetOrCreateCustomerResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.customerId !== "") {
        writer.uint32(10).string(message.customerId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): GetOrCreateCustomerResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetOrCreateCustomerResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.customerId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetOrCreateCustomerResponse {
      return {
        customerId: isSet(object.customerId)
          ? globalThis.String(object.customerId)
          : "",
      };
    },

    toJSON(message: GetOrCreateCustomerResponse): unknown {
      const obj: any = {};
      if (message.customerId !== "") {
        obj.customerId = message.customerId;
      }
      return obj;
    },
  };

function createBaseCreatePaymentIntentRequest(): CreatePaymentIntentRequest {
  return { userId: "", amountInCents: 0, paymentType: 0 };
}

export const CreatePaymentIntentRequest: MessageFns<CreatePaymentIntentRequest> =
  {
    encode(
      message: CreatePaymentIntentRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.userId !== "") {
        writer.uint32(10).string(message.userId);
      }
      if (message.amountInCents !== 0) {
        writer.uint32(16).int32(message.amountInCents);
      }
      if (message.paymentType !== 0) {
        writer.uint32(24).int32(message.paymentType);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CreatePaymentIntentRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreatePaymentIntentRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.amountInCents = reader.int32();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.paymentType = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreatePaymentIntentRequest {
      return {
        userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
        amountInCents: isSet(object.amountInCents)
          ? globalThis.Number(object.amountInCents)
          : 0,
        paymentType: isSet(object.paymentType)
          ? paymentTypeFromJSON(object.paymentType)
          : 0,
      };
    },

    toJSON(message: CreatePaymentIntentRequest): unknown {
      const obj: any = {};
      if (message.userId !== "") {
        obj.userId = message.userId;
      }
      if (message.amountInCents !== 0) {
        obj.amountInCents = Math.round(message.amountInCents);
      }
      if (message.paymentType !== 0) {
        obj.paymentType = paymentTypeToJSON(message.paymentType);
      }
      return obj;
    },
  };

function createBaseCreatePaymentIntentResponse(): CreatePaymentIntentResponse {
  return { clientSecret: "", ephemeralKey: "", customerId: "" };
}

export const CreatePaymentIntentResponse: MessageFns<CreatePaymentIntentResponse> =
  {
    encode(
      message: CreatePaymentIntentResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.clientSecret !== "") {
        writer.uint32(10).string(message.clientSecret);
      }
      if (message.ephemeralKey !== "") {
        writer.uint32(18).string(message.ephemeralKey);
      }
      if (message.customerId !== "") {
        writer.uint32(26).string(message.customerId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CreatePaymentIntentResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreatePaymentIntentResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.clientSecret = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.ephemeralKey = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.customerId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreatePaymentIntentResponse {
      return {
        clientSecret: isSet(object.clientSecret)
          ? globalThis.String(object.clientSecret)
          : "",
        ephemeralKey: isSet(object.ephemeralKey)
          ? globalThis.String(object.ephemeralKey)
          : "",
        customerId: isSet(object.customerId)
          ? globalThis.String(object.customerId)
          : "",
      };
    },

    toJSON(message: CreatePaymentIntentResponse): unknown {
      const obj: any = {};
      if (message.clientSecret !== "") {
        obj.clientSecret = message.clientSecret;
      }
      if (message.ephemeralKey !== "") {
        obj.ephemeralKey = message.ephemeralKey;
      }
      if (message.customerId !== "") {
        obj.customerId = message.customerId;
      }
      return obj;
    },
  };

function createBaseCreateSubscriptionRequest(): CreateSubscriptionRequest {
  return { userId: "", priceId: "" };
}

export const CreateSubscriptionRequest: MessageFns<CreateSubscriptionRequest> =
  {
    encode(
      message: CreateSubscriptionRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.userId !== "") {
        writer.uint32(10).string(message.userId);
      }
      if (message.priceId !== "") {
        writer.uint32(18).string(message.priceId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CreateSubscriptionRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateSubscriptionRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.priceId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreateSubscriptionRequest {
      return {
        userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
        priceId: isSet(object.priceId) ? globalThis.String(object.priceId) : "",
      };
    },

    toJSON(message: CreateSubscriptionRequest): unknown {
      const obj: any = {};
      if (message.userId !== "") {
        obj.userId = message.userId;
      }
      if (message.priceId !== "") {
        obj.priceId = message.priceId;
      }
      return obj;
    },
  };

function createBaseCreateSubscriptionResponse(): CreateSubscriptionResponse {
  return { subscriptionId: "", clientSecret: "", customerId: "" };
}

export const CreateSubscriptionResponse: MessageFns<CreateSubscriptionResponse> =
  {
    encode(
      message: CreateSubscriptionResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.subscriptionId !== "") {
        writer.uint32(10).string(message.subscriptionId);
      }
      if (message.clientSecret !== "") {
        writer.uint32(18).string(message.clientSecret);
      }
      if (message.customerId !== "") {
        writer.uint32(26).string(message.customerId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CreateSubscriptionResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateSubscriptionResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.subscriptionId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.clientSecret = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.customerId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreateSubscriptionResponse {
      return {
        subscriptionId: isSet(object.subscriptionId)
          ? globalThis.String(object.subscriptionId)
          : "",
        clientSecret: isSet(object.clientSecret)
          ? globalThis.String(object.clientSecret)
          : "",
        customerId: isSet(object.customerId)
          ? globalThis.String(object.customerId)
          : "",
      };
    },

    toJSON(message: CreateSubscriptionResponse): unknown {
      const obj: any = {};
      if (message.subscriptionId !== "") {
        obj.subscriptionId = message.subscriptionId;
      }
      if (message.clientSecret !== "") {
        obj.clientSecret = message.clientSecret;
      }
      if (message.customerId !== "") {
        obj.customerId = message.customerId;
      }
      return obj;
    },
  };

function createBaseCreateStripeSetupIntentRequest(): CreateStripeSetupIntentRequest {
  return { userId: "" };
}

export const CreateStripeSetupIntentRequest: MessageFns<CreateStripeSetupIntentRequest> =
  {
    encode(
      message: CreateStripeSetupIntentRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.userId !== "") {
        writer.uint32(10).string(message.userId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CreateStripeSetupIntentRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateStripeSetupIntentRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreateStripeSetupIntentRequest {
      return {
        userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      };
    },

    toJSON(message: CreateStripeSetupIntentRequest): unknown {
      const obj: any = {};
      if (message.userId !== "") {
        obj.userId = message.userId;
      }
      return obj;
    },
  };

function createBaseCreateStripeSetupIntentResponse(): CreateStripeSetupIntentResponse {
  return { clientSecret: "", customerId: "" };
}

export const CreateStripeSetupIntentResponse: MessageFns<CreateStripeSetupIntentResponse> =
  {
    encode(
      message: CreateStripeSetupIntentResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.clientSecret !== "") {
        writer.uint32(10).string(message.clientSecret);
      }
      if (message.customerId !== "") {
        writer.uint32(18).string(message.customerId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CreateStripeSetupIntentResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateStripeSetupIntentResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.clientSecret = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.customerId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreateStripeSetupIntentResponse {
      return {
        clientSecret: isSet(object.clientSecret)
          ? globalThis.String(object.clientSecret)
          : "",
        customerId: isSet(object.customerId)
          ? globalThis.String(object.customerId)
          : "",
      };
    },

    toJSON(message: CreateStripeSetupIntentResponse): unknown {
      const obj: any = {};
      if (message.clientSecret !== "") {
        obj.clientSecret = message.clientSecret;
      }
      if (message.customerId !== "") {
        obj.customerId = message.customerId;
      }
      return obj;
    },
  };

function createBasePaymentMethodDetails(): PaymentMethodDetails {
  return { brand: "", last4: "", expiryMonth: 0, expiryYear: 0 };
}

export const PaymentMethodDetails: MessageFns<PaymentMethodDetails> = {
  encode(
    message: PaymentMethodDetails,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.brand !== "") {
      writer.uint32(10).string(message.brand);
    }
    if (message.last4 !== "") {
      writer.uint32(18).string(message.last4);
    }
    if (message.expiryMonth !== 0) {
      writer.uint32(24).int32(message.expiryMonth);
    }
    if (message.expiryYear !== 0) {
      writer.uint32(32).int32(message.expiryYear);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): PaymentMethodDetails {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentMethodDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brand = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last4 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiryMonth = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiryYear = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentMethodDetails {
    return {
      brand: isSet(object.brand) ? globalThis.String(object.brand) : "",
      last4: isSet(object.last4) ? globalThis.String(object.last4) : "",
      expiryMonth: isSet(object.expiryMonth)
        ? globalThis.Number(object.expiryMonth)
        : 0,
      expiryYear: isSet(object.expiryYear)
        ? globalThis.Number(object.expiryYear)
        : 0,
    };
  },

  toJSON(message: PaymentMethodDetails): unknown {
    const obj: any = {};
    if (message.brand !== "") {
      obj.brand = message.brand;
    }
    if (message.last4 !== "") {
      obj.last4 = message.last4;
    }
    if (message.expiryMonth !== 0) {
      obj.expiryMonth = Math.round(message.expiryMonth);
    }
    if (message.expiryYear !== 0) {
      obj.expiryYear = Math.round(message.expiryYear);
    }
    return obj;
  },
};

function createBaseRefreshCustomerPaymentStatusRequest(): RefreshCustomerPaymentStatusRequest {
  return { userId: "" };
}

export const RefreshCustomerPaymentStatusRequest: MessageFns<RefreshCustomerPaymentStatusRequest> =
  {
    encode(
      message: RefreshCustomerPaymentStatusRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.userId !== "") {
        writer.uint32(10).string(message.userId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): RefreshCustomerPaymentStatusRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRefreshCustomerPaymentStatusRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): RefreshCustomerPaymentStatusRequest {
      return {
        userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      };
    },

    toJSON(message: RefreshCustomerPaymentStatusRequest): unknown {
      const obj: any = {};
      if (message.userId !== "") {
        obj.userId = message.userId;
      }
      return obj;
    },
  };

function createBaseRefreshCustomerPaymentStatusResponse(): RefreshCustomerPaymentStatusResponse {
  return { status: 0, paymentMethods: [] };
}

export const RefreshCustomerPaymentStatusResponse: MessageFns<RefreshCustomerPaymentStatusResponse> =
  {
    encode(
      message: RefreshCustomerPaymentStatusResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.status !== 0) {
        writer.uint32(8).int32(message.status);
      }
      for (const v of message.paymentMethods) {
        PaymentMethodDetails.encode(v!, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): RefreshCustomerPaymentStatusResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRefreshCustomerPaymentStatusResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.status = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.paymentMethods.push(
              PaymentMethodDetails.decode(reader, reader.uint32())
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): RefreshCustomerPaymentStatusResponse {
      return {
        status: isSet(object.status)
          ? paymentMethodStatusFromJSON(object.status)
          : 0,
        paymentMethods: globalThis.Array.isArray(object?.paymentMethods)
          ? object.paymentMethods.map((e: any) =>
              PaymentMethodDetails.fromJSON(e)
            )
          : [],
      };
    },

    toJSON(message: RefreshCustomerPaymentStatusResponse): unknown {
      const obj: any = {};
      if (message.status !== 0) {
        obj.status = paymentMethodStatusToJSON(message.status);
      }
      if (message.paymentMethods?.length) {
        obj.paymentMethods = message.paymentMethods.map((e) =>
          PaymentMethodDetails.toJSON(e)
        );
      }
      return obj;
    },
  };

function createBaseGetStripeConfigRequest(): GetStripeConfigRequest {
  return {};
}

export const GetStripeConfigRequest: MessageFns<GetStripeConfigRequest> = {
  encode(
    _: GetStripeConfigRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetStripeConfigRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStripeConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetStripeConfigRequest {
    return {};
  },

  toJSON(_: GetStripeConfigRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetStripeConfigResponse(): GetStripeConfigResponse {
  return { publishableKey: "", merchantId: "", subscriptionPriceId: "" };
}

export const GetStripeConfigResponse: MessageFns<GetStripeConfigResponse> = {
  encode(
    message: GetStripeConfigResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.publishableKey !== "") {
      writer.uint32(10).string(message.publishableKey);
    }
    if (message.merchantId !== "") {
      writer.uint32(18).string(message.merchantId);
    }
    if (message.subscriptionPriceId !== "") {
      writer.uint32(26).string(message.subscriptionPriceId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetStripeConfigResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStripeConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publishableKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.merchantId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscriptionPriceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStripeConfigResponse {
    return {
      publishableKey: isSet(object.publishableKey)
        ? globalThis.String(object.publishableKey)
        : "",
      merchantId: isSet(object.merchantId)
        ? globalThis.String(object.merchantId)
        : "",
      subscriptionPriceId: isSet(object.subscriptionPriceId)
        ? globalThis.String(object.subscriptionPriceId)
        : "",
    };
  },

  toJSON(message: GetStripeConfigResponse): unknown {
    const obj: any = {};
    if (message.publishableKey !== "") {
      obj.publishableKey = message.publishableKey;
    }
    if (message.merchantId !== "") {
      obj.merchantId = message.merchantId;
    }
    if (message.subscriptionPriceId !== "") {
      obj.subscriptionPriceId = message.subscriptionPriceId;
    }
    return obj;
  },
};

export type BillingServiceDefinition = typeof BillingServiceDefinition;
export const BillingServiceDefinition = {
  name: "BillingService",
  fullName: "billing.BillingService",
  methods: {
    createCheckoutSession: {
      name: "CreateCheckoutSession",
      requestType: CreateCheckoutSessionRequest,
      requestStream: false,
      responseType: CreateCheckoutSessionResponse,
      responseStream: false,
      options: {},
    },
    cancelSubscription: {
      name: "CancelSubscription",
      requestType: CancelSubscriptionRequest,
      requestStream: false,
      responseType: CancelSubscriptionResponse,
      responseStream: false,
      options: {},
    },
    syncStripeData: {
      name: "SyncStripeData",
      requestType: SyncStripeDataRequest,
      requestStream: false,
      responseType: SyncStripeDataResponse,
      responseStream: false,
      options: {},
    },
    getOrCreateCustomer: {
      name: "GetOrCreateCustomer",
      requestType: GetOrCreateCustomerRequest,
      requestStream: false,
      responseType: GetOrCreateCustomerResponse,
      responseStream: false,
      options: {},
    },
    createPaymentIntent: {
      name: "CreatePaymentIntent",
      requestType: CreatePaymentIntentRequest,
      requestStream: false,
      responseType: CreatePaymentIntentResponse,
      responseStream: false,
      options: {},
    },
    createSubscription: {
      name: "CreateSubscription",
      requestType: CreateSubscriptionRequest,
      requestStream: false,
      responseType: CreateSubscriptionResponse,
      responseStream: false,
      options: {},
    },
    createStripeSetupIntent: {
      name: "CreateStripeSetupIntent",
      requestType: CreateStripeSetupIntentRequest,
      requestStream: false,
      responseType: CreateStripeSetupIntentResponse,
      responseStream: false,
      options: {},
    },
    getStripeConfig: {
      name: "GetStripeConfig",
      requestType: GetStripeConfigRequest,
      requestStream: false,
      responseType: GetStripeConfigResponse,
      responseStream: false,
      options: {},
    },
    refreshCustomerPaymentStatus: {
      name: "RefreshCustomerPaymentStatus",
      requestType: RefreshCustomerPaymentStatusRequest,
      requestStream: false,
      responseType: RefreshCustomerPaymentStatusResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface BillingServiceImplementation<CallContextExt = {}> {
  createCheckoutSession(
    request: CreateCheckoutSessionRequest,
    context: CallContext & CallContextExt
  ): Promise<CreateCheckoutSessionResponse>;
  cancelSubscription(
    request: CancelSubscriptionRequest,
    context: CallContext & CallContextExt
  ): Promise<CancelSubscriptionResponse>;
  syncStripeData(
    request: SyncStripeDataRequest,
    context: CallContext & CallContextExt
  ): Promise<SyncStripeDataResponse>;
  getOrCreateCustomer(
    request: GetOrCreateCustomerRequest,
    context: CallContext & CallContextExt
  ): Promise<GetOrCreateCustomerResponse>;
  createPaymentIntent(
    request: CreatePaymentIntentRequest,
    context: CallContext & CallContextExt
  ): Promise<CreatePaymentIntentResponse>;
  createSubscription(
    request: CreateSubscriptionRequest,
    context: CallContext & CallContextExt
  ): Promise<CreateSubscriptionResponse>;
  createStripeSetupIntent(
    request: CreateStripeSetupIntentRequest,
    context: CallContext & CallContextExt
  ): Promise<CreateStripeSetupIntentResponse>;
  getStripeConfig(
    request: GetStripeConfigRequest,
    context: CallContext & CallContextExt
  ): Promise<GetStripeConfigResponse>;
  refreshCustomerPaymentStatus(
    request: RefreshCustomerPaymentStatusRequest,
    context: CallContext & CallContextExt
  ): Promise<RefreshCustomerPaymentStatusResponse>;
}

export interface BillingServiceClient<CallOptionsExt = {}> {
  createCheckoutSession(
    request: CreateCheckoutSessionRequest,
    options?: CallOptions & CallOptionsExt
  ): Promise<CreateCheckoutSessionResponse>;
  cancelSubscription(
    request: CancelSubscriptionRequest,
    options?: CallOptions & CallOptionsExt
  ): Promise<CancelSubscriptionResponse>;
  syncStripeData(
    request: SyncStripeDataRequest,
    options?: CallOptions & CallOptionsExt
  ): Promise<SyncStripeDataResponse>;
  getOrCreateCustomer(
    request: GetOrCreateCustomerRequest,
    options?: CallOptions & CallOptionsExt
  ): Promise<GetOrCreateCustomerResponse>;
  createPaymentIntent(
    request: CreatePaymentIntentRequest,
    options?: CallOptions & CallOptionsExt
  ): Promise<CreatePaymentIntentResponse>;
  createSubscription(
    request: CreateSubscriptionRequest,
    options?: CallOptions & CallOptionsExt
  ): Promise<CreateSubscriptionResponse>;
  createStripeSetupIntent(
    request: CreateStripeSetupIntentRequest,
    options?: CallOptions & CallOptionsExt
  ): Promise<CreateStripeSetupIntentResponse>;
  getStripeConfig(
    request: GetStripeConfigRequest,
    options?: CallOptions & CallOptionsExt
  ): Promise<GetStripeConfigResponse>;
  refreshCustomerPaymentStatus(
    request: RefreshCustomerPaymentStatusRequest,
    options?: CallOptions & CallOptionsExt
  ): Promise<RefreshCustomerPaymentStatusResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
