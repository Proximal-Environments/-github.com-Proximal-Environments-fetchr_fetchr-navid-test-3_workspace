// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v5.29.3
// source: explore/explore.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  ExploreRequest,
  ExploreRequestSummary,
  Gender,
  genderFromJSON,
  genderToJSON,
  ImagePreferenceItem,
  PopulatedExploreMessage,
  PopulatedExploreRequestMessage,
  PopulatedExploreResponseMessage,
  ProductCategory,
  productCategoryFromJSON,
  productCategoryToJSON,
  ProductPreferenceItem,
  ProductWithScoreAndSearchQuery,
  ProductWithSearchQuery,
  ProductWithSearchQueryAndPreference,
} from "../base/base";

export const protobufPackage = "exploreServer";

export interface ReplyToChatRequest {
  requestId: string;
  messages: PopulatedExploreMessage[];
}

export interface ReplyToChatResponse {
  message: PopulatedExploreRequestMessage | undefined;
}

export interface ListExploreRequestSummariesRequest {
}

export interface ListExploreRequestSummariesResponse {
  summaries: ExploreRequestSummary[];
}

export interface FinalizeImagePreferencesRequest {
  requestId: string;
  toolId: string;
}

export interface FinalizeImagePreferencesResponse {
  message: string;
}

export interface AdminListAllExploreRequestsRequest {
  page?: number | undefined;
  pageSize?: number | undefined;
}

export interface AdminListAllExploreRequestsResponse {
  requests: ExploreRequest[];
}

export interface ProcessMessageRequest {
  requestId: string;
  message: PopulatedExploreResponseMessage | undefined;
}

export interface ProcessMessageResponse {
  message: PopulatedExploreRequestMessage | undefined;
}

/** Request/Response messages */
export interface CreateExploreRequestRequest {
  query: string;
  lowerBudget?: number | undefined;
  upperBudget?: number | undefined;
  brandIds: string[];
  category?: ProductCategory | undefined;
  gender?: Gender | undefined;
  isDevOnly?: boolean | undefined;
  message: PopulatedExploreResponseMessage | undefined;
  id?: string | undefined;
  productId?: string | undefined;
}

export interface CreateExploreRequestResponse {
  response?: { $case: "exploreRequestResult"; exploreRequestResult: ExploreRequestResult } | {
    $case: "processMessageResponse";
    processMessageResponse: ProcessMessageResponse;
  } | undefined;
}

export interface ExploreRequestResult {
  request: ExploreRequest | undefined;
}

export interface Done {
}

export interface MessageResult {
  message: string;
}

export interface StatusUpdate {
  status: string;
}

export interface ProductsResult {
  products: ProductWithScoreAndSearchQuery[];
  unrankedProducts: ProductWithSearchQuery[];
  intermediateQueries: string[];
}

export interface SubmitImagePreferenceRequest {
  toolId: string;
  requestId: string;
  preferenceItems: ImagePreferenceItem[];
}

export interface SubmitImagePreferenceResponse {
  message: string;
}

export interface SubmitPreferenceRequest {
  toolId: string;
  requestId: string;
  preferenceItems: ProductPreferenceItem[];
}

export interface SubmitPreferenceResponse {
  message: string;
}

export interface DeleteCohortRequest {
  requestId: string;
  cohort: number;
}

export interface DeleteCohortResponse {
  message: string;
}

export interface GetExploreRequestRequest {
  requestId: string;
}

export interface GetExploreRequestResponse {
  request: ExploreRequest | undefined;
  cohorts: { [key: number]: CohortData };
}

export interface GetExploreRequestResponse_CohortsEntry {
  key: number;
  value: CohortData | undefined;
}

export interface CohortData {
  products: ProductWithSearchQueryAndPreference[];
  intermediateQueries: string[];
  unrankedProducts: ProductWithSearchQuery[];
}

export interface ListExploreRequestsRequest {
  includeDevOnlyRequests?: boolean | undefined;
  page?: number | undefined;
  pageSize?: number | undefined;
}

export interface ListExploreRequestsResponse {
  requests: ExploreRequest[];
}

export interface DuplicateExploreRequestRequest {
  requestId: string;
}

export interface DuplicateExploreRequestResponse {
  newRequestId: string;
}

export interface DeleteExploreRequestRequest {
  requestId: string;
}

export interface DeleteExploreRequestResponse {
  message: string;
}

export interface StyleGenerationRequest {
  query: string;
  gender: Gender;
  numProducts: number;
  searchMethod?: string | undefined;
  category?: ProductCategory | undefined;
}

export interface StyleGenerationResponse {
  styles: ProductWithSearchQuery[];
  message?: string | undefined;
}

export interface SearchProductsAtCohortRequest {
  requestId: string;
  cohort: number;
  query: string;
  numProducts?: number | undefined;
  filterOutSeenProducts?: boolean | undefined;
}

export interface SearchProductsAtCohortResponse {
  /** Reranked results based on user preferences */
  rankedProducts: ProductWithScoreAndSearchQuery[];
  intermediateQueries: string[];
  /** Original search results before reranking */
  unrankedProducts: ProductWithScoreAndSearchQuery[];
}

function createBaseReplyToChatRequest(): ReplyToChatRequest {
  return { requestId: "", messages: [] };
}

export const ReplyToChatRequest: MessageFns<ReplyToChatRequest> = {
  encode(message: ReplyToChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    for (const v of message.messages) {
      PopulatedExploreMessage.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplyToChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplyToChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(PopulatedExploreMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplyToChatRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => PopulatedExploreMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReplyToChatRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => PopulatedExploreMessage.toJSON(e));
    }
    return obj;
  },
};

function createBaseReplyToChatResponse(): ReplyToChatResponse {
  return { message: undefined };
}

export const ReplyToChatResponse: MessageFns<ReplyToChatResponse> = {
  encode(message: ReplyToChatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      PopulatedExploreRequestMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplyToChatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplyToChatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = PopulatedExploreRequestMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplyToChatResponse {
    return { message: isSet(object.message) ? PopulatedExploreRequestMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: ReplyToChatResponse): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = PopulatedExploreRequestMessage.toJSON(message.message);
    }
    return obj;
  },
};

function createBaseListExploreRequestSummariesRequest(): ListExploreRequestSummariesRequest {
  return {};
}

export const ListExploreRequestSummariesRequest: MessageFns<ListExploreRequestSummariesRequest> = {
  encode(_: ListExploreRequestSummariesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExploreRequestSummariesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExploreRequestSummariesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListExploreRequestSummariesRequest {
    return {};
  },

  toJSON(_: ListExploreRequestSummariesRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseListExploreRequestSummariesResponse(): ListExploreRequestSummariesResponse {
  return { summaries: [] };
}

export const ListExploreRequestSummariesResponse: MessageFns<ListExploreRequestSummariesResponse> = {
  encode(message: ListExploreRequestSummariesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.summaries) {
      ExploreRequestSummary.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExploreRequestSummariesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExploreRequestSummariesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.summaries.push(ExploreRequestSummary.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExploreRequestSummariesResponse {
    return {
      summaries: globalThis.Array.isArray(object?.summaries)
        ? object.summaries.map((e: any) => ExploreRequestSummary.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListExploreRequestSummariesResponse): unknown {
    const obj: any = {};
    if (message.summaries?.length) {
      obj.summaries = message.summaries.map((e) => ExploreRequestSummary.toJSON(e));
    }
    return obj;
  },
};

function createBaseFinalizeImagePreferencesRequest(): FinalizeImagePreferencesRequest {
  return { requestId: "", toolId: "" };
}

export const FinalizeImagePreferencesRequest: MessageFns<FinalizeImagePreferencesRequest> = {
  encode(message: FinalizeImagePreferencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.toolId !== "") {
      writer.uint32(18).string(message.toolId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeImagePreferencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeImagePreferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeImagePreferencesRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      toolId: isSet(object.toolId) ? globalThis.String(object.toolId) : "",
    };
  },

  toJSON(message: FinalizeImagePreferencesRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.toolId !== "") {
      obj.toolId = message.toolId;
    }
    return obj;
  },
};

function createBaseFinalizeImagePreferencesResponse(): FinalizeImagePreferencesResponse {
  return { message: "" };
}

export const FinalizeImagePreferencesResponse: MessageFns<FinalizeImagePreferencesResponse> = {
  encode(message: FinalizeImagePreferencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeImagePreferencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeImagePreferencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeImagePreferencesResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: FinalizeImagePreferencesResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseAdminListAllExploreRequestsRequest(): AdminListAllExploreRequestsRequest {
  return { page: undefined, pageSize: undefined };
}

export const AdminListAllExploreRequestsRequest: MessageFns<AdminListAllExploreRequestsRequest> = {
  encode(message: AdminListAllExploreRequestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(16).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminListAllExploreRequestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminListAllExploreRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminListAllExploreRequestsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
    };
  },

  toJSON(message: AdminListAllExploreRequestsRequest): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },
};

function createBaseAdminListAllExploreRequestsResponse(): AdminListAllExploreRequestsResponse {
  return { requests: [] };
}

export const AdminListAllExploreRequestsResponse: MessageFns<AdminListAllExploreRequestsResponse> = {
  encode(message: AdminListAllExploreRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      ExploreRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminListAllExploreRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminListAllExploreRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(ExploreRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminListAllExploreRequestsResponse {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => ExploreRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AdminListAllExploreRequestsResponse): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => ExploreRequest.toJSON(e));
    }
    return obj;
  },
};

function createBaseProcessMessageRequest(): ProcessMessageRequest {
  return { requestId: "", message: undefined };
}

export const ProcessMessageRequest: MessageFns<ProcessMessageRequest> = {
  encode(message: ProcessMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.message !== undefined) {
      PopulatedExploreResponseMessage.encode(message.message, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = PopulatedExploreResponseMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessMessageRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      message: isSet(object.message) ? PopulatedExploreResponseMessage.fromJSON(object.message) : undefined,
    };
  },

  toJSON(message: ProcessMessageRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.message !== undefined) {
      obj.message = PopulatedExploreResponseMessage.toJSON(message.message);
    }
    return obj;
  },
};

function createBaseProcessMessageResponse(): ProcessMessageResponse {
  return { message: undefined };
}

export const ProcessMessageResponse: MessageFns<ProcessMessageResponse> = {
  encode(message: ProcessMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      PopulatedExploreRequestMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = PopulatedExploreRequestMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessMessageResponse {
    return { message: isSet(object.message) ? PopulatedExploreRequestMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: ProcessMessageResponse): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = PopulatedExploreRequestMessage.toJSON(message.message);
    }
    return obj;
  },
};

function createBaseCreateExploreRequestRequest(): CreateExploreRequestRequest {
  return {
    query: "",
    lowerBudget: undefined,
    upperBudget: undefined,
    brandIds: [],
    category: undefined,
    gender: undefined,
    isDevOnly: undefined,
    message: undefined,
    id: undefined,
    productId: undefined,
  };
}

export const CreateExploreRequestRequest: MessageFns<CreateExploreRequestRequest> = {
  encode(message: CreateExploreRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.lowerBudget !== undefined) {
      writer.uint32(29).float(message.lowerBudget);
    }
    if (message.upperBudget !== undefined) {
      writer.uint32(37).float(message.upperBudget);
    }
    for (const v of message.brandIds) {
      writer.uint32(42).string(v!);
    }
    if (message.category !== undefined) {
      writer.uint32(48).int32(message.category);
    }
    if (message.gender !== undefined) {
      writer.uint32(56).int32(message.gender);
    }
    if (message.isDevOnly !== undefined) {
      writer.uint32(64).bool(message.isDevOnly);
    }
    if (message.message !== undefined) {
      PopulatedExploreResponseMessage.encode(message.message, writer.uint32(74).fork()).join();
    }
    if (message.id !== undefined) {
      writer.uint32(82).string(message.id);
    }
    if (message.productId !== undefined) {
      writer.uint32(90).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExploreRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExploreRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.lowerBudget = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.upperBudget = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.brandIds.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isDevOnly = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.message = PopulatedExploreResponseMessage.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateExploreRequestRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      lowerBudget: isSet(object.lowerBudget) ? globalThis.Number(object.lowerBudget) : undefined,
      upperBudget: isSet(object.upperBudget) ? globalThis.Number(object.upperBudget) : undefined,
      brandIds: globalThis.Array.isArray(object?.brandIds) ? object.brandIds.map((e: any) => globalThis.String(e)) : [],
      category: isSet(object.category) ? productCategoryFromJSON(object.category) : undefined,
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : undefined,
      isDevOnly: isSet(object.isDevOnly) ? globalThis.Boolean(object.isDevOnly) : undefined,
      message: isSet(object.message) ? PopulatedExploreResponseMessage.fromJSON(object.message) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      productId: isSet(object.productId) ? globalThis.String(object.productId) : undefined,
    };
  },

  toJSON(message: CreateExploreRequestRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.lowerBudget !== undefined) {
      obj.lowerBudget = message.lowerBudget;
    }
    if (message.upperBudget !== undefined) {
      obj.upperBudget = message.upperBudget;
    }
    if (message.brandIds?.length) {
      obj.brandIds = message.brandIds;
    }
    if (message.category !== undefined) {
      obj.category = productCategoryToJSON(message.category);
    }
    if (message.gender !== undefined) {
      obj.gender = genderToJSON(message.gender);
    }
    if (message.isDevOnly !== undefined) {
      obj.isDevOnly = message.isDevOnly;
    }
    if (message.message !== undefined) {
      obj.message = PopulatedExploreResponseMessage.toJSON(message.message);
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.productId !== undefined) {
      obj.productId = message.productId;
    }
    return obj;
  },
};

function createBaseCreateExploreRequestResponse(): CreateExploreRequestResponse {
  return { response: undefined };
}

export const CreateExploreRequestResponse: MessageFns<CreateExploreRequestResponse> = {
  encode(message: CreateExploreRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.response?.$case) {
      case "exploreRequestResult":
        ExploreRequestResult.encode(message.response.exploreRequestResult, writer.uint32(10).fork()).join();
        break;
      case "processMessageResponse":
        ProcessMessageResponse.encode(message.response.processMessageResponse, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExploreRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExploreRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = {
            $case: "exploreRequestResult",
            exploreRequestResult: ExploreRequestResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.response = {
            $case: "processMessageResponse",
            processMessageResponse: ProcessMessageResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateExploreRequestResponse {
    return {
      response: isSet(object.exploreRequestResult)
        ? {
          $case: "exploreRequestResult",
          exploreRequestResult: ExploreRequestResult.fromJSON(object.exploreRequestResult),
        }
        : isSet(object.processMessageResponse)
        ? {
          $case: "processMessageResponse",
          processMessageResponse: ProcessMessageResponse.fromJSON(object.processMessageResponse),
        }
        : undefined,
    };
  },

  toJSON(message: CreateExploreRequestResponse): unknown {
    const obj: any = {};
    if (message.response?.$case === "exploreRequestResult") {
      obj.exploreRequestResult = ExploreRequestResult.toJSON(message.response.exploreRequestResult);
    } else if (message.response?.$case === "processMessageResponse") {
      obj.processMessageResponse = ProcessMessageResponse.toJSON(message.response.processMessageResponse);
    }
    return obj;
  },
};

function createBaseExploreRequestResult(): ExploreRequestResult {
  return { request: undefined };
}

export const ExploreRequestResult: MessageFns<ExploreRequestResult> = {
  encode(message: ExploreRequestResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      ExploreRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExploreRequestResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExploreRequestResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = ExploreRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExploreRequestResult {
    return { request: isSet(object.request) ? ExploreRequest.fromJSON(object.request) : undefined };
  },

  toJSON(message: ExploreRequestResult): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = ExploreRequest.toJSON(message.request);
    }
    return obj;
  },
};

function createBaseDone(): Done {
  return {};
}

export const Done: MessageFns<Done> = {
  encode(_: Done, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Done {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Done {
    return {};
  },

  toJSON(_: Done): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseMessageResult(): MessageResult {
  return { message: "" };
}

export const MessageResult: MessageFns<MessageResult> = {
  encode(message: MessageResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageResult {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: MessageResult): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseStatusUpdate(): StatusUpdate {
  return { status: "" };
}

export const StatusUpdate: MessageFns<StatusUpdate> = {
  encode(message: StatusUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusUpdate {
    return { status: isSet(object.status) ? globalThis.String(object.status) : "" };
  },

  toJSON(message: StatusUpdate): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },
};

function createBaseProductsResult(): ProductsResult {
  return { products: [], unrankedProducts: [], intermediateQueries: [] };
}

export const ProductsResult: MessageFns<ProductsResult> = {
  encode(message: ProductsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      ProductWithScoreAndSearchQuery.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.unrankedProducts) {
      ProductWithSearchQuery.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.intermediateQueries) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(ProductWithScoreAndSearchQuery.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unrankedProducts.push(ProductWithSearchQuery.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.intermediateQueries.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductsResult {
    return {
      products: globalThis.Array.isArray(object?.products)
        ? object.products.map((e: any) => ProductWithScoreAndSearchQuery.fromJSON(e))
        : [],
      unrankedProducts: globalThis.Array.isArray(object?.unrankedProducts)
        ? object.unrankedProducts.map((e: any) => ProductWithSearchQuery.fromJSON(e))
        : [],
      intermediateQueries: globalThis.Array.isArray(object?.intermediateQueries)
        ? object.intermediateQueries.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ProductsResult): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => ProductWithScoreAndSearchQuery.toJSON(e));
    }
    if (message.unrankedProducts?.length) {
      obj.unrankedProducts = message.unrankedProducts.map((e) => ProductWithSearchQuery.toJSON(e));
    }
    if (message.intermediateQueries?.length) {
      obj.intermediateQueries = message.intermediateQueries;
    }
    return obj;
  },
};

function createBaseSubmitImagePreferenceRequest(): SubmitImagePreferenceRequest {
  return { toolId: "", requestId: "", preferenceItems: [] };
}

export const SubmitImagePreferenceRequest: MessageFns<SubmitImagePreferenceRequest> = {
  encode(message: SubmitImagePreferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolId !== "") {
      writer.uint32(10).string(message.toolId);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    for (const v of message.preferenceItems) {
      ImagePreferenceItem.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitImagePreferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitImagePreferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.preferenceItems.push(ImagePreferenceItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitImagePreferenceRequest {
    return {
      toolId: isSet(object.toolId) ? globalThis.String(object.toolId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      preferenceItems: globalThis.Array.isArray(object?.preferenceItems)
        ? object.preferenceItems.map((e: any) => ImagePreferenceItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubmitImagePreferenceRequest): unknown {
    const obj: any = {};
    if (message.toolId !== "") {
      obj.toolId = message.toolId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.preferenceItems?.length) {
      obj.preferenceItems = message.preferenceItems.map((e) => ImagePreferenceItem.toJSON(e));
    }
    return obj;
  },
};

function createBaseSubmitImagePreferenceResponse(): SubmitImagePreferenceResponse {
  return { message: "" };
}

export const SubmitImagePreferenceResponse: MessageFns<SubmitImagePreferenceResponse> = {
  encode(message: SubmitImagePreferenceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitImagePreferenceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitImagePreferenceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitImagePreferenceResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: SubmitImagePreferenceResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseSubmitPreferenceRequest(): SubmitPreferenceRequest {
  return { toolId: "", requestId: "", preferenceItems: [] };
}

export const SubmitPreferenceRequest: MessageFns<SubmitPreferenceRequest> = {
  encode(message: SubmitPreferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolId !== "") {
      writer.uint32(10).string(message.toolId);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    for (const v of message.preferenceItems) {
      ProductPreferenceItem.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitPreferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitPreferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.preferenceItems.push(ProductPreferenceItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitPreferenceRequest {
    return {
      toolId: isSet(object.toolId) ? globalThis.String(object.toolId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      preferenceItems: globalThis.Array.isArray(object?.preferenceItems)
        ? object.preferenceItems.map((e: any) => ProductPreferenceItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubmitPreferenceRequest): unknown {
    const obj: any = {};
    if (message.toolId !== "") {
      obj.toolId = message.toolId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.preferenceItems?.length) {
      obj.preferenceItems = message.preferenceItems.map((e) => ProductPreferenceItem.toJSON(e));
    }
    return obj;
  },
};

function createBaseSubmitPreferenceResponse(): SubmitPreferenceResponse {
  return { message: "" };
}

export const SubmitPreferenceResponse: MessageFns<SubmitPreferenceResponse> = {
  encode(message: SubmitPreferenceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitPreferenceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitPreferenceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitPreferenceResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: SubmitPreferenceResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseDeleteCohortRequest(): DeleteCohortRequest {
  return { requestId: "", cohort: 0 };
}

export const DeleteCohortRequest: MessageFns<DeleteCohortRequest> = {
  encode(message: DeleteCohortRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.cohort !== 0) {
      writer.uint32(16).int32(message.cohort);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCohortRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCohortRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cohort = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCohortRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      cohort: isSet(object.cohort) ? globalThis.Number(object.cohort) : 0,
    };
  },

  toJSON(message: DeleteCohortRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.cohort !== 0) {
      obj.cohort = Math.round(message.cohort);
    }
    return obj;
  },
};

function createBaseDeleteCohortResponse(): DeleteCohortResponse {
  return { message: "" };
}

export const DeleteCohortResponse: MessageFns<DeleteCohortResponse> = {
  encode(message: DeleteCohortResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCohortResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCohortResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCohortResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: DeleteCohortResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseGetExploreRequestRequest(): GetExploreRequestRequest {
  return { requestId: "" };
}

export const GetExploreRequestRequest: MessageFns<GetExploreRequestRequest> = {
  encode(message: GetExploreRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExploreRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExploreRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExploreRequestRequest {
    return { requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "" };
  },

  toJSON(message: GetExploreRequestRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },
};

function createBaseGetExploreRequestResponse(): GetExploreRequestResponse {
  return { request: undefined, cohorts: {} };
}

export const GetExploreRequestResponse: MessageFns<GetExploreRequestResponse> = {
  encode(message: GetExploreRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      ExploreRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    Object.entries(message.cohorts).forEach(([key, value]) => {
      GetExploreRequestResponse_CohortsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExploreRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExploreRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = ExploreRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GetExploreRequestResponse_CohortsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.cohorts[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExploreRequestResponse {
    return {
      request: isSet(object.request) ? ExploreRequest.fromJSON(object.request) : undefined,
      cohorts: isObject(object.cohorts)
        ? Object.entries(object.cohorts).reduce<{ [key: number]: CohortData }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = CohortData.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetExploreRequestResponse): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = ExploreRequest.toJSON(message.request);
    }
    if (message.cohorts) {
      const entries = Object.entries(message.cohorts);
      if (entries.length > 0) {
        obj.cohorts = {};
        entries.forEach(([k, v]) => {
          obj.cohorts[k] = CohortData.toJSON(v);
        });
      }
    }
    return obj;
  },
};

function createBaseGetExploreRequestResponse_CohortsEntry(): GetExploreRequestResponse_CohortsEntry {
  return { key: 0, value: undefined };
}

export const GetExploreRequestResponse_CohortsEntry: MessageFns<GetExploreRequestResponse_CohortsEntry> = {
  encode(message: GetExploreRequestResponse_CohortsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      CohortData.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExploreRequestResponse_CohortsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExploreRequestResponse_CohortsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = CohortData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExploreRequestResponse_CohortsEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? CohortData.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetExploreRequestResponse_CohortsEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = CohortData.toJSON(message.value);
    }
    return obj;
  },
};

function createBaseCohortData(): CohortData {
  return { products: [], intermediateQueries: [], unrankedProducts: [] };
}

export const CohortData: MessageFns<CohortData> = {
  encode(message: CohortData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      ProductWithSearchQueryAndPreference.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.intermediateQueries) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.unrankedProducts) {
      ProductWithSearchQuery.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CohortData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCohortData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(ProductWithSearchQueryAndPreference.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.intermediateQueries.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unrankedProducts.push(ProductWithSearchQuery.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CohortData {
    return {
      products: globalThis.Array.isArray(object?.products)
        ? object.products.map((e: any) => ProductWithSearchQueryAndPreference.fromJSON(e))
        : [],
      intermediateQueries: globalThis.Array.isArray(object?.intermediateQueries)
        ? object.intermediateQueries.map((e: any) => globalThis.String(e))
        : [],
      unrankedProducts: globalThis.Array.isArray(object?.unrankedProducts)
        ? object.unrankedProducts.map((e: any) => ProductWithSearchQuery.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CohortData): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => ProductWithSearchQueryAndPreference.toJSON(e));
    }
    if (message.intermediateQueries?.length) {
      obj.intermediateQueries = message.intermediateQueries;
    }
    if (message.unrankedProducts?.length) {
      obj.unrankedProducts = message.unrankedProducts.map((e) => ProductWithSearchQuery.toJSON(e));
    }
    return obj;
  },
};

function createBaseListExploreRequestsRequest(): ListExploreRequestsRequest {
  return { includeDevOnlyRequests: undefined, page: undefined, pageSize: undefined };
}

export const ListExploreRequestsRequest: MessageFns<ListExploreRequestsRequest> = {
  encode(message: ListExploreRequestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeDevOnlyRequests !== undefined) {
      writer.uint32(8).bool(message.includeDevOnlyRequests);
    }
    if (message.page !== undefined) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(24).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExploreRequestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExploreRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.includeDevOnlyRequests = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExploreRequestsRequest {
    return {
      includeDevOnlyRequests: isSet(object.includeDevOnlyRequests)
        ? globalThis.Boolean(object.includeDevOnlyRequests)
        : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
    };
  },

  toJSON(message: ListExploreRequestsRequest): unknown {
    const obj: any = {};
    if (message.includeDevOnlyRequests !== undefined) {
      obj.includeDevOnlyRequests = message.includeDevOnlyRequests;
    }
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },
};

function createBaseListExploreRequestsResponse(): ListExploreRequestsResponse {
  return { requests: [] };
}

export const ListExploreRequestsResponse: MessageFns<ListExploreRequestsResponse> = {
  encode(message: ListExploreRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      ExploreRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExploreRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExploreRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(ExploreRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExploreRequestsResponse {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => ExploreRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListExploreRequestsResponse): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => ExploreRequest.toJSON(e));
    }
    return obj;
  },
};

function createBaseDuplicateExploreRequestRequest(): DuplicateExploreRequestRequest {
  return { requestId: "" };
}

export const DuplicateExploreRequestRequest: MessageFns<DuplicateExploreRequestRequest> = {
  encode(message: DuplicateExploreRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuplicateExploreRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateExploreRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateExploreRequestRequest {
    return { requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "" };
  },

  toJSON(message: DuplicateExploreRequestRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },
};

function createBaseDuplicateExploreRequestResponse(): DuplicateExploreRequestResponse {
  return { newRequestId: "" };
}

export const DuplicateExploreRequestResponse: MessageFns<DuplicateExploreRequestResponse> = {
  encode(message: DuplicateExploreRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newRequestId !== "") {
      writer.uint32(10).string(message.newRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuplicateExploreRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateExploreRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newRequestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateExploreRequestResponse {
    return { newRequestId: isSet(object.newRequestId) ? globalThis.String(object.newRequestId) : "" };
  },

  toJSON(message: DuplicateExploreRequestResponse): unknown {
    const obj: any = {};
    if (message.newRequestId !== "") {
      obj.newRequestId = message.newRequestId;
    }
    return obj;
  },
};

function createBaseDeleteExploreRequestRequest(): DeleteExploreRequestRequest {
  return { requestId: "" };
}

export const DeleteExploreRequestRequest: MessageFns<DeleteExploreRequestRequest> = {
  encode(message: DeleteExploreRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteExploreRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteExploreRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteExploreRequestRequest {
    return { requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "" };
  },

  toJSON(message: DeleteExploreRequestRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },
};

function createBaseDeleteExploreRequestResponse(): DeleteExploreRequestResponse {
  return { message: "" };
}

export const DeleteExploreRequestResponse: MessageFns<DeleteExploreRequestResponse> = {
  encode(message: DeleteExploreRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteExploreRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteExploreRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteExploreRequestResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: DeleteExploreRequestResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseStyleGenerationRequest(): StyleGenerationRequest {
  return { query: "", gender: 0, numProducts: 0, searchMethod: undefined, category: undefined };
}

export const StyleGenerationRequest: MessageFns<StyleGenerationRequest> = {
  encode(message: StyleGenerationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.gender !== 0) {
      writer.uint32(16).int32(message.gender);
    }
    if (message.numProducts !== 0) {
      writer.uint32(24).int32(message.numProducts);
    }
    if (message.searchMethod !== undefined) {
      writer.uint32(34).string(message.searchMethod);
    }
    if (message.category !== undefined) {
      writer.uint32(40).int32(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StyleGenerationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStyleGenerationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numProducts = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.searchMethod = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StyleGenerationRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : 0,
      numProducts: isSet(object.numProducts) ? globalThis.Number(object.numProducts) : 0,
      searchMethod: isSet(object.searchMethod) ? globalThis.String(object.searchMethod) : undefined,
      category: isSet(object.category) ? productCategoryFromJSON(object.category) : undefined,
    };
  },

  toJSON(message: StyleGenerationRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.gender !== 0) {
      obj.gender = genderToJSON(message.gender);
    }
    if (message.numProducts !== 0) {
      obj.numProducts = Math.round(message.numProducts);
    }
    if (message.searchMethod !== undefined) {
      obj.searchMethod = message.searchMethod;
    }
    if (message.category !== undefined) {
      obj.category = productCategoryToJSON(message.category);
    }
    return obj;
  },
};

function createBaseStyleGenerationResponse(): StyleGenerationResponse {
  return { styles: [], message: undefined };
}

export const StyleGenerationResponse: MessageFns<StyleGenerationResponse> = {
  encode(message: StyleGenerationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.styles) {
      ProductWithSearchQuery.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.message !== undefined) {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StyleGenerationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStyleGenerationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.styles.push(ProductWithSearchQuery.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StyleGenerationResponse {
    return {
      styles: globalThis.Array.isArray(object?.styles)
        ? object.styles.map((e: any) => ProductWithSearchQuery.fromJSON(e))
        : [],
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: StyleGenerationResponse): unknown {
    const obj: any = {};
    if (message.styles?.length) {
      obj.styles = message.styles.map((e) => ProductWithSearchQuery.toJSON(e));
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseSearchProductsAtCohortRequest(): SearchProductsAtCohortRequest {
  return { requestId: "", cohort: 0, query: "", numProducts: undefined, filterOutSeenProducts: undefined };
}

export const SearchProductsAtCohortRequest: MessageFns<SearchProductsAtCohortRequest> = {
  encode(message: SearchProductsAtCohortRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.cohort !== 0) {
      writer.uint32(16).int32(message.cohort);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    if (message.numProducts !== undefined) {
      writer.uint32(32).int32(message.numProducts);
    }
    if (message.filterOutSeenProducts !== undefined) {
      writer.uint32(40).bool(message.filterOutSeenProducts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchProductsAtCohortRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchProductsAtCohortRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cohort = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numProducts = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.filterOutSeenProducts = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchProductsAtCohortRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      cohort: isSet(object.cohort) ? globalThis.Number(object.cohort) : 0,
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      numProducts: isSet(object.numProducts) ? globalThis.Number(object.numProducts) : undefined,
      filterOutSeenProducts: isSet(object.filterOutSeenProducts)
        ? globalThis.Boolean(object.filterOutSeenProducts)
        : undefined,
    };
  },

  toJSON(message: SearchProductsAtCohortRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.cohort !== 0) {
      obj.cohort = Math.round(message.cohort);
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.numProducts !== undefined) {
      obj.numProducts = Math.round(message.numProducts);
    }
    if (message.filterOutSeenProducts !== undefined) {
      obj.filterOutSeenProducts = message.filterOutSeenProducts;
    }
    return obj;
  },
};

function createBaseSearchProductsAtCohortResponse(): SearchProductsAtCohortResponse {
  return { rankedProducts: [], intermediateQueries: [], unrankedProducts: [] };
}

export const SearchProductsAtCohortResponse: MessageFns<SearchProductsAtCohortResponse> = {
  encode(message: SearchProductsAtCohortResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rankedProducts) {
      ProductWithScoreAndSearchQuery.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.intermediateQueries) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.unrankedProducts) {
      ProductWithScoreAndSearchQuery.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchProductsAtCohortResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchProductsAtCohortResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rankedProducts.push(ProductWithScoreAndSearchQuery.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.intermediateQueries.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unrankedProducts.push(ProductWithScoreAndSearchQuery.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchProductsAtCohortResponse {
    return {
      rankedProducts: globalThis.Array.isArray(object?.rankedProducts)
        ? object.rankedProducts.map((e: any) => ProductWithScoreAndSearchQuery.fromJSON(e))
        : [],
      intermediateQueries: globalThis.Array.isArray(object?.intermediateQueries)
        ? object.intermediateQueries.map((e: any) => globalThis.String(e))
        : [],
      unrankedProducts: globalThis.Array.isArray(object?.unrankedProducts)
        ? object.unrankedProducts.map((e: any) => ProductWithScoreAndSearchQuery.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchProductsAtCohortResponse): unknown {
    const obj: any = {};
    if (message.rankedProducts?.length) {
      obj.rankedProducts = message.rankedProducts.map((e) => ProductWithScoreAndSearchQuery.toJSON(e));
    }
    if (message.intermediateQueries?.length) {
      obj.intermediateQueries = message.intermediateQueries;
    }
    if (message.unrankedProducts?.length) {
      obj.unrankedProducts = message.unrankedProducts.map((e) => ProductWithScoreAndSearchQuery.toJSON(e));
    }
    return obj;
  },
};

export type ExploreServiceDefinition = typeof ExploreServiceDefinition;
export const ExploreServiceDefinition = {
  name: "ExploreService",
  fullName: "exploreServer.ExploreService",
  methods: {
    /** Create a new explore request */
    createExploreRequest: {
      name: "CreateExploreRequest",
      requestType: CreateExploreRequestRequest,
      requestStream: false,
      responseType: CreateExploreRequestResponse,
      responseStream: true,
      options: {},
    },
    /** V2 Explore Endpoint */
    processMessage: {
      name: "ProcessMessage",
      requestType: ProcessMessageRequest,
      requestStream: false,
      responseType: ProcessMessageResponse,
      responseStream: true,
      options: {},
    },
    replyToChat: {
      name: "ReplyToChat",
      requestType: ReplyToChatRequest,
      requestStream: false,
      responseType: ReplyToChatResponse,
      responseStream: true,
      options: {},
    },
    /** Submit product preferences for a cohort */
    submitProductPreference: {
      name: "SubmitProductPreference",
      requestType: SubmitPreferenceRequest,
      requestStream: false,
      responseType: SubmitPreferenceResponse,
      responseStream: false,
      options: {},
    },
    /** Submit image preferences for a cohort */
    submitImagePreference: {
      name: "SubmitImagePreference",
      requestType: SubmitImagePreferenceRequest,
      requestStream: false,
      responseType: SubmitImagePreferenceResponse,
      responseStream: false,
      options: {},
    },
    /** Finalize image preferences for a cohort */
    finalizeImagePreferences: {
      name: "FinalizeImagePreferences",
      requestType: FinalizeImagePreferencesRequest,
      requestStream: false,
      responseType: FinalizeImagePreferencesResponse,
      responseStream: false,
      options: {},
    },
    /** Delete product preferences for a cohort */
    deleteProductPreferenceCohort: {
      name: "DeleteProductPreferenceCohort",
      requestType: DeleteCohortRequest,
      requestStream: false,
      responseType: DeleteCohortResponse,
      responseStream: false,
      options: {},
    },
    /** Get explore request details */
    getExploreRequest: {
      name: "GetExploreRequest",
      requestType: GetExploreRequestRequest,
      requestStream: false,
      responseType: GetExploreRequestResponse,
      responseStream: false,
      options: {},
    },
    /** List explore requests */
    listExploreRequests: {
      name: "ListExploreRequests",
      requestType: ListExploreRequestsRequest,
      requestStream: false,
      responseType: ListExploreRequestsResponse,
      responseStream: false,
      options: {},
    },
    listExploreRequestSummaries: {
      name: "ListExploreRequestSummaries",
      requestType: ListExploreRequestSummariesRequest,
      requestStream: false,
      responseType: ListExploreRequestSummariesResponse,
      responseStream: false,
      options: {},
    },
    adminListAllExploreRequests: {
      name: "AdminListAllExploreRequests",
      requestType: AdminListAllExploreRequestsRequest,
      requestStream: false,
      responseType: AdminListAllExploreRequestsResponse,
      responseStream: false,
      options: {},
    },
    /** Dev endpoints */
    duplicateExploreRequest: {
      name: "DuplicateExploreRequest",
      requestType: DuplicateExploreRequestRequest,
      requestStream: false,
      responseType: DuplicateExploreRequestResponse,
      responseStream: false,
      options: {},
    },
    deleteExploreRequest: {
      name: "DeleteExploreRequest",
      requestType: DeleteExploreRequestRequest,
      requestStream: false,
      responseType: DeleteExploreRequestResponse,
      responseStream: false,
      options: {},
    },
    deleteCohort: {
      name: "DeleteCohort",
      requestType: DeleteCohortRequest,
      requestStream: false,
      responseType: DeleteCohortResponse,
      responseStream: false,
      options: {},
    },
    generateStyles: {
      name: "GenerateStyles",
      requestType: StyleGenerationRequest,
      requestStream: false,
      responseType: StyleGenerationResponse,
      responseStream: false,
      options: {},
    },
    /** Search for products at a specific cohort */
    searchProductsAtCohort: {
      name: "SearchProductsAtCohort",
      requestType: SearchProductsAtCohortRequest,
      requestStream: false,
      responseType: SearchProductsAtCohortResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface ExploreServiceImplementation<CallContextExt = {}> {
  /** Create a new explore request */
  createExploreRequest(
    request: CreateExploreRequestRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<CreateExploreRequestResponse>;
  /** V2 Explore Endpoint */
  processMessage(
    request: ProcessMessageRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<ProcessMessageResponse>;
  replyToChat(
    request: ReplyToChatRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<ReplyToChatResponse>;
  /** Submit product preferences for a cohort */
  submitProductPreference(
    request: SubmitPreferenceRequest,
    context: CallContext & CallContextExt,
  ): Promise<SubmitPreferenceResponse>;
  /** Submit image preferences for a cohort */
  submitImagePreference(
    request: SubmitImagePreferenceRequest,
    context: CallContext & CallContextExt,
  ): Promise<SubmitImagePreferenceResponse>;
  /** Finalize image preferences for a cohort */
  finalizeImagePreferences(
    request: FinalizeImagePreferencesRequest,
    context: CallContext & CallContextExt,
  ): Promise<FinalizeImagePreferencesResponse>;
  /** Delete product preferences for a cohort */
  deleteProductPreferenceCohort(
    request: DeleteCohortRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeleteCohortResponse>;
  /** Get explore request details */
  getExploreRequest(
    request: GetExploreRequestRequest,
    context: CallContext & CallContextExt,
  ): Promise<GetExploreRequestResponse>;
  /** List explore requests */
  listExploreRequests(
    request: ListExploreRequestsRequest,
    context: CallContext & CallContextExt,
  ): Promise<ListExploreRequestsResponse>;
  listExploreRequestSummaries(
    request: ListExploreRequestSummariesRequest,
    context: CallContext & CallContextExt,
  ): Promise<ListExploreRequestSummariesResponse>;
  adminListAllExploreRequests(
    request: AdminListAllExploreRequestsRequest,
    context: CallContext & CallContextExt,
  ): Promise<AdminListAllExploreRequestsResponse>;
  /** Dev endpoints */
  duplicateExploreRequest(
    request: DuplicateExploreRequestRequest,
    context: CallContext & CallContextExt,
  ): Promise<DuplicateExploreRequestResponse>;
  deleteExploreRequest(
    request: DeleteExploreRequestRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeleteExploreRequestResponse>;
  deleteCohort(request: DeleteCohortRequest, context: CallContext & CallContextExt): Promise<DeleteCohortResponse>;
  generateStyles(
    request: StyleGenerationRequest,
    context: CallContext & CallContextExt,
  ): Promise<StyleGenerationResponse>;
  /** Search for products at a specific cohort */
  searchProductsAtCohort(
    request: SearchProductsAtCohortRequest,
    context: CallContext & CallContextExt,
  ): Promise<SearchProductsAtCohortResponse>;
}

export interface ExploreServiceClient<CallOptionsExt = {}> {
  /** Create a new explore request */
  createExploreRequest(
    request: CreateExploreRequestRequest,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<CreateExploreRequestResponse>;
  /** V2 Explore Endpoint */
  processMessage(
    request: ProcessMessageRequest,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<ProcessMessageResponse>;
  replyToChat(request: ReplyToChatRequest, options?: CallOptions & CallOptionsExt): AsyncIterable<ReplyToChatResponse>;
  /** Submit product preferences for a cohort */
  submitProductPreference(
    request: SubmitPreferenceRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SubmitPreferenceResponse>;
  /** Submit image preferences for a cohort */
  submitImagePreference(
    request: SubmitImagePreferenceRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SubmitImagePreferenceResponse>;
  /** Finalize image preferences for a cohort */
  finalizeImagePreferences(
    request: FinalizeImagePreferencesRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeImagePreferencesResponse>;
  /** Delete product preferences for a cohort */
  deleteProductPreferenceCohort(
    request: DeleteCohortRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeleteCohortResponse>;
  /** Get explore request details */
  getExploreRequest(
    request: GetExploreRequestRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetExploreRequestResponse>;
  /** List explore requests */
  listExploreRequests(
    request: ListExploreRequestsRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListExploreRequestsResponse>;
  listExploreRequestSummaries(
    request: ListExploreRequestSummariesRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListExploreRequestSummariesResponse>;
  adminListAllExploreRequests(
    request: AdminListAllExploreRequestsRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AdminListAllExploreRequestsResponse>;
  /** Dev endpoints */
  duplicateExploreRequest(
    request: DuplicateExploreRequestRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DuplicateExploreRequestResponse>;
  deleteExploreRequest(
    request: DeleteExploreRequestRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeleteExploreRequestResponse>;
  deleteCohort(request: DeleteCohortRequest, options?: CallOptions & CallOptionsExt): Promise<DeleteCohortResponse>;
  generateStyles(
    request: StyleGenerationRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StyleGenerationResponse>;
  /** Search for products at a specific cohort */
  searchProductsAtCohort(
    request: SearchProductsAtCohortRequest,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchProductsAtCohortResponse>;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
